<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>神域-戰鬥</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="style.css">
  <style>
    body { margin: 0; padding: 0; overflow: hidden; background-color: #000; position: fixed; width: 100%; height: 100%; }
    canvas { display: block; touch-action: none; }
  </style>
</head>
<body>
  <canvas id="battleCanvas"></canvas>

  <script>
    // --- 1. 遊戲基礎配置 ---
    const config = {
      canvasWidth: window.innerWidth,
      canvasHeight: window.innerHeight,
      enemySpeed: 1,
      heroAttackRange: 200,
      waveDelay: 5000, 
    };

    const gameState = {
      wave: 1,
      maxWave: 20,
      wallHP: 1000,
      maxWallHP: 1000,
      souls: 0,
      energy: 0,
      cageLevel: 0,
      heroLevel: 1,
      wallLevel: 1,
      killCount: 0,
      isPaused: false,
      gameTime: 0,
      nextWaveTime: 5000,
      waveInterval: 10000
    };

    // --- 2. 讀取來自 godrpg.html 的數據 ---
    const savedHero = JSON.parse(localStorage.getItem('battle_hero'));
    const savedCards = JSON.parse(localStorage.getItem('battle_cards'));

    // 初始化英雄
    const currentHero = {
      id: savedHero ? savedHero.id : 'knight',
      name: savedHero ? savedHero.name : '聖騎士',
      x: config.canvasWidth / 2,
      y: config.canvasHeight - 220,
      attack: savedHero ? savedHero.attack : 50,
      attackSpeed: savedHero ? (savedHero.speed || 1.0) : 1.0,
      range: savedHero ? (savedHero.range === 'long' ? 250 : 150) : 150,
      lastAttackTime: 0,
      image: new Image()
    };
    currentHero.image.src = savedHero ? savedHero.image : 'hero_basic.png';

    // 初始化技能卡 (固定 5 張)
    let battleCards = [];
    if (savedCards && savedCards.length > 0) {
      battleCards = savedCards.slice(0, 5).map(card => ({
        ...card,
        cd: (card.cd || 30) * 1000, // 秒轉毫秒
        lastUse: -60000,
        image: new Image()
      }));
      battleCards.forEach(c => c.image.src = c.image || 'skill_basic.png');
    } else {
      // 預設卡片
      battleCards = [
        { id: 'berserk', name: '狂戰', cost: 80, cd: 30000, lastUse: -30000, image: new Image() },
        { id: 'freeze', name: '冰封', cost: 120, cd: 45000, lastUse: -45000, image: new Image() },
        { id: 'meteor', name: '隕石', cost: 150, cd: 60000, lastUse: -60000, image: new Image() },
        { id: 'heal', name: '治癒', cost: 100, cd: 40000, lastUse: -40000, image: new Image() },
        { id: 'slow', name: '遲緩', cost: 70, cd: 25000, lastUse: -25000, image: new Image() }
      ];
      battleCards.forEach(c => c.image.src = 'skill_basic.png');
    }

    let enemies = [];
    let projectiles = [];
    let floatingTexts = [];

    const canvas = document.getElementById('battleCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = config.canvasWidth;
    canvas.height = config.canvasHeight;

    // --- 3. 類別定義 ---
    class Enemy {
      constructor(wave) {
        this.x = Math.random() * (canvas.width - 100) + 50;
        this.y = -50;
        this.hp = 50 + (wave * 12);
        this.maxHp = this.hp;
        this.speed = 0.5 + (wave * 0.05);
        this.radius = 20;
        this.reward = 5 + wave;
        this.image = new Image();
        this.image.src = 'enemy_basic.png';
      }
      update(deltaTime) {
        this.y += this.speed * (deltaTime / 16);
        if (this.y > canvas.height - 180) {
          gameState.wallHP -= 10;
          return false;
        }
        return true;
      }
      draw() {
        if (this.image.complete && this.image.naturalWidth > 0) {
          ctx.drawImage(this.image, this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
        } else {
          ctx.fillStyle = '#ef4444';
          ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill();
        }
        const barW = 40;
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(this.x - barW/2, this.y - this.radius - 10, barW, 5);
        ctx.fillStyle = '#22c55e';
        ctx.fillRect(this.x - barW/2, this.y - this.radius - 10, barW * (this.hp / this.maxHp), 5);
      }
      takeDamage(damage) {
        this.hp -= damage;
        floatingTexts.push({ x: this.x, y: this.y, text: Math.floor(damage), alpha: 1, dy: -2 });
        return this.hp <= 0;
      }
    }

    class Projectile {
      constructor(startX, startY, target) {
        this.x = startX; this.y = startY; this.target = target;
        this.speed = 8;
        this.damage = currentHero.attack * (1 + (gameState.heroLevel - 1) * 0.2);
      }
      update() {
        if (!this.target || this.target.hp <= 0) return false;
        const dx = this.target.x - this.x, dy = this.target.y - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 10) {
          if (this.target.takeDamage(this.damage)) {
            gameState.souls += this.target.reward;
            gameState.killCount++;
          }
          return false;
        }
        this.x += (dx / dist) * this.speed;
        this.y += (dy / dist) * this.speed;
        return true;
      }
      draw() {
        ctx.fillStyle = '#fbbf24';
        ctx.beginPath(); ctx.arc(this.x, this.y, 5, 0, Math.PI * 2); ctx.fill();
      }
    }

    // --- 4. 遊戲邏輯 ---
    function spawnWave(wave) {
      const enemyCount = 5 + (wave * 2);
      for (let i = 0; i < enemyCount; i++) {
        setTimeout(() => enemies.push(new Enemy(wave)), i * 600);
      }
    }

    function heroAttack(currentTime) {
      const interval = 1000 / currentHero.attackSpeed;
      if (currentTime - currentHero.lastAttackTime < interval) return;
      let nearest = null, minDist = currentHero.range;
      enemies.forEach(e => {
        const dist = Math.sqrt((e.x - currentHero.x)**2 + (e.y - currentHero.y)**2);
        if (dist < minDist) { minDist = dist; nearest = e; }
      });
      if (nearest) {
        projectiles.push(new Projectile(currentHero.x, currentHero.y, nearest));
        currentHero.lastAttackTime = currentTime;
      }
    }

    function useSkillCard(i) {
      const card = battleCards[i];
      const now = Date.now();
      if (!card) return;
      if (gameState.energy < card.cost) return showMessage('能量不足!');
      if (now - card.lastUse < card.cd) return showMessage('冷卻中!');
      
      gameState.energy -= card.cost;
      card.lastUse = now;
      
      if (card.id === 'berserk') {
        currentHero.attack *= 1.5; setTimeout(() => currentHero.attack /= 1.5, 10000);
        showMessage('狂暴提升攻擊!');
      } else if (card.id === 'freeze') {
        enemies.forEach(e => { e.speed *= 0.1; setTimeout(() => e.speed *= 10, 3000); });
        showMessage('冰封大地!');
      } else if (card.id === 'meteor') {
        enemies.forEach(e => e.takeDamage(200));
        showMessage('隕石天降!');
      } else if (card.id === 'heal') {
        gameState.wallHP = Math.min(gameState.wallHP + gameState.maxWallHP * 0.3, gameState.maxWallHP);
        showMessage('城牆修復!');
      } else if (card.id === 'slow') {
        enemies.forEach(e => { e.speed *= 0.5; setTimeout(() => e.speed *= 2, 8000); });
        showMessage('時間扭曲!');
      }
    }

    function upgrade(type) {
      let cost = 0;
      if (type === 'hero') cost = 100 * gameState.heroLevel;
      if (type === 'wall') cost = 100 * gameState.wallLevel;
      if (type === 'cage') cost = 150 * (gameState.cageLevel + 1);

      if (gameState.souls >= cost) {
        gameState.souls -= cost;
        if (type === 'hero') { gameState.heroLevel++; showMessage(`英雄升級 Lv.${gameState.heroLevel}`); }
        if (type === 'wall') { gameState.wallLevel++; gameState.maxWallHP += 50; gameState.wallHP += 50; showMessage(`城牆升級 Lv.${gameState.wallLevel}`); }
        if (type === 'cage') { gameState.cageLevel++; showMessage(`囚籠升級 Lv.${gameState.cageLevel}`); }
      }
    }

    let currentMessage = '', messageTime = 0;
    function showMessage(t) { currentMessage = t; messageTime = Date.now(); }

    // --- 5. 繪製 UI ---
    function drawUI() {
      const padding = 20;
      const fontSize = canvas.width < 500 ? 14 : 18;
      ctx.font = `bold ${fontSize}px Arial`;
      
      // 左上資訊
      const info = [`波次: ${gameState.wave-1}/${gameState.maxWave}`, `靈魂: ${Math.floor(gameState.souls)}`, `能量: ${Math.floor(gameState.energy)}` ];
      info.forEach((text, i) => {
        ctx.fillStyle = '#000'; ctx.fillText(text, padding+1, padding + (i*25)+1);
        ctx.fillStyle = '#fff'; ctx.fillText(text, padding, padding + (i*25));
      });

      // 城牆血條
      const bw = Math.min(400, canvas.width * 0.8), bh = 25, bx = (canvas.width - bw)/2, by = canvas.height - 180;
      ctx.fillStyle = '#1f2937'; ctx.fillRect(bx, by, bw, bh);
      const hpP = gameState.wallHP / gameState.maxWallHP;
      ctx.fillStyle = hpP > 0.3 ? '#22c55e' : '#ef4444';
      ctx.fillRect(bx, by, bw * hpP, bh);
      ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.strokeRect(bx, by, bw, bh);
      ctx.fillStyle = '#fff'; ctx.textAlign = 'center';
      ctx.fillText(`城牆 HP: ${Math.floor(gameState.wallHP)}`, canvas.width/2, by + 18);

      // 技能卡
      const cardSize = Math.min(70, (canvas.width - 60) / 5);
      const cardGap = 10;
      const totalW = (cardSize + cardGap) * battleCards.length - cardGap;
      const startX = (canvas.width - totalW)/2, cardY = canvas.height - 85;

      battleCards.forEach((card, i) => {
        const x = startX + i * (cardSize + cardGap);
        const cdRem = Math.max(0, card.cd - (Date.now() - card.lastUse));
        const canUse = gameState.energy >= card.cost && cdRem === 0;

        ctx.fillStyle = canUse ? '#7c3aed' : '#374151';
        ctx.fillRect(x, cardY, cardSize, cardSize);

        if (card.image.complete && card.image.naturalWidth > 0) {
          ctx.globalAlpha = canUse ? 1 : 0.4;
          ctx.drawImage(card.image, x+5, cardY+5, cardSize-10, cardSize-10);
          ctx.globalAlpha = 1;
        }

        if (cdRem > 0) {
          ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(x, cardY, cardSize, cardSize);
          ctx.fillStyle = '#fff'; ctx.textAlign = 'center';
          ctx.fillText(Math.ceil(cdRem/1000), x + cardSize/2, cardY + cardSize/2 + 6);
        }
        ctx.strokeStyle = canUse ? '#a78bfa' : '#4b5563';
        ctx.strokeRect(x, cardY, cardSize, cardSize);
      });

      // 右側升級按鈕
      const btnW = 100, btnH = 35, btnX = canvas.width - btnW - 15;
      ['英雄', '城牆', '囚籠'].forEach((label, i) => {
        const y = 80 + i * 45;
        ctx.fillStyle = '#4f46e5'; ctx.fillRect(btnX, y, btnW, btnH);
        ctx.fillStyle = '#fff'; ctx.textAlign = 'center'; ctx.font = '12px Arial';
        ctx.fillText(`升級${label}`, btnX + btnW/2, y + 22);
      });

      // 訊息與傷害
      if (Date.now() - messageTime < 2000) {
        ctx.font = 'bold 24px Arial'; ctx.fillStyle = '#fbbf24'; ctx.textAlign = 'center';
        ctx.fillText(currentMessage, canvas.width/2, 120);
      }
      floatingTexts = floatingTexts.filter(ft => {
        ft.y += ft.dy; ft.alpha -= 0.02;
        if (ft.alpha > 0) {
          ctx.globalAlpha = ft.alpha; ctx.fillStyle = '#ff6b6b'; ctx.font = 'bold 18px Arial';
          ctx.fillText(ft.text, ft.x, ft.y); ctx.globalAlpha = 1; return true;
        }
        return false;
      });
    }

    function drawHero() {
      ctx.strokeStyle = 'rgba(139, 92, 246, 0.4)';
      ctx.beginPath(); ctx.arc(currentHero.x, currentHero.y, currentHero.range, 0, Math.PI*2); ctx.stroke();
      if (currentHero.image.complete && currentHero.image.naturalWidth > 0) {
        ctx.drawImage(currentHero.image, currentHero.x - 30, currentHero.y - 30, 60, 60);
      } else {
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(currentHero.x - 25, currentHero.y - 25, 50, 50);
        ctx.fillStyle = '#fff'; ctx.textAlign = 'center'; ctx.fillText('HERO', currentHero.x, currentHero.y + 5);
      }
    }

    function gameLoop() {
      const now = Date.now();
      const dt = now - lastTime;
      lastTime = now;
      ctx.fillStyle = '#0f172a'; ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      gameState.energy += (1 + gameState.cageLevel * 2) * (dt / 1000);
      gameState.gameTime += dt;

      if (enemies.length === 0 && gameState.gameTime >= gameState.nextWaveTime && gameState.wave <= gameState.maxWave) {
        spawnWave(gameState.wave);
        gameState.wave++;
        gameState.nextWaveTime = gameState.gameTime + gameState.waveInterval;
        showMessage(`第 ${gameState.wave - 1} 波來襲!`);
      }

      enemies = enemies.filter(e => e.update(dt));
      projectiles = projectiles.filter(p => p.update());
      heroAttack(now);

      drawHero();
      enemies.forEach(e => e.draw());
      projectiles.forEach(p => p.draw());
      drawUI();

      if (gameState.wallHP <= 0) {
        ctx.fillStyle = 'rgba(0,0,0,0.8)'; ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = '#ef4444'; ctx.textAlign = 'center'; ctx.font = '40px Arial';
        ctx.fillText('遊戲失敗', canvas.width/2, canvas.height/2);
        return;
      }
      requestAnimationFrame(gameLoop);
    }

    canvas.addEventListener('click', (e) => {
      const x = e.clientX, y = e.clientY;
      // 技能點擊
      const cardSize = Math.min(70, (canvas.width - 60) / 5), cardGap = 10;
      const totalW = (cardSize + cardGap) * battleCards.length - cardGap;
      const startX = (canvas.width - totalW)/2, cardY = canvas.height - 85;
      battleCards.forEach((c, i) => {
        const cx = startX + i * (cardSize + cardGap);
        if (x >= cx && x <= cx + cardSize && y >= cardY && y <= cardY + cardSize) useSkillCard(i);
      });
      // 升級按鈕點擊
      const btnW = 100, btnX = canvas.width - btnW - 15;
      if (x >= btnX && x <= btnX + btnW) {
        if (y >= 80 && y <= 115) upgrade('hero');
        else if (y >= 125 && y <= 160) upgrade('wall');
        else if (y >= 170 && y <= 205) upgrade('cage');
      }
    });

    let lastTime = Date.now();
    showMessage('準備戰鬥!');
    setTimeout(gameLoop, 2000);
  </script>
</body>
</html>