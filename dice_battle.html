<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>éª°å­æˆ°çˆ­ - æˆ°å ´</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            height: 100dvh;
            /* ä½¿ç”¨ dvh ç¢ºä¿åœ¨æ‰‹æ©Ÿä¸Šè‡ªå‹•æ‰£é™¤ç¶²å€åˆ—é«˜åº¦ */
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            background-color: #020617;
        }

        #header-info {
            flex-shrink: 0;
            /* å›ºå®šé ­éƒ¨é«˜åº¦ */
        }

        #footer-controls {
            flex-shrink: 0;
            /* å›ºå®šåº•éƒ¨é«˜åº¦ */
            padding: 12px;
            padding-bottom: env(safe-area-inset-bottom, 20px);
            /* é‡å° iPhone åº•éƒ¨ç™½æ¢çš„æ’ç‰ˆå„ªåŒ– */
            background: rgba(15, 23, 42, 0.95);
            border-top: 1px solid rgba(51, 65, 85, 0.5);
        }

        #canvas-container {
            flex-grow: 1;
            position: relative;
            width: 100%;
            overflow: hidden;
        }

        #gameCanvas {
            background: radial-gradient(circle, #1e293b 0%, #020617 100%);
            touch-action: none;
            width: 100%;
            height: 100%;
        }

        .glass-panel {
            background: rgba(30, 41, 49, 0.8);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .diff-card {
            transition: all 0.3s;
            border: 2px solid transparent;
            cursor: pointer;
        }

        .diff-card:active {
            transform: scale(0.95);
        }

        .energy-glow {
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.5);
        }

        .scroll-hide::-webkit-scrollbar {
            display: none;
        }
    </style>
</head>

<body class="flex flex-col h-screen bg-slate-900">
    <div id="header-info" class="p-3 flex justify-between items-center bg-slate-900/50">
        <div class="flex items-center gap-4">
            <span class="text-red-500 font-bold">HP: <span id="hpText">3</span></span>
            <span class="text-blue-400 font-bold">SP: <span id="spText">100</span></span>
        </div>
        <div class="text-slate-400 font-bold text-sm">WAVE: <span id="waveText">1</span></div>
    </div>

    <div id="canvas-container" class="flex-1 relative">
        <canvas id="gameCanvas" style="width: 100%; height: 100%; display: block;"></canvas>
    </div>

    <div id="footer-controls" class="p-3 max-w-[500px] mx-auto w-full">
        <div class="flex flex-nowrap w-full gap-1 mb-4">
            <div id="powerUpButtons" class="contents"></div>
        </div>
        <button onclick="summonDice()"
            class="w-full py-4 bg-blue-600 rounded-xl font-black text-xl shadow-lg active:scale-95 transition-all text-white">
            å¬å–šéª°å­ (<span id="summonCostText">10</span> SP)
        </button>
    </div>

    <div id="difficultyOverlay" class="fixed inset-0 z-50 bg-black/95 flex items-center justify-center p-6">
        <div class="w-full max-w-sm">
            <h2
                class="text-center text-2xl font-black mb-8 text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-400">
                é¸æ“‡æˆ°é¬¥é›£åº¦</h2>
            <div class="space-y-4">
                <button onclick="startGame('normal')"
                    class="w-full bg-slate-800 p-4 rounded-2xl flex justify-between items-center border border-slate-700 active:bg-slate-700">
                    <span class="font-bold text-lg text-white">ç°¡å–®æ¨¡å¼</span>
                    <span class="text-xs text-green-400 bg-green-900/30 px-2 py-1 rounded">1x çå‹µ</span>
                </button>
                <button onclick="startGame('hard')"
                    class="w-full bg-slate-800 p-4 rounded-2xl flex justify-between items-center border border-blue-500/50 active:bg-slate-700">
                    <span class="font-bold text-lg text-white">å›°é›£æ¨¡å¼</span>
                    <span class="text-xs text-blue-400 bg-blue-900/30 px-2 py-1 rounded">2.5x çå‹µ</span>
                </button>
                <button onclick="startGame('hell')"
                    class="w-full bg-slate-800 p-4 rounded-2xl flex justify-between items-center border border-red-500/50 active:bg-slate-700">
                    <span class="font-bold text-lg text-red-500">åœ°ç„æ¨¡å¼</span>
                    <span class="text-xs text-red-400 bg-red-900/30 px-2 py-1 rounded">6x çå‹µ</span>
                </button>
            </div>
        </div>
    </div>

    <div id="resultModal"
        style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index:9999; flex-direction:column; align-items:center; justify-content:center; color:white;">

        <h1 id="resTitle" style="font-size:40px; margin:10px 0;">æˆ°ç¸¾çµç®—</h1>

        <div
            style="background:#1e293b; padding:20px; border-radius:15px; border:2px solid #3b82f6; text-align:center; min-width:250px;">
            <p style="font-size:18px; margin:5px 0;">æ’éæ³¢æ•¸ï¼š<span id="resWave" style="color:#facc15;">0</span> / 20</p>
            <hr style="border:0; border-top:1px solid #475569; margin:15px 0;">
            <p style="margin:5px 0;">ç²å¾—çå‹µ</p>
            <div style="font-size:28px; font-weight:bold; color:#10b981; margin-top:10px;">
                ğŸ« æŠ½çåˆ¸ x <span id="resTickets">0</span>
            </div>
        </div>

        <button onclick="location.href='dice.html'"
            style="margin-top:30px; padding:12px 35px; font-size:18px; background:#3b82f6; color:white; border:none; border-radius:8px; font-weight:bold;">
            é ˜å–ä¸¦å›å¤§å»³
        </button>
    </div>
    <script>
        const QUALITIES = {
            common: { name: 'æ™®é€š', color: '#ffffff', chance: 0.60 },   // 60% æ©Ÿç‡
            rare: { name: 'ç¨€æœ‰', color: '#3b82f6', chance: 0.25 },   // 25% æ©Ÿç‡
            epic: { name: 'å²è©©', color: '#a855f7', chance: 0.10 },   // 10% æ©Ÿç‡
            legend: { name: 'å‚³èªª', color: '#eab308', chance: 0.04 },   // 4% æ©Ÿç‡
            mythic: { name: 'ç¥è©±', color: '#ff00ff', chance: 0.01 }    // 1% æ©Ÿç‡
        };

        const ALL_DICES = [
            // --- Common (æ™®é€š) ---
            {
                id: 'fire', name: 'ç«', quality: 'common', baseColor: '#ef4444',
                stats: { atk: 15, speed: 50 }, grow: { atk: 5, speed: -1 },
                special: { label: 'æ¿ºå°„ç¯„åœ', value: 1.0, unit: 'æ ¼', grow: 0.1 }
            },
            {
                id: 'wind', name: 'é¢¨', quality: 'common', baseColor: '#10b981',
                stats: { atk: 10, speed: 20 }, grow: { atk: 3, speed: -2 },
                special: { label: 'é€£æ“Šæ©Ÿç‡', value: 10, unit: '%', grow: 3 }
            },
            {
                id: 'ice', name: 'å†°', quality: 'common', baseColor: '#3b82f6',
                stats: { atk: 8, speed: 60 }, grow: { atk: 2, speed: -1 },
                special: { label: 'ç·©é€Ÿæ•ˆæœ', value: 15, unit: '%', grow: 5 }
            },
            {
                id: 'electric', name: 'é›»', quality: 'common', baseColor: '#f59e0b',
                stats: { atk: 7, speed: 40 }, grow: { atk: 2, speed: -1 },
                special: { label: 'é€£é–ç›®æ¨™', value: 3, unit: 'é«”', grow: 1 }
            },
            {
                id: 'poison', name: 'æ¯’', quality: 'common', baseColor: '#008000',
                stats: { atk: 6, speed: 45 }, grow: { atk: 2, speed: -1 },
                special: { label: 'ä¸­æ¯’å‚·å®³', value: 5, unit: 'pt', grow: 3 }
            },

            // --- Rare (ç¨€æœ‰) ---
            {
                id: 'lock', name: 'é–å®š', quality: 'rare', baseColor: '#64748b',
                stats: { atk: 10, speed: 55 }, grow: { atk: 4, speed: -1 },
                special: { label: 'ç¦éŒ®æ™‚é•·', value: 0.5, unit: 'ç§’', grow: 0.2 }
            },

            // --- Epic (å²è©©) ---
            {
                id: 'teleport', name: 'å‚³é€', quality: 'epic', baseColor: '#8b5cf6',
                stats: { atk: 5, speed: 65 }, grow: { atk: 2, speed: -1 },
                special: { label: 'å‚³é€å›çµ‚é»', value: 5, unit: '%', grow: 2 }
            },
            {
                id: 'gear', name: 'é½’è¼ª', quality: 'epic', baseColor: '#475569',
                stats: { atk: 12, speed: 50 }, grow: { atk: 6, speed: -1 },
                special: { label: 'é€£çµåŠ æˆ', value: 10, unit: '%', grow: 5 }
            },

            // --- Legend (å‚³èªª) ---
            {
                id: 'joker', name: 'å°ä¸‘', quality: 'legend', baseColor: '#f87171',
                stats: { atk: 5, speed: 50 }, grow: { atk: 1, speed: 0 },
                special: { label: 'ç¹¼æ‰¿æ¯”ä¾‹', value: 80, unit: '%', grow: 2 }
            },
            {
                id: 'growth', name: 'æˆé•·', quality: 'legend', baseColor: '#f472b6',
                stats: { atk: 10, speed: 50 }, grow: { atk: 5, speed: -1 },
                special: { label: 'æˆé•·æ™‚é–“', value: 60, unit: 'ç§’', grow: -2 }
            },
            {
                id: 'sun', name: 'å¤ªé™½', quality: 'legend', baseColor: '#fbbf24',
                stats: { atk: 25, speed: 55 }, grow: { atk: 12, speed: -0.5 },
                special: { label: 'æ¿ºå°„çˆ†ç™¼', value: 100, unit: '%', grow: 20 }
            },

            // --- Mythic (ç¥è©±) ---
            {
                id: 'galaxy', name: 'éŠ€æ²³', quality: 'mythic', baseColor: '#6366f1',
                stats: { atk: 40, speed: 45 }, grow: { atk: 20, speed: -1 },
                special: { label: 'é»‘æ´åå™¬', value: 1, unit: '%', grow: 0.5 }
            }
        ];

        const BOSS_TYPES = {
            'CRUSHER': {
                name: 'ç²‰ç¢è€…', color: '#ff4444', skillInterval: 300, onSkill: (boss) => {
                    const occupied = grid.slots.filter(s => s.dice && !s.isLocked);
                    if (occupied.length > 0) {
                        const target = occupied[Math.floor(Math.random() * occupied.length)];
                        target.isLocked = true;
                        setTimeout(() => { target.isLocked = false; }, 4000);
                    }
                }
            },
            'SNAKE': {
                name: 'å™´å°„è€…', color: '#22c55e', skillInterval: 240, onSkill: (boss) => {
                    enemies.forEach(e => e.speed *= 1.5);
                    setTimeout(() => { enemies.forEach(e => e.speed /= 1.5); }, 2000);
                }
            }
        };

        const userData = JSON.parse(localStorage.getItem('dice_game_data')) || {
            deck: ['fire', 'wind', 'ice', 'electric', 'poison'],
            diceLevels: { 'fire': 1, 'wind': 1, 'ice': 1, 'electric': 1, 'poison': 1 }
        };
        if (userData.tickets === undefined) userData.tickets = 0;
        let battleState = { hp: 3, sp: 100, wave: 1, summonCost: 10, difficulty: 'normal', isStarted: false };
        let powerUpLevels = {};
        userData.deck.forEach(id => { powerUpLevels[id] = 1; });
        let frameCount = 0;
        let grid = { rows: 3, cols: 5, padding: 10, slotSize: 0, slots: [], y: 0 };
        let drag = { isDragging: false, fromSlot: null, currentX: 0, currentY: 0, dice: null };
        let waveState = { totalEnemiesPerWave: 10, spawnedCount: 0, isWaiting: false, timer: 0 };
        let projectiles = [], enemies = [], path = [], damagePopups = [];

        function startGame(diff) {
            battleState.difficulty = diff;
            battleState.isStarted = true;
            document.getElementById('difficultyOverlay').style.display = 'none';
            initGame();
        }

        function initGame() {
            const canvas = document.getElementById('gameCanvas');
            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;

            initGrid(canvas);
            initPath(canvas);
            setupTouchEvents(canvas);
            updateUI();
            startRenderLoop();
        }

        function initGrid(canvas) {
            const sideMargin = 15;
            grid.slotSize = (canvas.width - (grid.cols + 1) * grid.padding - (sideMargin * 2)) / grid.cols;
            const totalGridHeight = grid.rows * (grid.slotSize + grid.padding);
            grid.y = (canvas.height / 2) - (totalGridHeight / 2);
            grid.slots = [];
            for (let i = 0; i < grid.rows * grid.cols; i++) {
                const r = Math.floor(i / grid.cols), c = i % grid.cols;
                grid.slots.push({
                    x: sideMargin + grid.padding + c * (grid.slotSize + grid.padding),
                    y: grid.y + r * (grid.slotSize + grid.padding),
                    dice: null, isLocked: false, isBeingDragged: false, attackCooldown: 0
                });
            }
        }
        function getDiceSpecialValue(diceId) {
            if (!diceId) return 0;
            const dice = ALL_DICES.find(d => d.id === diceId);
            if (!dice || !dice.special) return 0;

            const lv = (userData.diceLevels && userData.diceLevels[diceId]) ? userData.diceLevels[diceId] : 1;

            // åŠ ä¸Š || 0 ç¢ºä¿å¦‚æœè³‡æ–™è¡¨æ²’å¯« value æˆ– growï¼Œä¸æœƒè®Šæˆ NaN
            const base = dice.special.value || 0;
            const grow = dice.special.grow || 0;

            return base + (lv - 1) * grow;
        }
        function transformJoker(jokerDice, targetDice) {
            const ratio = getDiceSpecialValue('joker') / 100; // æ‹¿åˆ° 0.8, 0.82...

            jokerDice.name = targetDice.name;
            jokerDice.baseColor = targetDice.baseColor;

            // ç¹¼æ‰¿æ”»æ“ŠåŠ› (å—æ¯”ä¾‹å½±éŸ¿)
            jokerDice.atk = targetDice.atk * ratio;

            // å¦‚æœè¤‡è£½çš„æ˜¯æˆé•·éª°å­ï¼Œæ™‚é–“è¦è®Šé•· (æ•ˆç‡é™ä½)
            if (targetDice.id === 'growth') {
                const targetTime = getDiceSpecialValue('growth');
                jokerDice.timer = targetTime / ratio; // ä¾‹å¦‚ 60 / 0.8 = 75ç§’
            }
        }
        function handleGameOver(isVictory) {
            // è¨ˆç®—çå‹µ
            let earnedTickets = 0;

            if (isVictory) {
                // å®Œå…¨é€šé—œ (20æ³¢)ï¼šçµ¦äºˆå¤§çï¼Œä¾‹å¦‚ 5 å¼µæŠ½çåˆ¸
                earnedTickets = 5;
            } else {
                // ä¸­é€”æˆ°æ•—ï¼šæ¯ 5 æ³¢çµ¦ 1 å¼µï¼Œæœªæ»¿ 5 æ³¢è‡³å°‘çµ¦ 0 æˆ– 1 å¼µ
                earnedTickets = Math.floor(battleState.wave / 5);
            }

            // å­˜æª”åˆ° LocalStorage
            userData.tickets = (userData.tickets || 0) + earnedTickets;
            localStorage.setItem('dice_game_data', JSON.stringify(userData));

            // é¡¯ç¤ºçµç®—è¦–çª—
            showResultModal(isVictory, battleState.wave, earnedTickets);
        }
        function showResultModal(isVictory, wave, tickets) {
            const modal = document.getElementById('resultModal');
            const title = document.getElementById('resTitle');

            if (isVictory) {
                title.innerText = "ğŸ‰ å®Œç¾é€šé—œ";
                title.style.color = "#facc15"; // é‡‘è‰²
            } else {
                title.innerText = "ğŸ’€ æˆ°æ•—";
                title.style.color = "#ef4444"; // ç´…è‰²
            }

            document.getElementById('resWave').innerText = wave;
            document.getElementById('resTickets').innerText = tickets;
            modal.style.display = 'flex';
        }
        function initPath(canvas) {
            const L = 25, R = canvas.width - 25, T = grid.y - 50, B = grid.y + (grid.rows * (grid.slotSize + grid.padding)) + 20;
            path = [{ x: L, y: T }, { x: R, y: T }, { x: R, y: B }, { x: L, y: B }, { x: L, y: T + 5 }];
        }

        function summonDice() {
            if (battleState.sp < battleState.summonCost) return;
            const emptySlots = grid.slots.filter(s => s.dice === null);
            if (emptySlots.length === 0) return;

            battleState.sp -= battleState.summonCost;
            battleState.summonCost += 10;

            const targetSlot = emptySlots[Math.floor(Math.random() * emptySlots.length)];
            const diceId = userData.deck[Math.floor(Math.random() * userData.deck.length)];
            const db = ALL_DICES.find(d => d.id === diceId);

            // å¼·åˆ¶è¨­å®š lv ç‚º 1
            targetSlot.dice = {
                id: diceId,
                lv: 1, // é€™è£¡ç¢ºä¿æ˜¯ 1
                color: db.baseColor,
                qualityColor: QUALITIES[db.quality].color,
                growthTimer: 0,   // çµ¦æˆé•·éª°å­ç”¨
                isPowered: false, // çµ¦é½’è¼ª/å¤ªé™½ç”¨
                attackCooldown: 0
            };

            // æ‹›å–šå¾Œç«‹åˆ»é‡ç®—ä¸€æ¬¡å¤ªé™½æ•¸é‡ï¼Œé¿å… updateCombat é–ƒé€€
            updateUI();
        }

        function powerUpDice(id) {
            const lv = powerUpLevels[id] || 1;
            const cost = 100 * Math.pow(2, lv - 1);
            if (battleState.sp >= cost && lv < 5) {
                battleState.sp -= cost;
                powerUpLevels[id] = lv + 1;
                updateUI();
            }
        }

        function spawnEnemy() {
            let mult = (battleState.difficulty === 'hell' ? 1.5 : battleState.difficulty === 'hard' ? 1.3 : 1.15);
            const hp = 100 * Math.pow(mult, battleState.wave - 1);
            enemies.push({ x: path[0].x, y: path[0].y, pathIndex: 1, maxHp: hp, hp, virtualHp: hp, speed: 1.5, rewardSp: 10 + Math.floor(battleState.wave / 2), isBoss: false });
        }

        function spawnBoss() {
            const type = Object.keys(BOSS_TYPES)[Math.floor(Math.random() * 2)];
            const hp = 2000 * Math.pow(1.4, battleState.wave / 10);
            enemies.push({ x: path[0].x, y: path[0].y, pathIndex: 1, maxHp: hp, hp, virtualHp: hp, speed: 0.8, rewardSp: 150, isBoss: true, bossType: type, skillTimer: 0, size: 50, color: BOSS_TYPES[type].color });
        }

        function updateCombat() {
            // A. å…ˆè¨ˆç®—å…¨å ´å¤ªé™½æ•¸é‡ (åªéœ€ç®—ä¸€æ¬¡)
            const totalSunCount = grid.slots.filter(s => s.dice && s.dice.id === 'sun').length;
            const isSunActivated = [1, 4, 7].includes(totalSunCount);

            grid.slots.forEach(slot => {
                if (slot.dice && slot.dice.id && !slot.isBeingDragged && !slot.isLocked) {
                    const db = ALL_DICES.find(d => d.id === slot.dice.id);
                    if (!db) return;
                    const pLv = userData.diceLevels[slot.dice.id] || 1;

                    // --- 1. æˆé•·éª°å­é‚è¼¯ (ä¿æŒä¸è®Š) ---
                    if (slot.dice.id === 'growth') {
                        if (!slot.dice.growthTimer) slot.dice.growthTimer = 0;
                        slot.dice.growthTimer++;
                        // å‹•æ…‹ç²å–æˆé•·æ™‚é–“ï¼ˆä¾‹å¦‚ 60ç§’ã€58ç§’...ï¼‰
                        const targetSeconds = getDiceSpecialValue('growth');
                        if (slot.dice.growthTimer >= targetSeconds * 60) { // 60fps
                            if (slot.dice.lv < 7) {
                                const newId = userData.deck[Math.floor(Math.random() * userData.deck.length)];
                                const newDb = ALL_DICES.find(d => d.id === newId);
                                slot.dice = {
                                    id: newId,
                                    lv: slot.dice.lv + 1,
                                    color: newDb.baseColor,
                                    qualityColor: QUALITIES[newDb.quality].color,
                                    growthTimer: 0
                                };
                                updateUI();
                            }
                        }
                    }

                    // --- 2. æ”»é€Ÿè¨ˆç®— (å«å¤ªé™½ç™¼å…‰åˆ¤æ–·) ---
                    let spd = Math.max(10, db.stats.speed + (pLv - 1) * db.grow.speed);

                    // é—œéµä¿®æ­£ï¼šåªæœ‰ã€Œè‡ªå·±æ˜¯å¤ªé™½ã€ä¸”ã€Œç¬¦åˆç™¼å…‰æ¢ä»¶ã€æ‰åŠ é€Ÿ
                    if (slot.dice.id === 'sun' && isSunActivated) {
                        spd /= 2.5;
                    }

                    slot.attackCooldown++;
                    if (slot.attackCooldown >= spd) {
                        // å„ªå…ˆæ”»æ“Šæœ€å‰æ–¹çš„æ€ª
                        const target = enemies.filter(e => (e.virtualHp || e.hp) > 0).sort((a, b) => b.pathIndex - a.pathIndex)[0];

                        if (target) {
                            const powerUpLv = powerUpLevels[slot.dice.id] || 1;
                            let dmg = (db.stats.atk + (pLv - 1) * db.grow.atk) * slot.dice.lv * (1 + (powerUpLv - 1) * 0.4);
                            if (slot.dice.id === 'joker') {
                                // ä¾æ“šç¹¼æ‰¿æ¯”ä¾‹ï¼ˆä¾‹å¦‚ 80%ï¼‰èª¿æ•´å‚·å®³
                                dmg *= (getDiceSpecialValue('joker') / 100);
                            }

                            // --- 3. é½’è¼ª (Gear) å‚·å®³åŠ æˆé‚è¼¯ ---
                            if (slot.dice.id === 'gear') {
                                const idx = grid.slots.indexOf(slot);
                                const col = idx % grid.cols;
                                const row = Math.floor(idx / grid.cols);
                                let neighbors = 0;

                                grid.slots.forEach((s, sIdx) => {
                                    if (s.dice && s.dice.id === 'gear' && s !== slot) {
                                        let sCol = sIdx % grid.cols;
                                        let sRow = Math.floor(sIdx / grid.cols);
                                        if (Math.abs(sCol - col) + Math.abs(sRow - row) === 1) {
                                            neighbors++;
                                        }
                                    }
                                });

                                // åŠŸèƒ½æ€§æ¨™è¨˜ï¼šå¦‚æœæœ‰é„°å±…ï¼Œå°±æ¨™è¨˜ç‚ºå¼·åŒ–ç‹€æ…‹ï¼Œç”¨æ–¼ç¹ªè£½ç‰¹æ•ˆ
                                slot.dice.isPowered = (neighbors > 0);
                                dmg *= (1 + neighbors * 0.5);
                            }

                            target.virtualHp -= dmg;
                            projectiles.push({
                                x: slot.x + grid.slotSize / 2,
                                y: slot.y + grid.slotSize / 2,
                                target,
                                color: db.baseColor,
                                speed: 10,
                                damage: dmg,
                                diceId: slot.dice.id,
                                diceLv: slot.dice.lv
                            });
                            slot.attackCooldown = 0;
                        }
                    }
                }
            });

            // --- 4. å­å½ˆç§»å‹•èˆ‡æ“Šä¸­åˆ¤å®š ---
            for (let i = projectiles.length - 1; i >= 0; i--) {
                let p = projectiles[i];
                if (!enemies.includes(p.target)) { projectiles.splice(i, 1); continue; }

                let dx = p.target.x - p.x;
                let dy = p.target.y - p.y;
                let dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 15) {
                    // æ“Šä¸­æ•ˆæœäº¤çµ¦ applyHitEffect è™•ç† (æ•´åˆäº†å‚³é€ã€é–å®šã€é€£é–ç­‰)
                    applyHitEffect(p);
                    projectiles.splice(i, 1);
                } else {
                    p.x += (dx / dist) * p.speed;
                    p.y += (dy / dist) * p.speed;
                }
            }
        }
        // ç‰¹æ®Šéª°å­æ•ˆæœ
        function executeAttack(dice, target, damage, startX, startY) {
            // é æ‰£è™›æ“¬è¡€é‡ï¼Œé˜²æ­¢å¤šå€‹éª°å­åŒæ™‚æ”»æ“ŠåŒä¸€éš»å¿«æ­»çš„æ€ª
            target.virtualHp -= damage;

            // æ ¹æ“šéª°å­ ID åŸ·è¡Œä¸åŒæ•ˆæœ
            switch (dice.id) {
                case 'ice':
                    target.speed = Math.max(0.5, 1.5 * 0.7); // æ¸›é€Ÿ 30%
                    clearTimeout(target.iceTimer);
                    target.iceTimer = setTimeout(() => { target.speed = 1.5; }, 1000);
                    break;

                case 'lock':
                    // é–å®šï¼š20% æ©Ÿç‡å®šèº« 1.5 ç§’
                    if (Math.random() < 0.2) {
                        const originalSpeed = target.speed;
                        target.speed = 0;
                        setTimeout(() => { target.speed = 1.5; }, 1500);
                    }
                    break;

                case 'electric':
                    // é€£é–æ”»æ“Šï¼šå°‹æ‰¾é™„è¿‘çš„æ€ª
                    enemies.forEach(e => {
                        let dist = Math.hypot(e.x - target.x, e.y - target.y);
                        if (e !== target && dist < 100) {
                            e.hp -= damage * 0.5;
                            damagePopups.push({ x: e.x, y: e.y, val: Math.floor(damage * 0.5), life: 20 });
                        }
                    });
                    break;

                case 'poison':
                    // ä¸­æ¯’ï¼šå¯ç–ŠåŠ 
                    if (!target.poisonStacks) target.poisonStacks = 0;
                    target.poisonStacks++;
                    break;

                case 'teleport':
                    // å‚³é€ï¼š5% æ©Ÿç‡å°‡é Boss æ€ªå‚³å›èµ·é»
                    if (Math.random() < 0.05 && !target.isBoss) {
                        target.x = path[0].x;
                        target.y = path[0].y;
                        target.pathIndex = 1;
                        return; // å‚³é€å¾Œä¸ç”¢ç”Ÿå­å½ˆ
                    }
                    break;

                case 'gear':
                    // é½’è¼ªï¼šè¨ˆç®—ç›¸é„°çš„é½’è¼ªæ•¸é‡å¢åŠ å‚·å®³ (é€™éƒ¨åˆ†é€šå¸¸åœ¨ damage è¨ˆç®—æ™‚è™•ç†ï¼Œé€™è£¡åšç‚ºæç¤º)
                    // å¦‚æœä½ åœ¨ updateCombat å·²ç¶“ç®—å¥½ damageï¼Œé€™è£¡å°±ç›´æ¥èµ°å­å½ˆé‚è¼¯
                    break;

                case 'sun':
                    const sunCount = grid.slots.filter(s => s.dice && s.dice.id === 'sun').length;
                    if ([1, 4, 7].includes(sunCount)) {
                        // ç¯„åœå‚·å®³ (AOE)
                        enemies.forEach(e => {
                            if (Math.hypot(e.x - target.x, e.y - target.y) < 65) {
                                e.hp -= damage;
                                damagePopups.push({ x: e.x, y: e.y, val: Math.floor(damage), life: 20 });
                            }
                        });
                        return; // å¤ªé™½ç™¼å…‰æ™‚ç›´æ¥çˆ†ç‚¸ï¼Œä¸ç”¢ç”Ÿæ™®é€šå­å½ˆ
                    }
                    break;

                case 'galaxy':
                    // éŠ€æ²³é»‘æ´ï¼š15% æ©Ÿç‡è§¸ç™¼å°ç¯„åœå¸å…¥èˆ‡æŒçºŒå‚·å®³
                    if (Math.random() < 0.15) {
                        enemies.forEach(e => {
                            let d = Math.hypot(e.x - target.x, e.y - target.y);
                            if (d < 80) {
                                e.x += (target.x - e.x) * 0.3; // å¾®å¼±å¸å…¥æ„Ÿ
                                e.y += (target.y - e.y) * 0.3;
                                e.hp -= damage * 0.2;
                            }
                        });
                    }
                    break;

                case 'joker':
                    // å°ä¸‘æœ¬èº«æ”»æ“ŠåŠ›æ¥µä½ï¼Œé€šå¸¸ä¸å…·å‚™ç‰¹æ®Šæ“Šä¸­æ•ˆæœ
                    break;
            }

            // ç”¢ç”Ÿå­å½ˆ (ä½¿ç”¨å‚³å…¥çš„èµ·å§‹åº§æ¨™)
            projectiles.push({
                x: startX,
                y: startY,
                fromDice: true,
                target,
                color: dice.color,
                speed: 10,
                damage: damage
            });
        }
        function applyHitEffect(p) {
            const target = p.target;
            target.hp -= p.damage;

            // é¡¯ç¤ºå‚·å®³å­—é«”
            damagePopups.push({ x: target.x, y: target.y, val: Math.floor(p.damage), life: 30 });

            // ç²å–è©²éª°å­çš„åŠŸèƒ½æ€§æ•¸å€¼ (ä¾‹å¦‚æ¸›é€Ÿ%ã€ç§’æ•¸ã€æ©Ÿç‡ç­‰)
            const spec = getDiceSpecialValue(p.diceId);

            switch (p.diceId) {
                case 'ice':
                    // spec ç‚ºæ¸›é€Ÿç™¾åˆ†æ¯” (ä¾‹å¦‚ 30%)ï¼Œè¨ˆç®—å‰©é¤˜é€Ÿåº¦
                    target.speed = Math.max(0.3, 1.5 * (1 - spec / 100));
                    clearTimeout(target.iceTimer);
                    target.iceTimer = setTimeout(() => { target.speed = 1.5; }, 1000);
                    break;
                case 'lock':
                    // spec ç‚ºå®šèº«ç§’æ•¸ (ä¾‹å¦‚ 1.5, 1.8...)
                    if (Math.random() < 0.2) {
                        target.speed = 0;
                        setTimeout(() => { target.speed = 1.5; }, spec * 1000);
                    }
                    break;
                case 'teleport':
                    // spec ç‚ºå‚³é€æ©Ÿç‡ (ä¾‹å¦‚ 5, 8, 10...)
                    if (Math.random() < (spec / 100) && !target.isBoss) {
                        target.x = path[0].x; target.y = path[0].y; target.pathIndex = 1;
                    }
                    break;
                case 'electric':
                    // ç²å–é›·é›»çš„ç‰¹æ®Šæ•¸å€¼ (å‡è¨­ spec ç¾åœ¨ä»£è¡¨ä¸€å€‹æ›´å¼·çš„åŠ æˆä¿‚æ•¸)
                    // ä¿®æ­£é»ï¼šå³ä½¿ p.damage å¾ˆä½ï¼Œæˆ‘å€‘ä¹Ÿçµ¦äºˆä¸€å€‹åŸºæ–¼ç­‰ç´šçš„ä¿åº•é€£é–å‚·
                    const chainBase = (p.diceLv * 10); // æ¯ä¸€æ˜Ÿç­‰æä¾› 20 é»åŸºç¤é›»æ“Šå‚·

                    enemies.forEach(e => {
                        // é€£é–ç¯„åœç¶­æŒ 100
                        if (e !== target && Math.hypot(e.x - target.x, e.y - target.y) < 100) {

                            // æ–°ç®—æ³•ï¼šä¸»å½ˆå‚·å®³çš„ 150% + æ˜Ÿç­‰ä¿åº•å‚·å®³
                            // é€™æ¨£å°±ç®—ä¸»å½ˆå‚·å®³åªæœ‰ 5ï¼Œ1 æ˜Ÿé›·é›»ä¹Ÿèƒ½æ‰“å‡º (5*1.5 + 20) = 27 é»é€£é–å‚·
                            let chainDmg = (p.damage * 0.8) + chainBase;

                            // PowerUp ç­‰ç´šåŠ æˆ (å¦‚æœæœ‰é€£å‹•åˆ° powerUpLevels)
                            const pUpLv = powerUpLevels['electric'] || 1;
                            chainDmg *= (1 + (pUpLv - 1) * 0.2);

                            e.hp -= chainDmg;

                            // é¡¯ç¤ºå‚·å®³ï¼šé›·é›»é€£é–é€šå¸¸ç”¨ Math.ceilï¼Œè®“æ•¸å­—çœ‹èµ·ä¾†æ¯”è¼ƒå¤§
                            const displayVal = Math.ceil(chainDmg);
                            if (displayVal > 0) {
                                damagePopups.push({
                                    x: e.x,
                                    y: e.y,
                                    val: displayVal,
                                    life: 20,
                                    color: "#fde047" // çµ¦äºˆé»ƒè‰²å­—é«”ï¼Œæ›´æœ‰é›·é›»æ„Ÿ
                                });
                            }
                        }
                    });
                    break;
                case 'sun':
                    const sunCount = grid.slots.filter(s => s.dice && s.dice.id === 'sun').length;
                    if ([1, 4, 7].includes(sunCount)) {
                        // å¤ªé™½ç™¼å…‰æ™‚ï¼Œspec å¯å®šç¾©çˆ†ç‚¸ç¯„åœæˆ–é¡å¤–ä¿‚æ•¸
                        enemies.forEach(e => {
                            if (e !== target && Math.hypot(e.x - target.x, e.y - target.y) < 65) {
                                e.hp -= p.damage;
                            }
                        });
                    }
                    break;
                case 'galaxy':
                    // spec ç‚ºå¸å…¥æ©Ÿç‡æˆ–å¼·åº¦
                    if (Math.random() < (spec / 100)) {
                        enemies.forEach(e => {
                            if (Math.hypot(e.x - target.x, e.y - target.y) < 80) {
                                e.x += (target.x - e.x) * 0.3;
                                e.y += (target.y - e.y) * 0.3;
                                e.hp -= p.damage * 0.2;
                            }
                        });
                    }
                    break;
                case 'poison':
                    // spec ç‚ºä¸­æ¯’å‚·å®³åŠ æˆ
                    if (!target.poisonStacks) target.poisonStacks = 0;
                    target.poisonStacks++;
                    break;
            }

            // æ­»äº¡åˆ¤å®šèˆ‡ SP ç²å–
            if (target.hp <= 0) {
                battleState.sp += target.rewardSp || 10;
                const index = enemies.indexOf(target);
                if (index > -1) enemies.splice(index, 1);
                updateUI();
            }
        }
        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                let e = enemies[i];

                // --- 1. è™•ç†ä¸­æ¯’æŒçºŒå‚·å®³ ---
                if (e.poisonStacks > 0) {
                    // æ¯ç§’é€ æˆ (å±¤æ•¸ * åŸºç¤å‚·å®³)
                    // åŸºç¤æ¯’å‚·è¨­ç‚º 2ï¼Œä½ å¯ä»¥æ ¹æ“š db.stats èª¿æ•´æ›´ç²¾ç¢ºçš„æ•¸å€¼
                    const poisonDmgPerFrame = (e.poisonStacks * 2) / 60;
                    e.hp -= poisonDmgPerFrame;

                    // æ¯ç§’ (60å¹€) é¡¯ç¤ºä¸€æ¬¡ç´«è‰²æ¯’å‚·æ•¸å­—
                    if (frameCount % 60 === 0) {
                        damagePopups.push({
                            x: e.x,
                            y: e.y - 15,
                            val: Math.floor(e.poisonStacks * 2),
                            color: "#a855f7", // ç´«è‰²ä»£è¡¨æ¯’ç´ 
                            life: 30
                        });
                    }
                }

                // --- 2. Boss æŠ€èƒ½é‚è¼¯ ---
                if (e.isBoss) {
                    if (!e.skillTimer) e.skillTimer = 0; // ç¢ºä¿ timer å­˜åœ¨
                    e.skillTimer++;
                    if (e.skillTimer >= BOSS_TYPES[e.bossType].skillInterval) {
                        BOSS_TYPES[e.bossType].onSkill(e);
                        e.skillTimer = 0;
                    }
                }

                // --- 3. ç§»å‹•é‚è¼¯ ---
                let target = path[e.pathIndex];
                let dx = target.x - e.x, dy = target.y - e.y, dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < e.speed) {
                    e.pathIndex++;
                    if (e.pathIndex >= path.length) {
                        battleState.hp--;
                        enemies.splice(i, 1);
                        updateUI();

                        // æˆ°æ•—åˆ¤æ–·
                        if (battleState.hp <= 0) {
                            handleGameOver(false); // å»ºè­°æ”¹ç”¨ function è™•ç†çµç®—ï¼Œè€Œä¸æ˜¯ç›´æ¥ reload
                            return;
                        }
                    }
                } else {
                    e.x += (dx / dist) * e.speed;
                    e.y += (dy / dist) * e.speed;
                }

                // --- 4. æª¢æŸ¥ä¸­æ¯’æˆ– DOT å°è‡´çš„æ­»äº¡ ---
                if (e.hp <= 0) {
                    battleState.sp += e.rewardSp || 10;
                    enemies.splice(i, 1);
                    updateUI();
                }
                if (battleState.wave > 20 && enemies.length === 0) {
                    handleGameOver(true); // å‚³å…¥ true ä»£è¡¨ã€Œå®Œå…¨é€šé—œã€
                    return;
                }
            }
        }
        function updateWave() {
            if (!waveState.isWaiting) {
                waveState.timer++;
                if (waveState.timer >= 60) {
                    if (battleState.wave % 10 === 0 && waveState.spawnedCount === 0) { spawnBoss(); waveState.spawnedCount = waveState.totalEnemiesPerWave; }
                    else if (waveState.spawnedCount < waveState.totalEnemiesPerWave) { spawnEnemy(); waveState.spawnedCount++; waveState.timer = 0; }
                    else if (enemies.length === 0) { waveState.isWaiting = true; waveState.timer = 0; }
                }
            } else {
                waveState.timer++;
                if (waveState.timer >= 120) {
                    battleState.wave++; waveState.spawnedCount = 0; waveState.totalEnemiesPerWave += 2; waveState.isWaiting = false; waveState.timer = 0; updateUI();
                }
            }
        }

        function updateUI() {
            document.getElementById('spText').innerText = Math.floor(battleState.sp);
            document.getElementById('summonCostText').innerText = battleState.summonCost;
            document.getElementById('hpText').innerText = battleState.hp;
            document.getElementById('waveText').innerText = battleState.wave;

            const container = document.getElementById('powerUpButtons');
            container.innerHTML = userData.deck.map((id) => {
                const dice = ALL_DICES.find(d => d.id === id);
                const lv = powerUpLevels[id] || 1;
                const cost = 100 * Math.pow(2, lv - 1);
                return `<button onclick="powerUpDice('${id}')" class="flex-1 min-w-0 bg-slate-800 border ${battleState.sp >= cost ? 'border-blue-500' : 'border-slate-700'} rounded-lg py-1.5 flex flex-col items-center active:scale-95 transition-all">
                <div class="w-7 h-7 rounded flex items-center justify-center text-[10px] font-bold mb-1" style="background-color: ${dice.baseColor}; color: white;">${dice.name}</div>
                <div class="text-[9px] text-yellow-500 font-bold">Lv.${lv}</div>
                <div class="text-[8px] text-slate-400 mt-1">${cost >= 1000 ? (cost / 1000).toFixed(1) + 'k' : cost}</div>
            </button>`;
            }).join('');
        }

        function startRenderLoop() {
            const canvas = document.getElementById('gameCanvas'), ctx = canvas.getContext('2d');
            function frame() {
                if (!battleState.isStarted) return;
                frameCount++;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                updateEnemies(); updateWave(); updateCombat();

                ctx.strokeStyle = "rgba(59, 130, 246, 0.1)"; ctx.lineWidth = 30; ctx.lineJoin = "round"; ctx.beginPath();
                ctx.moveTo(path[0].x, path[0].y); path.forEach(p => ctx.lineTo(p.x, p.y)); ctx.stroke();

                projectiles.forEach(p => { ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI * 2); ctx.fill(); });
                enemies.forEach(e => {
                    const s = e.isBoss ? e.size : 20;
                    ctx.fillStyle = e.isBoss ? e.color : "#ef4444"; ctx.fillRect(e.x - s / 2, e.y - s / 2, s, s);
                    ctx.fillStyle = "rgba(0,0,0,0.5)"; ctx.fillRect(e.x - 15, e.y - (s / 2 + 8), 30, 3);
                    ctx.fillStyle = "#22c55e"; ctx.fillRect(e.x - 15, e.y - (s / 2 + 8), (e.hp / e.maxHp) * 30, 3);
                });

                for (let i = damagePopups.length - 1; i >= 0; i--) {
                    let d = damagePopups[i];
                    ctx.fillStyle = `rgba(255, 255, 255, ${d.life / 30})`; ctx.font = "bold 14px Arial"; ctx.fillText(d.val, d.x, d.y);
                    d.y -= 1; d.life--; if (d.life <= 0) damagePopups.splice(i, 1);
                }

                grid.slots.forEach(slot => {
                    // ç•«æ ¼å­èƒŒæ™¯
                    ctx.fillStyle = "rgba(255, 255, 255, 0.05)";
                    drawRoundedRect(ctx, slot.x, slot.y, grid.slotSize, grid.slotSize, 10);
                    ctx.fill();

                    if (slot.dice && !slot.isBeingDragged) {
                        // --- æ–°å¢ï¼šè¦–è¦ºç‰¹æ•ˆé‚è¼¯ ---
                        const canvas = document.getElementById('gameCanvas');
                        const ctx = canvas.getContext('2d');

                        // å¤ªé™½ç‰¹æ•ˆ
                        if (slot.dice.id === 'sun') {
                            const sunCount = grid.slots.filter(s => s.dice && s.dice.id === 'sun').length;
                            if ([1, 4, 7].includes(sunCount)) {
                                drawEffect(slot, "orange");
                            }
                        }
                        // é½’è¼ªç‰¹æ•ˆ
                        if (slot.dice.id === 'gear' && slot.dice.isPowered) {
                            drawEffect(slot, "#00ccff");
                        }

                        // ç•«éª°å­ä¸»é«”
                        renderDice(ctx, slot.x, slot.y, slot.dice, slot.isLocked);
                    }
                });

                if (drag.isDragging) renderDice(ctx, drag.currentX - grid.slotSize / 2, drag.currentY - grid.slotSize / 2, drag.dice, false);
                requestAnimationFrame(frame);
            }
            frame();
        }

        function renderDice(ctx, x, y, dice, isLocked) {
            ctx.strokeStyle = dice.qualityColor || '#fff'; ctx.lineWidth = 3;
            drawRoundedRect(ctx, x + 4, y + 4, grid.slotSize - 8, grid.slotSize - 8, 8); ctx.stroke();
            ctx.fillStyle = dice.color; drawRoundedRect(ctx, x + 6, y + 6, grid.slotSize - 12, grid.slotSize - 12, 6); ctx.fill();
            ctx.fillStyle = "#fff"; ctx.font = "bold 20px Arial"; ctx.textAlign = "center";
            ctx.fillText(dice.lv, x + grid.slotSize / 2, y + grid.slotSize / 2 + 7);
            if (isLocked) { ctx.fillStyle = "rgba(0,0,0,0.7)"; drawRoundedRect(ctx, x + 5, y + 5, grid.slotSize - 10, grid.slotSize - 10, 8); ctx.fill(); }
        }

        function drawRoundedRect(ctx, x, y, w, h, r) {
            ctx.beginPath(); ctx.moveTo(x + r, y); ctx.lineTo(x + w - r, y); ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r); ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h); ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r); ctx.lineTo(x, y + r); ctx.quadraticCurveTo(x, y, x + r, y); ctx.closePath();
        }

        function setupTouchEvents(canvas) {
            canvas.addEventListener('touchstart', (e) => {
                const touch = e.touches[0], rect = canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left, y = touch.clientY - rect.top;
                grid.slots.forEach(slot => {
                    if (slot.dice && x > slot.x && x < slot.x + grid.slotSize && y > slot.y && y < slot.y + grid.slotSize) {
                        drag.isDragging = true;
                        drag.fromSlot = slot;
                        drag.dice = { ...slot.dice }; // æ·ºæ‹·è²
                        drag.currentX = x;
                        drag.currentY = y;
                        slot.isBeingDragged = true;
                    }
                });
            });

            canvas.addEventListener('touchmove', (e) => {
                if (!drag.isDragging) return;
                e.preventDefault();
                const touch = e.touches[0], rect = canvas.getBoundingClientRect();
                drag.currentX = touch.clientX - rect.left;
                drag.currentY = touch.clientY - rect.top;
            }, { passive: false });

            canvas.addEventListener('touchend', () => {
                if (!drag.isDragging) return;

                let targetSlot = grid.slots.find(s =>
                    drag.currentX > s.x && drag.currentX < s.x + grid.slotSize &&
                    drag.currentY > s.y && drag.currentY < s.y + grid.slotSize
                );

                if (targetSlot && targetSlot !== drag.fromSlot && targetSlot.dice) {
                    // --- å°ä¸‘éª°å­è®Šèº«é‚è¼¯ ---
                    if (drag.dice.id === 'joker' && drag.dice.lv === targetSlot.dice.lv) {
                        const targetId = targetSlot.dice.id;
                        const db = ALL_DICES.find(d => d.id === targetId);

                        drag.fromSlot.dice = {
                            id: targetId,
                            lv: drag.dice.lv,
                            color: db.baseColor,
                            qualityColor: QUALITIES[db.quality].color,
                            growthTimer: 0 // è£œä¸Šè¨ˆæ™‚å™¨é˜²å¡æ­»
                        };

                        drag.isDragging = false;
                        drag.fromSlot.isBeingDragged = false;
                        updateUI();
                        return;
                    }

                    // --- ä¸€èˆ¬åˆæˆé‚è¼¯ ---
                    if (targetSlot.dice.id === drag.dice.id && targetSlot.dice.lv === drag.dice.lv && targetSlot.dice.lv < 7) {
                        const newId = userData.deck[Math.floor(Math.random() * userData.deck.length)];
                        const db = ALL_DICES.find(d => d.id === newId);

                        // ä¿®æ­£é»ï¼šç¢ºä¿åˆæˆå¾Œçš„æ–°éª°å­å±¬æ€§å®Œæ•´
                        targetSlot.dice = {
                            id: newId,
                            lv: drag.dice.lv + 1,
                            color: db.baseColor,
                            qualityColor: QUALITIES[db.quality].color,
                            growthTimer: 0 // è£œä¸Šè¨ˆæ™‚å™¨é˜²å¡æ­»
                        };
                        drag.fromSlot.dice = null;
                    }
                }
                // 3. å¦‚æœæ˜¯ç§»åˆ°ç©ºä½
                else if (targetSlot && !targetSlot.dice) {
                    // ä¿®æ­£é»ï¼šä½¿ç”¨æ‹·è²è€Œéå¼•ç”¨ï¼Œç¢ºä¿ growthTimer éš¨è¡Œ
                    targetSlot.dice = { ...drag.dice, growthTimer: drag.dice.growthTimer || 0 };
                    drag.fromSlot.dice = null;
                }

                drag.isDragging = false;
                drag.fromSlot.isBeingDragged = false;
                updateUI();
            });
        }
        function drawEffect(slot, color) {
            ctx.save();
            ctx.beginPath();
            const pulse = Math.sin(Date.now() / 200) * 5;
            ctx.strokeStyle = color;
            ctx.lineWidth = 4;
            ctx.shadowBlur = 10 + pulse;
            ctx.shadowColor = color;
            const centerX = slot.x + grid.slotSize / 2;
            const centerY = slot.y + grid.slotSize / 2;
            ctx.arc(centerX, centerY, (grid.slotSize / 2) - 5, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }
    </script>
</body>

</html>