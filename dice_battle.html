<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>éª°å­æˆ°çˆ­ - æˆ°å ´</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            height: 100dvh;
            /* ä½¿ç”¨ dvh ç¢ºä¿åœ¨æ‰‹æ©Ÿä¸Šè‡ªå‹•æ‰£é™¤ç¶²å€åˆ—é«˜åº¦ */
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            background-color: #020617;
        }

        #header-info {
            flex-shrink: 0;
            /* å›ºå®šé ­éƒ¨é«˜åº¦ */
        }

        #footer-controls {
            flex-shrink: 0;
            /* å›ºå®šåº•éƒ¨é«˜åº¦ */
            padding: 12px;
            padding-bottom: env(safe-area-inset-bottom, 20px);
            /* é‡å° iPhone åº•éƒ¨ç™½æ¢çš„æ’ç‰ˆå„ªåŒ– */
            background: rgba(15, 23, 42, 0.95);
            border-top: 1px solid rgba(51, 65, 85, 0.5);
        }

        #canvas-container {
            flex-grow: 1;
            position: relative;
            width: 100%;
            overflow: hidden;
        }

        #gameCanvas {
            background: radial-gradient(circle, #1e293b 0%, #020617 100%);
            touch-action: none;
            width: 100%;
            height: 100%;
        }

        .glass-panel {
            background: rgba(30, 41, 49, 0.8);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .diff-card {
            transition: all 0.3s;
            border: 2px solid transparent;
            cursor: pointer;
        }

        .diff-card:active {
            transform: scale(0.95);
        }

        .energy-glow {
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.5);
        }

        .scroll-hide::-webkit-scrollbar {
            display: none;
        }
    </style>
</head>

<body class="flex flex-col h-screen bg-slate-900">
    <div id="header-info" class="p-3 flex justify-between items-center bg-slate-900/50">
        <div class="flex items-center gap-4">
            <span class="text-red-500 font-bold">HP: <span id="hpText">3</span></span>
            <span class="text-blue-400 font-bold">SP: <span id="spText">100</span></span>
        </div>
        <div class="text-slate-400 font-bold text-sm">WAVE: <span id="waveText">1</span></div>
    </div>

    <div id="canvas-container" class="flex-1 relative">
        <canvas id="gameCanvas" style="width: 100%; height: 100%; display: block;"></canvas>
    </div>

    <div id="footer-controls" class="p-3 max-w-[500px] mx-auto w-full">
        <div class="flex flex-nowrap w-full gap-1 mb-4">
            <div id="powerUpButtons" class="contents"></div>
        </div>
        <button onclick="summonDice()"
            class="w-full py-4 bg-blue-600 rounded-xl font-black text-xl shadow-lg active:scale-95 transition-all text-white">
            å¬å–šéª°å­ (<span id="summonCostText">10</span> SP)
        </button>
    </div>

    <div id="difficultyOverlay" class="fixed inset-0 z-50 bg-black/95 flex items-center justify-center p-6">
        <div class="w-full max-w-sm">
            <h2
                class="text-center text-2xl font-black mb-8 text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-400">
                é¸æ“‡æˆ°é¬¥é›£åº¦</h2>
            <div class="space-y-4">
                <button onclick="startGame('normal')"
                    class="w-full bg-slate-800 p-4 rounded-2xl flex justify-between items-center border border-slate-700 active:bg-slate-700">
                    <span class="font-bold text-lg text-white">ç°¡å–®æ¨¡å¼</span>
                    <span class="text-xs text-green-400 bg-green-900/30 px-2 py-1 rounded">1x çå‹µ</span>
                </button>
                <button onclick="startGame('hard')"
                    class="w-full bg-slate-800 p-4 rounded-2xl flex justify-between items-center border border-blue-500/50 active:bg-slate-700">
                    <span class="font-bold text-lg text-white">å›°é›£æ¨¡å¼</span>
                    <span class="text-xs text-blue-400 bg-blue-900/30 px-2 py-1 rounded">2.5x çå‹µ</span>
                </button>
                <button onclick="startGame('hell')"
                    class="w-full bg-slate-800 p-4 rounded-2xl flex justify-between items-center border border-red-500/50 active:bg-slate-700">
                    <span class="font-bold text-lg text-red-500">åœ°ç„æ¨¡å¼</span>
                    <span class="text-xs text-red-400 bg-red-900/30 px-2 py-1 rounded">6x çå‹µ</span>
                </button>
            </div>
        </div>
    </div>

    <div id="resultModal"
        style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index:9999; flex-direction:column; align-items:center; justify-content:center; color:white;">

        <h1 id="resTitle" style="font-size:40px; margin:10px 0;">æˆ°ç¸¾çµç®—</h1>

        <div
            style="background:#1e293b; padding:20px; border-radius:15px; border:2px solid #3b82f6; text-align:center; min-width:250px;">
            <p style="font-size:18px; margin:5px 0;">æ’éæ³¢æ•¸ï¼š<span id="resWave" style="color:#facc15;">0</span> / 20</p>
            <hr style="border:0; border-top:1px solid #475569; margin:15px 0;">
            <p style="margin:5px 0;">ç²å¾—çå‹µ</p>
            <div style="font-size:28px; font-weight:bold; color:#10b981; margin-top:10px;">
                ğŸ« æŠ½çåˆ¸ x <span id="resTickets">0</span>
            </div>
        </div>

        <button onclick="location.href='dice.html'"
            style="margin-top:30px; padding:12px 35px; font-size:18px; background:#3b82f6; color:white; border:none; border-radius:8px; font-weight:bold;">
            é ˜å–ä¸¦å›å¤§å»³
        </button>
    </div>
    <script>
        const QUALITIES = {
            common: { name: 'æ™®é€š', color: '#ffffff', chance: 0.60 },   // 60% æ©Ÿç‡
            rare: { name: 'ç¨€æœ‰', color: '#3b82f6', chance: 0.25 },   // 25% æ©Ÿç‡
            epic: { name: 'å²è©©', color: '#a855f7', chance: 0.10 },   // 10% æ©Ÿç‡
            legend: { name: 'å‚³èªª', color: '#eab308', chance: 0.04 },   // 4% æ©Ÿç‡
            mythic: { name: 'ç¥è©±', color: '#ff00ff', chance: 0.01 }    // 1% æ©Ÿç‡
        };

        const ALL_DICES = [
            // --- Common (æ™®é€š) ---
            {
                id: 'fire', name: 'ç«', quality: 'common', baseColor: '#ef4444',
                stats: { atk: 15, speed: 50 }, grow: { atk: 5, speed: -1 },
                special: { label: 'æ¿ºå°„ç¯„åœ', value: 1.0, unit: 'æ ¼', grow: 0.1 }
            },
            {
                id: 'wind', name: 'é¢¨', quality: 'common', baseColor: '#10b981',
                stats: { atk: 10, speed: 20 }, grow: { atk: 3, speed: -2 },
                special: { label: 'é€£æ“Šæ©Ÿç‡', value: 10, unit: '%', grow: 3 }
            },
            {
                id: 'ice', name: 'å†°', quality: 'common', baseColor: '#3b82f6',
                stats: { atk: 8, speed: 60 }, grow: { atk: 2, speed: -1 },
                special: { label: 'ç·©é€Ÿæ•ˆæœ', value: 15, unit: '%', grow: 5 }
            },
            {
                id: 'electric', name: 'é›»', quality: 'common', baseColor: '#f59e0b',
                stats: { atk: 7, speed: 40 }, grow: { atk: 2, speed: -1 },
                special: { label: 'é€£é–ç›®æ¨™', value: 3, unit: 'é«”', grow: 1 }
            },
            {
                id: 'poison', name: 'æ¯’', quality: 'common', baseColor: '#008000',
                stats: { atk: 6, speed: 45 }, grow: { atk: 2, speed: -1 },
                special: { label: 'ä¸­æ¯’å‚·å®³', value: 5, unit: 'pt', grow: 3 }
            },

            // --- Rare (ç¨€æœ‰) ---
            {
                id: 'lock', name: 'é–å®š', quality: 'rare', baseColor: '#64748b',
                stats: { atk: 10, speed: 55 }, grow: { atk: 4, speed: -1 },
                special: { label: 'ç¦éŒ®æ™‚é•·', value: 0.5, unit: 'ç§’', grow: 0.2 }
            },

            // --- Epic (å²è©©) ---
            {
                id: 'teleport', name: 'å‚³é€', quality: 'epic', baseColor: '#8b5cf6',
                stats: { atk: 5, speed: 65 }, grow: { atk: 2, speed: -1 },
                special: { label: 'å‚³é€å›çµ‚é»', value: 5, unit: '%', grow: 2 }
            },
            {
                id: 'gear', name: 'é½’è¼ª', quality: 'epic', baseColor: '#475569',
                stats: { atk: 12, speed: 50 }, grow: { atk: 6, speed: -1 },
                special: { label: 'é€£çµåŠ æˆ', value: 10, unit: '%', grow: 5 }
            },

            // --- Legend (å‚³èªª) ---
            {
                id: 'joker', name: 'å°ä¸‘', quality: 'legend', baseColor: '#f87171',
                stats: { atk: 5, speed: 50 }, grow: { atk: 1, speed: 0 },
                special: { label: 'ç¹¼æ‰¿æ¯”ä¾‹', value: 80, unit: '%', grow: 2 }
            },
            {
                id: 'growth', name: 'æˆé•·', quality: 'legend', baseColor: '#f472b6',
                stats: { atk: 10, speed: 50 }, grow: { atk: 5, speed: -1 },
                special: { label: 'æˆé•·æ™‚é–“', value: 60, unit: 'ç§’', grow: -2 }
            },
            {
                id: 'sun', name: 'å¤ªé™½', quality: 'legend', baseColor: '#fbbf24',
                stats: { atk: 25, speed: 55 }, grow: { atk: 12, speed: -0.5 },
                special: { label: 'æ¿ºå°„çˆ†ç™¼', value: 100, unit: '%', grow: 20 }
            },

            // --- Mythic (ç¥è©±) ---
            {
                id: 'galaxy', name: 'éŠ€æ²³', quality: 'mythic', baseColor: '#6366f1',
                stats: { atk: 40, speed: 45 }, grow: { atk: 20, speed: -1 },
                special: { label: 'é»‘æ´åå™¬', value: 1, unit: '%', grow: 0.5 }
            }
        ];

        const BOSS_TYPES = {
            'CRUSHER': {
                name: 'ç²‰ç¢è€…', color: '#ff4444', skillInterval: 300, onSkill: (boss) => {
                    const occupied = grid.slots.filter(s => s.dice && !s.isLocked);
                    if (occupied.length > 0) {
                        const target = occupied[Math.floor(Math.random() * occupied.length)];
                        target.isLocked = true;
                        setTimeout(() => { target.isLocked = false; }, 4000);
                    }
                }
            },
            'SNAKE': {
                name: 'å™´å°„è€…', color: '#22c55e', skillInterval: 240, onSkill: (boss) => {
                    enemies.forEach(e => e.speed *= 1.5);
                    setTimeout(() => { enemies.forEach(e => e.speed /= 1.5); }, 2000);
                }
            }
        };

        const userData = JSON.parse(localStorage.getItem('dice_game_data')) || {
            deck: ['fire', 'wind', 'ice', 'electric', 'poison'],
            diceLevels: { 'fire': 1, 'wind': 1, 'ice': 1, 'electric': 1, 'poison': 1 }
        };
        if (userData.tickets === undefined) userData.tickets = 0;
        let battleState = { hp: 3, sp: 100, wave: 1, summonCost: 10, difficulty: 'normal', isStarted: false };
        let powerUpLevels = {};
        userData.deck.forEach(id => { powerUpLevels[id] = 1; });
        let frameCount = 0;
        let grid = { rows: 3, cols: 5, padding: 10, slotSize: 0, slots: [], y: 0 };
        let drag = { isDragging: false, fromSlot: null, currentX: 0, currentY: 0, dice: null };
        let waveState = { totalEnemiesPerWave: 10, spawnedCount: 0, isWaiting: false, timer: 0 };
        let projectiles = [], enemies = [], path = [], damagePopups = [];

        function startGame(diff) {
            battleState.difficulty = diff;
            battleState.isStarted = true;
            document.getElementById('difficultyOverlay').style.display = 'none';
            initGame();
        }

        function initGame() {
            const canvas = document.getElementById('gameCanvas');
            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;

            initGrid(canvas);
            initPath(canvas);
            setupTouchEvents(canvas);
            updateUI();
            startRenderLoop();
        }

        function initGrid(canvas) {
            const sideMargin = 15;
            grid.slotSize = (canvas.width - (grid.cols + 1) * grid.padding - (sideMargin * 2)) / grid.cols;
            const totalGridHeight = grid.rows * (grid.slotSize + grid.padding);
            grid.y = (canvas.height / 2) - (totalGridHeight / 2);
            grid.slots = [];
            for (let i = 0; i < grid.rows * grid.cols; i++) {
                const r = Math.floor(i / grid.cols), c = i % grid.cols;
                grid.slots.push({
                    x: sideMargin + grid.padding + c * (grid.slotSize + grid.padding),
                    y: grid.y + r * (grid.slotSize + grid.padding),
                    dice: null, isLocked: false, isBeingDragged: false, attackCooldown: 0
                });
            }
        }
        function getDiceSpecialValue(diceId) {
            if (!diceId) return 0;
            const dice = ALL_DICES.find(d => d.id === diceId);
            if (!dice || !dice.special) return 0;

            const lv = (userData.diceLevels && userData.diceLevels[diceId]) ? userData.diceLevels[diceId] : 1;

            // åŠ ä¸Š || 0 ç¢ºä¿å¦‚æœè³‡æ–™è¡¨æ²’å¯« value æˆ– growï¼Œä¸æœƒè®Šæˆ NaN
            const base = dice.special.value || 0;
            const grow = dice.special.grow || 0;

            return base + (lv - 1) * grow;
        }
        function transformJoker(jokerDice, targetDice) {
            const ratio = getDiceSpecialValue('joker') / 100; // æ‹¿åˆ° 0.8, 0.82...

            jokerDice.name = targetDice.name;
            jokerDice.baseColor = targetDice.baseColor;

            // ç¹¼æ‰¿æ”»æ“ŠåŠ› (å—æ¯”ä¾‹å½±éŸ¿)
            jokerDice.atk = targetDice.atk * ratio;

            // å¦‚æœè¤‡è£½çš„æ˜¯æˆé•·éª°å­ï¼Œæ™‚é–“è¦è®Šé•· (æ•ˆç‡é™ä½)
            if (targetDice.id === 'growth') {
                const targetTime = getDiceSpecialValue('growth');
                jokerDice.timer = targetTime / ratio; // ä¾‹å¦‚ 60 / 0.8 = 75ç§’
            }
        }
        function handleGameOver(isVictory) {
            // è¨ˆç®—çå‹µ
            let earnedTickets = 0;

            if (isVictory) {
                // å®Œå…¨é€šé—œ (20æ³¢)ï¼šçµ¦äºˆå¤§çï¼Œä¾‹å¦‚ 5 å¼µæŠ½çåˆ¸
                earnedTickets = 5;
            } else {
                // ä¸­é€”æˆ°æ•—ï¼šæ¯ 5 æ³¢çµ¦ 1 å¼µï¼Œæœªæ»¿ 5 æ³¢è‡³å°‘çµ¦ 0 æˆ– 1 å¼µ
                earnedTickets = Math.floor(battleState.wave / 5);
            }

            // å­˜æª”åˆ° LocalStorage
            userData.tickets = (userData.tickets || 0) + earnedTickets;
            localStorage.setItem('dice_game_data', JSON.stringify(userData));

            // é¡¯ç¤ºçµç®—è¦–çª—
            showResultModal(isVictory, battleState.wave, earnedTickets);
        }
        function showResultModal(isVictory, wave, tickets) {
            const modal = document.getElementById('resultModal');
            const title = document.getElementById('resTitle');

            if (isVictory) {
                title.innerText = "ğŸ‰ å®Œç¾é€šé—œ";
                title.style.color = "#facc15"; // é‡‘è‰²
            } else {
                title.innerText = "ğŸ’€ æˆ°æ•—";
                title.style.color = "#ef4444"; // ç´…è‰²
            }

            document.getElementById('resWave').innerText = wave;
            document.getElementById('resTickets').innerText = tickets;
            modal.style.display = 'flex';
        }
        function initPath(canvas) {
            const L = 25, R = canvas.width - 25, T = grid.y - 50, B = grid.y + (grid.rows * (grid.slotSize + grid.padding)) + 20;
            path = [{ x: L, y: T }, { x: R, y: T }, { x: R, y: B }, { x: L, y: B }, { x: L, y: T + 5 }];
        }

        function summonDice() {
            if (battleState.sp < battleState.summonCost) return;
            const emptySlots = grid.slots.filter(s => s.dice === null);
            if (emptySlots.length === 0) return;

            battleState.sp -= battleState.summonCost;
            battleState.summonCost += 10;

            const targetSlot = emptySlots[Math.floor(Math.random() * emptySlots.length)];
            const diceId = userData.deck[Math.floor(Math.random() * userData.deck.length)];
            const db = ALL_DICES.find(d => d.id === diceId);

            // å¼·åˆ¶è¨­å®š lv ç‚º 1
            targetSlot.dice = {
                id: diceId,
                lv: 1, // é€™è£¡ç¢ºä¿æ˜¯ 1
                color: db.baseColor,
                qualityColor: QUALITIES[db.quality].color,
                growthTimer: 0,   // çµ¦æˆé•·éª°å­ç”¨
                isPowered: false, // çµ¦é½’è¼ª/å¤ªé™½ç”¨
                attackCooldown: 0
            };

            // æ‹›å–šå¾Œç«‹åˆ»é‡ç®—ä¸€æ¬¡å¤ªé™½æ•¸é‡ï¼Œé¿å… updateCombat é–ƒé€€
            updateUI();
            refreshSunState();
        }

        function powerUpDice(id) {
            const lv = powerUpLevels[id] || 1;
            const cost = 100 * Math.pow(2, lv - 1);
            if (battleState.sp >= cost && lv < 5) {
                battleState.sp -= cost;
                powerUpLevels[id] = lv + 1;
                updateUI();
            }
        }

        function spawnEnemy() {
            let mult = (battleState.difficulty === 'hell' ? 1.5 : battleState.difficulty === 'hard' ? 1.3 : 1.15);
            const hp = 100 * Math.pow(mult, battleState.wave - 1);
            enemies.push({ x: path[0].x, y: path[0].y, pathIndex: 1, maxHp: hp, hp, virtualHp: hp, speed: 1.5, rewardSp: 10 + Math.floor(battleState.wave / 2), isBoss: false });
        }

        function spawnBoss() {
            const type = Object.keys(BOSS_TYPES)[Math.floor(Math.random() * 2)];
            const hp = 2000 * Math.pow(1.4, battleState.wave / 10);
            enemies.push({ x: path[0].x, y: path[0].y, pathIndex: 1, maxHp: hp, hp, virtualHp: hp, speed: 0.8, rewardSp: 150, isBoss: true, bossType: type, skillTimer: 0, size: 50, color: BOSS_TYPES[type].color });
        }

        function updateCombat() {
            // 1. æå‰è¨ˆç®—å…¨å ´å¤ªé™½æ•¸é‡ (æå‡æ•ˆèƒ½ï¼Œé¿å…åœ¨è¿´åœˆå…§é‡è¤‡è¨ˆç®—)


            // 2. éæ­·æ‰€æœ‰æ ¼å­è™•ç†éª°å­é‚è¼¯
            grid.slots.forEach(slot => {
                // åŸºç¤å®‰å…¨æª¢æŸ¥ï¼šç¢ºä¿æ ¼å­æœ‰éª°å­ã€æ²’è¢«æ‹–æ›³ã€ä¸”æ²’è¢«é–å®š
                if (slot.dice && slot.dice.id && !slot.isBeingDragged && !slot.isLocked) {
                    const db = ALL_DICES.find(d => d.id === slot.dice.id);
                    if (!db) return;

                    // --- A. è™•ç†æˆé•·éª°å­é‚è¼¯ ---
                    if (slot.dice.id === 'growth') {
                        if (!slot.dice.growthTimer) slot.dice.growthTimer = 0;
                        slot.dice.growthTimer++;

                        // å–å¾—æˆé•·æ‰€éœ€ç§’æ•¸ (ä¾‹å¦‚ 15 ç§’)
                        const targetSeconds = getDiceSpecialValue('growth');
                        if (slot.dice.growthTimer >= targetSeconds * 60) { // å‡è¨­ 60 FPS
                            if (slot.dice.lv < 7) {
                                const newId = userData.deck[Math.floor(Math.random() * userData.deck.length)];
                                const newDb = ALL_DICES.find(d => d.id === newId);

                                // å‡æ˜Ÿè½‰åŒ–
                                slot.dice = {
                                    id: newId,
                                    lv: slot.dice.lv + 1,
                                    color: newDb.baseColor,
                                    qualityColor: QUALITIES[newDb.quality].color,
                                    growthTimer: 0,
                                    attackCooldown: 0
                                };
                                updateUI(); // éª°å­è®Šèº«éœ€è¦æ›´æ–°ä»‹é¢
                                refreshSunState();
                            }
                        }
                    }

                    // --- B. æ”»é€Ÿè¨ˆç®—èˆ‡æ”»æ“Šè§¸ç™¼ ---
                    const pLv = userData.diceLevels[slot.dice.id] || 1;
                    let spd = Math.max(10, db.stats.speed + (pLv - 1) * db.grow.speed);

                    // åŠŸèƒ½æ€§å„ªå…ˆï¼šå¤ªé™½ç™¼å…‰æ™‚å¤§å¹…åŠ é€Ÿ
                    if (slot.dice.id === 'sun' && isSunActivated) {
                        spd /= 1.2; // åŠ é€Ÿ 50%
                    }

                    // é˜²æ­¢æ”»é€Ÿç•°å¸¸å°è‡´å´©æ½°
                    if (spd < 5) spd = 20;

                    slot.attackCooldown = (slot.attackCooldown || 0) + 1;

                    if (slot.attackCooldown >= spd) {
                        // å°‹æ‰¾ç›®æ¨™ï¼šå„ªå…ˆæ”»æ“Šè·¯å¾‘æœ€å‰æ–¹çš„æ€ª (ä½¿ç”¨è™›æ“¬è¡€é‡éæ¿¾ï¼Œé˜²æ­¢å­å½ˆé­å±)
                        const target = enemies
                            .filter(e => (e.virtualHp !== undefined ? e.virtualHp : e.hp) > 0)
                            .sort((a, b) => b.pathIndex - a.pathIndex)[0];

                        if (target) {
                            // è¨ˆç®—åŸºç¤å‚·å®³ (åŒ…å« PowerUp ç­‰ç´šåŠ æˆ)
                            const powerUpLv = powerUpLevels[slot.dice.id] || 1;
                            let dmg = (db.stats.atk + (pLv - 1) * db.grow.atk) * slot.dice.lv * (1 + (powerUpLv - 1) * 0.4);

                            // é½’è¼ªéª°å­é„°è¿‘åŠ æˆé‚è¼¯
                            if (slot.dice.id === 'gear') {
                                const idx = grid.slots.indexOf(slot);
                                const col = idx % grid.cols;
                                const row = Math.floor(idx / grid.cols);
                                let neighbors = 0;
                                grid.slots.forEach((s, sIdx) => {
                                    if (s.dice && s.dice.id === 'gear' && s !== slot) {
                                        let sCol = sIdx % grid.cols;
                                        let sRow = Math.floor(sIdx / grid.cols);
                                        if (Math.abs(sCol - col) + Math.abs(sRow - row) === 1) neighbors++;
                                    }
                                });
                                dmg *= (1 + neighbors * 0.5); // æ¯å€‹ç›¸é„°é½’è¼ªå¢åŠ  50% å‚·å®³
                            }

                            // å‘¼å«ç™¼å°„å‡½å¼ (ç”±å…¶æ±ºå®šè¦ç”¢ç”Ÿå­å½ˆé‚„æ˜¯ AOE)
                            executeAttack(
                                slot.dice,
                                target,
                                dmg,
                                slot.x + grid.slotSize / 2,
                                slot.y + grid.slotSize / 2,
                                isSunActivated
                            );

                            slot.attackCooldown = 0;
                        } else {
                            // æ²’æ€ªæ™‚ï¼Œå†·å»ç¶­æŒåœ¨å¯æ”»æ“Šç‹€æ…‹ï¼Œä¸é‡ç½®
                            slot.attackCooldown = spd;
                        }
                    }
                }
            });

            // 3. å­å½ˆç§»å‹•èˆ‡æ“Šä¸­åˆ¤å®š (ç¨ç«‹æ–¼éª°å­è¿´åœˆä¹‹å¤–)
            for (let i = projectiles.length - 1; i >= 0; i--) {
                let p = projectiles[i];

                // å¦‚æœç›®æ¨™æ­»äº†æˆ–ä¸å­˜åœ¨ï¼Œç§»é™¤å­å½ˆ
                if (!enemies.includes(p.target) || p.target.hp <= 0) {
                    projectiles.splice(i, 1);
                    continue;
                }

                let dx = p.target.x - p.x;
                let dy = p.target.y - p.y;
                let dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 15) {
                    // æ“Šä¸­æ•ˆæœ
                    applyHitEffect(p);
                    projectiles.splice(i, 1);
                } else {
                    // ç§»å‹•å­å½ˆ
                    p.x += (dx / dist) * (p.speed || 10);
                    p.y += (dy / dist) * (p.speed || 10);
                }
            }
        }
        // ç‰¹æ®Šéª°å­æ•ˆæœ
        // ã€ç™¼å°„ç«¯ã€‘è™•ç†ï¼šè™›æ“¬è¡€é‡ã€å¤ªé™½ AOEã€ç”¢ç”Ÿå­å½ˆ
        function executeAttack(dice, target, damage, startX, startY, isSunActivated) {
            if (target.virtualHp === undefined) target.virtualHp = target.hp;
            target.virtualHp -= damage;

            // å¤ªé™½ç™¼å…‰ï¼šç›´æ¥ AOE çˆ†ç‚¸ï¼Œä¸ç”¢ç”Ÿå­å½ˆ (æ•ˆèƒ½æœ€å„ª)
            if (dice.id === 'sun' && isSunActivated) {
                enemies.forEach(e => {
                    if (e.hp > 0 && Math.hypot(e.x - target.x, e.y - target.y) < 65) {
                        e.hp -= damage;
                        e.virtualHp -= damage;
                        if (damagePopups.length < 15) { // é™åˆ¶æ•¸å­—é˜²å¡
                            damagePopups.push({ x: e.x, y: e.y, val: Math.floor(damage), life: 20 });
                        }
                    }
                });
                return; // ç›´æ¥çµæŸï¼Œä¸è·‘ä¸‹é¢çš„ push
            }

            // å…¶ä»–éª°å­ï¼ˆæˆ–æ²’ç™¼å…‰çš„å¤ªé™½ï¼‰ï¼šç”¢ç”Ÿå­å½ˆï¼Œä¸¦æŠŠ ID å¸¶çµ¦å­å½ˆ
            projectiles.push({
                x: startX, y: startY,
                target: target,
                damage: damage,
                diceId: dice.id, // è®“ applyHitEffect çŸ¥é“è¦è§¸ç™¼ä»€éº¼æ•ˆæœ
                color: dice.color,
                speed: 12
            });
        }

        // ã€æ’æ“Šç«¯ã€‘è™•ç†ï¼šå–®é«”å‚·å®³ã€åŠŸèƒ½æ€§æ•ˆæœ (æ¸›é€Ÿã€ä¸­æ¯’ã€å‚³é€ã€é€£é–)
        function applyHitEffect(p) {
            const target = p.target;
            if (!target || target.hp <= 0) return;

            // 1. åŸºç¤å‚·å®³
            target.hp -= p.damage;
            if (damagePopups.length < 20) {
                damagePopups.push({ x: target.x, y: target.y, val: Math.floor(p.damage), life: 30 });
            }

            // 2. åŸ·è¡ŒåŠŸèƒ½æ€§æ•ˆæœ
            const spec = getDiceSpecialValue(p.diceId);
            switch (p.diceId) {
                case 'ice':
                    target.speed = Math.max(0.3, 1.5 * (1 - spec / 100));
                    clearTimeout(target.iceTimer);
                    target.iceTimer = setTimeout(() => { target.speed = 1.5; }, 1000);
                    break;
                case 'lock':
                    if (Math.random() < 0.2) {
                        target.speed = 0;
                        setTimeout(() => { target.speed = 1.5; }, spec * 1000);
                    }
                    break;
                case 'electric':
                    // é›»åŠ›é€£é– (æ’æ“Šæ‰è·³é›»ï¼Œè¦–è¦ºæ¯”è¼ƒè‡ªç„¶)
                    enemies.forEach(e => {
                        if (e !== target && e.hp > 0 && Math.hypot(e.x - target.x, e.y - target.y) < 100) {
                            let chainDmg = p.damage * 0.5;
                            e.hp -= chainDmg;
                            e.virtualHp -= chainDmg;
                            if (damagePopups.length < 10) {
                                damagePopups.push({ x: e.x, y: e.y, val: Math.floor(chainDmg), life: 20, color: "#fde047" });
                            }
                        }
                    });
                    break;
                case 'poison':
                    target.poisonStacks = (target.poisonStacks || 0) + 1;
                    break;
                case 'teleport':
                    if (Math.random() < (spec / 100) && !target.isBoss) {
                        target.x = path[0].x; target.y = path[0].y; target.pathIndex = 1;
                    }
                    break;
            }

            // 3. çµ±ä¸€æ¸…ç†æ­»äº¡æ€ªç‰© (ç§»é™¤ updateUI é¿å…é »ç¹é‡ç¹ª)
            for (let i = enemies.length - 1; i >= 0; i--) {
                if (enemies[i].hp <= 0) {
                    battleState.sp += enemies[i].rewardSp || 10;
                    enemies.splice(i, 1);
                }
            }
        }
        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                let e = enemies[i];

                // --- 1. è™•ç†ä¸­æ¯’æŒçºŒå‚·å®³ ---
                if (e.poisonStacks > 0) {
                    // æ¯ç§’é€ æˆ (å±¤æ•¸ * åŸºç¤å‚·å®³)
                    // åŸºç¤æ¯’å‚·è¨­ç‚º 2ï¼Œä½ å¯ä»¥æ ¹æ“š db.stats èª¿æ•´æ›´ç²¾ç¢ºçš„æ•¸å€¼
                    const poisonDmgPerFrame = (e.poisonStacks * 2) / 60;
                    e.hp -= poisonDmgPerFrame;

                    // æ¯ç§’ (60å¹€) é¡¯ç¤ºä¸€æ¬¡ç´«è‰²æ¯’å‚·æ•¸å­—
                    if (frameCount % 60 === 0) {
                        damagePopups.push({
                            x: e.x,
                            y: e.y - 15,
                            val: Math.floor(e.poisonStacks * 2),
                            color: "#a855f7", // ç´«è‰²ä»£è¡¨æ¯’ç´ 
                            life: 30
                        });
                    }
                }

                // --- 2. Boss æŠ€èƒ½é‚è¼¯ ---
                if (e.isBoss) {
                    if (!e.skillTimer) e.skillTimer = 0; // ç¢ºä¿ timer å­˜åœ¨
                    e.skillTimer++;
                    if (e.skillTimer >= BOSS_TYPES[e.bossType].skillInterval) {
                        BOSS_TYPES[e.bossType].onSkill(e);
                        e.skillTimer = 0;
                    }
                }

                // --- 3. ç§»å‹•é‚è¼¯ ---
                let target = path[e.pathIndex];
                let dx = target.x - e.x, dy = target.y - e.y, dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < e.speed) {
                    e.pathIndex++;
                    if (e.pathIndex >= path.length) {
                        battleState.hp--;
                        enemies.splice(i, 1);
                        updateUI();

                        // æˆ°æ•—åˆ¤æ–·
                        if (battleState.hp <= 0) {
                            handleGameOver(false); // å»ºè­°æ”¹ç”¨ function è™•ç†çµç®—ï¼Œè€Œä¸æ˜¯ç›´æ¥ reload
                            return;
                        }
                    }
                } else {
                    e.x += (dx / dist) * e.speed;
                    e.y += (dy / dist) * e.speed;
                }

                // --- 4. æª¢æŸ¥ä¸­æ¯’æˆ– DOT å°è‡´çš„æ­»äº¡ ---
                if (e.hp <= 0) {
                    battleState.sp += e.rewardSp || 10;
                    enemies.splice(i, 1);
                    updateUI();
                }
                if (battleState.wave > 20 && enemies.length === 0) {
                    handleGameOver(true); // å‚³å…¥ true ä»£è¡¨ã€Œå®Œå…¨é€šé—œã€
                    return;
                }
            }
        }
        function updateWave() {
            if (!waveState.isWaiting) {
                waveState.timer++;
                if (waveState.timer >= 30) {
                    if (battleState.wave % 10 === 0 && waveState.spawnedCount === 0) { spawnBoss(); waveState.spawnedCount = waveState.totalEnemiesPerWave; }
                    else if (waveState.spawnedCount < waveState.totalEnemiesPerWave) { spawnEnemy(); waveState.spawnedCount++; waveState.timer = 0; }
                    else if (enemies.length === 0) { waveState.isWaiting = true; waveState.timer = 0; }
                }
            } else {
                waveState.timer++;
                if (waveState.timer >= 60) {
                    if (battleState.wave >= 20) {
                        handleGameOver(true); // è§¸ç™¼å‹åˆ©çµç®—
                        return; // åœæ­¢å¾ŒçºŒé‚è¼¯ï¼Œé˜²æ­¢éŠæˆ²ç¹¼çºŒè·‘
                    }
                    battleState.wave++; waveState.spawnedCount = 0; waveState.totalEnemiesPerWave += 6; waveState.isWaiting = false; waveState.timer = 0; updateUI();
                }
            }
        }

        function updateUI() {
            document.getElementById('spText').innerText = Math.floor(battleState.sp);
            document.getElementById('summonCostText').innerText = battleState.summonCost;
            document.getElementById('hpText').innerText = battleState.hp;
            document.getElementById('waveText').innerText = battleState.wave;

            const container = document.getElementById('powerUpButtons');
            container.innerHTML = userData.deck.map((id) => {
                const dice = ALL_DICES.find(d => d.id === id);
                const lv = powerUpLevels[id] || 1;
                const cost = 100 * Math.pow(2, lv - 1);
                return `<button onclick="powerUpDice('${id}')" class="flex-1 min-w-0 bg-slate-800 border ${battleState.sp >= cost ? 'border-blue-500' : 'border-slate-700'} rounded-lg py-1.5 flex flex-col items-center active:scale-95 transition-all">
                <div class="w-7 h-7 rounded flex items-center justify-center text-[10px] font-bold mb-1" style="background-color: ${dice.baseColor}; color: white;">${dice.name}</div>
                <div class="text-[9px] text-yellow-500 font-bold">Lv.${lv}</div>
                <div class="text-[8px] text-slate-400 mt-1">${cost >= 1000 ? (cost / 1000).toFixed(1) + 'k' : cost}</div>
            </button>`;
            }).join('');
        }
        function refreshSunState() {
            const totalSunCount = grid.slots.filter(s => s.dice && s.dice.id === 'sun').length;
            isSunActivated = [1, 4, 7].includes(totalSunCount);
        }
        function startRenderLoop() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');

            function frame() {
                // 1. å¦‚æœéŠæˆ²æ²’é–‹å§‹æˆ–å·²çµæŸï¼Œåœæ­¢å¾ªç’°
                if (!battleState.isStarted) return;

                // é¡å¤–æª¢æŸ¥ï¼šå¦‚æœéŠæˆ²å·²ç¶“çµç®—ï¼Œå°±ä¸è¦å†ç•«äº†
                const modal = document.getElementById('resultModal');
                if (modal.style.display === 'flex') return;

                frameCount++;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // é‚è¼¯æ›´æ–°
                updateEnemies();
                updateWave();
                updateCombat();

                // ç•«è·¯å¾‘
                ctx.strokeStyle = "rgba(59, 130, 246, 0.1)";
                ctx.lineWidth = 30;
                ctx.lineJoin = "round";
                ctx.beginPath();
                ctx.moveTo(path[0].x, path[0].y);
                path.forEach(p => ctx.lineTo(p.x, p.y));
                ctx.stroke();

                // ç•«å­å½ˆ
                projectiles.forEach(p => {
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                });

                // ç•«æ•µäºº
                enemies.forEach(e => {
                    const s = e.isBoss ? e.size : 20;
                    ctx.fillStyle = e.isBoss ? e.color : "#ef4444";
                    ctx.fillRect(e.x - s / 2, e.y - s / 2, s, s);
                    ctx.fillStyle = "rgba(0,0,0,0.5)";
                    ctx.fillRect(e.x - 15, e.y - (s / 2 + 8), 30, 3);
                    ctx.fillStyle = "#22c55e";
                    ctx.fillRect(e.x - 15, e.y - (s / 2 + 8), (e.hp / e.maxHp) * 30, 3);
                });

                // ç•«å‚·å®³å­—é«”
                for (let i = damagePopups.length - 1; i >= 0; i--) {
                    let d = damagePopups[i];
                    ctx.fillStyle = `rgba(255, 255, 255, ${d.life / 30})`;
                    ctx.font = "bold 14px Arial";
                    ctx.fillText(d.val, d.x, d.y);
                    d.y -= 1;
                    d.life--;
                    if (d.life <= 0) damagePopups.splice(i, 1);
                }



                grid.slots.forEach(slot => {
                    // ç•«æ ¼å­èƒŒæ™¯
                    ctx.fillStyle = "rgba(255, 255, 255, 0.05)";
                    drawRoundedRect(ctx, slot.x, slot.y, grid.slotSize, grid.slotSize, 10);
                    ctx.fill();

                    if (slot.dice && !slot.isBeingDragged) {
                        // ä½¿ç”¨å¤–é¢å®£å‘Šå¥½çš„ ctxï¼Œçµ•å°ä¸è¦åœ¨è£¡é¢é‡æ–° getContext

                        // å¤ªé™½ç‰¹æ•ˆ
                        if (slot.dice.id === 'sun' && isSunActivated) {
                            drawEffect(slot, "orange");
                        }

                        // é½’è¼ªç‰¹æ•ˆ
                        if (slot.dice.id === 'gear' && slot.dice.isPowered) {
                            drawEffect(slot, "#00ccff");
                        }

                        // ç•«éª°å­ä¸»é«”
                        renderDice(ctx, slot.x, slot.y, slot.dice, slot.isLocked);
                    }
                });

                if (drag.isDragging) {
                    renderDice(ctx, drag.currentX - grid.slotSize / 2, drag.currentY - grid.slotSize / 2, drag.dice, false);
                }

                requestAnimationFrame(frame);
            }
            frame();
        }
        function renderDice(ctx, x, y, dice, isLocked) {
            ctx.strokeStyle = dice.qualityColor || '#fff'; ctx.lineWidth = 3;
            drawRoundedRect(ctx, x + 4, y + 4, grid.slotSize - 8, grid.slotSize - 8, 8); ctx.stroke();
            ctx.fillStyle = dice.color; drawRoundedRect(ctx, x + 6, y + 6, grid.slotSize - 12, grid.slotSize - 12, 6); ctx.fill();
            ctx.fillStyle = "#fff"; ctx.font = "bold 20px Arial"; ctx.textAlign = "center";
            ctx.fillText(dice.lv, x + grid.slotSize / 2, y + grid.slotSize / 2 + 7);
            if (isLocked) { ctx.fillStyle = "rgba(0,0,0,0.7)"; drawRoundedRect(ctx, x + 5, y + 5, grid.slotSize - 10, grid.slotSize - 10, 8); ctx.fill(); }
        }

        function drawRoundedRect(ctx, x, y, w, h, r) {
            ctx.beginPath(); ctx.moveTo(x + r, y); ctx.lineTo(x + w - r, y); ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r); ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h); ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r); ctx.lineTo(x, y + r); ctx.quadraticCurveTo(x, y, x + r, y); ctx.closePath();
        }

        function setupTouchEvents(canvas) {
            canvas.addEventListener('touchstart', (e) => {
                const touch = e.touches[0], rect = canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left, y = touch.clientY - rect.top;
                grid.slots.forEach(slot => {
                    if (slot.dice && x > slot.x && x < slot.x + grid.slotSize && y > slot.y && y < slot.y + grid.slotSize) {
                        drag.isDragging = true;
                        drag.fromSlot = slot;
                        drag.dice = { ...slot.dice }; // æ·ºæ‹·è²
                        drag.currentX = x;
                        drag.currentY = y;
                        slot.isBeingDragged = true;
                    }
                });
            });

            canvas.addEventListener('touchmove', (e) => {
                if (!drag.isDragging) return;
                e.preventDefault();
                const touch = e.touches[0], rect = canvas.getBoundingClientRect();
                drag.currentX = touch.clientX - rect.left;
                drag.currentY = touch.clientY - rect.top;
            }, { passive: false });

            canvas.addEventListener('touchend', () => {
                if (!drag.isDragging) return;

                let targetSlot = grid.slots.find(s =>
                    drag.currentX > s.x && drag.currentX < s.x + grid.slotSize &&
                    drag.currentY > s.y && drag.currentY < s.y + grid.slotSize
                );

                if (targetSlot && targetSlot !== drag.fromSlot && targetSlot.dice) {
                    // --- å°ä¸‘éª°å­è®Šèº«é‚è¼¯ ---
                    // ä¿®æ­£é»ï¼šåŠ ä¸Š targetSlot.dice.id !== 'joker' çš„åˆ¤å®š
                    if (drag.dice.id === 'joker' && drag.dice.lv === targetSlot.dice.lv && targetSlot.dice.id !== 'joker') {
                        const targetId = targetSlot.dice.id;
                        const db = ALL_DICES.find(d => d.id === targetId);

                        drag.fromSlot.dice = {
                            id: targetId,
                            lv: drag.dice.lv,
                            color: db.baseColor,
                            qualityColor: QUALITIES[db.quality].color,
                            growthTimer: 0,
                            attackCooldown: 0 // è®Šèº«å¾Œé‡ç½®æ”»æ“Šå†·å»ï¼Œé˜²æ­¢ç¬é–“å™´å½ˆå¡æ­»
                        };

                        drag.isDragging = false;
                        drag.fromSlot.isBeingDragged = false;
                        updateUI();
                        refreshSunState();
                        return; // åªæœ‰è®Šèº«æ‰åœ¨é€™è£¡ return
                    }

                    // --- ä¸€èˆ¬åˆæˆé‚è¼¯ (åŒ…å«å°ä¸‘ç¢°å°ä¸‘) ---
                    if (targetSlot.dice.id === drag.dice.id && targetSlot.dice.lv === drag.dice.lv && targetSlot.dice.lv < 7) {
                        const newId = userData.deck[Math.floor(Math.random() * userData.deck.length)];
                        const db = ALL_DICES.find(d => d.id === newId);

                        targetSlot.dice = {
                            id: newId,
                            lv: drag.dice.lv + 1,
                            color: db.baseColor,
                            qualityColor: QUALITIES[db.quality].color,
                            growthTimer: 0,
                            attackCooldown: 0
                        };
                        drag.fromSlot.dice = null;
                        updateUI();
                        refreshSunState()
                    }
                }
                // 3. å¦‚æœæ˜¯ç§»åˆ°ç©ºä½
                else if (targetSlot && !targetSlot.dice) {
                    targetSlot.dice = { ...drag.dice, growthTimer: drag.dice.growthTimer || 0 };
                    drag.fromSlot.dice = null;
                }

                // çµ±ä¸€é‡ç½®ç‹€æ…‹
                drag.isDragging = false;
                if (drag.fromSlot) drag.fromSlot.isBeingDragged = false;
                updateUI();
                refreshSunState();
            });
        }
        function drawEffect(slot, color) {
            // å–å¾—ä¸­å¿ƒé»
            const centerX = slot.x + grid.slotSize / 2;
            const centerY = slot.y + grid.slotSize / 2;
            const radius = (grid.slotSize / 2) - 5;

            // ä½¿ç”¨æ­£å¼¦æ³¢åšå‘¼å¸ç‡ˆæ•ˆæœ
            const pulse = Math.sin(Date.now() / 200);

            ctx.save();

            // 1. ç•«å¤–åœˆå‘¼å¸å…‰ç’° (ä¸ä½¿ç”¨ shadowBlur)
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.globalAlpha = 0.4 + (pulse * 0.2); // è®“é€æ˜åº¦éš¨æ™‚é–“è®ŠåŒ–ï¼Œæ¨¡æ“¬ç™¼å…‰æ„Ÿ
            ctx.arc(centerX, centerY, radius + 2, 0, Math.PI * 2);
            ctx.stroke();

            // 2. ç•«å…§åœˆä¸»ç·š
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.globalAlpha = 1.0;
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.stroke();

            ctx.restore();
        }
    </script>
</body>

</html>