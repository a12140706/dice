<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>骰子戰爭 - 戰場</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
        margin: 0;
        padding: 0;
        height: 100vh;
        width: 100vw;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        background-color: #020617;
    }
#footer-controls {
        flex-shrink: 0;
        padding: 16px;
        padding-bottom: 24px; /* 手機安全距離 */
        background: rgba(15, 23, 42, 0.9);
        border-top: 1px solid rgba(51, 65, 85, 0.5);
    }
    #canvas-container {
        flex-grow: 1;
        position: relative;
        width: 100%;
    }
        #gameCanvas {
            background: radial-gradient(circle, #1e293b 0%, #020617 100%);
            touch-action: none;
            width: 100%;
            height: 100%;
        }

        .glass-panel {
            background: rgba(30, 41, 49, 0.8);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .diff-card {
            transition: all 0.3s;
            border: 2px solid transparent;
            cursor: pointer;
        }

        .diff-card:active {
            transform: scale(0.95);
        }

        .energy-glow {
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.5);
        }

        .scroll-hide::-webkit-scrollbar {
            display: none;
        }
    </style>
</head>

<body class="flex flex-col h-screen">

    <div id="header-info" class="p-3 flex justify-between items-center bg-slate-900/50">
        <div class="flex items-center gap-4">
            <span class="text-red-500 font-bold">HP: <span id="hpText">3</span></span>
            <span class="text-blue-400 font-bold">SP: <span id="spText">100</span></span>
        </div>
        <div class="text-slate-400 font-bold">WAVE: <span id="waveText">1</span></div>
    </div>

    <div id="canvas-container">
        <canvas id="gameCanvas"></canvas>
    </div>

    <div id="footer-controls">
        <div id="powerUpBar" class="flex gap-2 overflow-x-auto pb-4 mb-2"></div>
        <button onclick="summonDice()" class="w-full py-4 bg-blue-600 rounded-xl font-black text-xl shadow-lg active:scale-95 transition-all">
            召喚骰子 (<span id="summonCostText">10</span> SP)
        </button>
    </div>

    <div id="difficultyOverlay" class="fixed inset-0 z-50 bg-black/95 flex items-center justify-center p-6">
        <div class="w-full max-w-sm">
            <h2
                class="text-center text-2xl font-black mb-8 text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-400">
                選擇戰鬥難度</h2>
            <div class="space-y-4">
                <button onclick="startGame('normal')"
                    class="diff-card w-full bg-slate-800 p-4 rounded-2xl flex justify-between items-center border-slate-700">
                    <span class="font-bold text-lg">簡單模式</span>
                    <span class="text-xs text-green-400 bg-green-900/30 px-2 py-1 rounded">1x 獎勵</span>
                </button>
                <button onclick="startGame('hard')"
                    class="diff-card w-full bg-slate-800 p-4 rounded-2xl flex justify-between items-center border-blue-500/50">
                    <span class="font-bold text-lg">困難模式</span>
                    <span class="text-xs text-blue-400 bg-blue-900/30 px-2 py-1 rounded">2.5x 獎勵</span>
                </button>
                <button onclick="startGame('hell')"
                    class="diff-card w-full bg-slate-800 p-4 rounded-2xl flex justify-between items-center border-red-500/50">
                    <span class="font-bold text-lg text-red-500">地獄模式</span>
                    <span class="text-xs text-red-400 bg-red-900/30 px-2 py-1 rounded">6x 獎勵</span>
                </button>
            </div>
        </div>
    </div>

    <script>
    // --- 1. 基礎資料定義 ---
    const QUALITIES = {
        common: { name: '普通', color: '#ffffff', textColor: '#000' },
        rare: { name: '稀有', color: '#3b82f6', textColor: '#fff' },
        epic: { name: '史詩', color: '#a855f7', textColor: '#fff' },
        legend: { name: '傳說', color: '#eab308', textColor: '#000' },
        mythic: { name: '神話', color: '#ff00ff', textColor: '#fff' }
    };

    // 確保這裡的 baseColor 與大廳一致
    const ALL_DICES = [
        { id: 'fire', name: '火', quality: 'common', baseColor: '#ef4444' },
        { id: 'wind', name: '風', quality: 'common', baseColor: '#10b981' },
        { id: 'ice', name: '冰', quality: 'rare', baseColor: '#3b82f6' },
        { id: 'electric', name: '電', quality: 'rare', baseColor: '#f59e0b' },
        { id: 'poison', name: '毒', quality: 'epic', baseColor: '#8b5cf6' },
        { id: 'growth', name: '成長', quality: 'legend', baseColor: '#f472b6' },
        { id: 'sun', name: '太陽', quality: 'legend', baseColor: '#fbbf24' },
        { id: 'galaxy', name: '銀河', quality: 'mythic', baseColor: '#1e293b' }
    ];

    const BOSS_TYPES = {
        'CRUSHER': {
            name: '粉碎者', color: '#ff4444', skillInterval: 300,
            onSkill: (boss) => {
                const occupied = grid.slots.filter(s => s.dice && !s.isLocked);
                if (occupied.length > 0) {
                    const target = occupied[Math.floor(Math.random() * occupied.length)];
                    target.isLocked = true;
                    setTimeout(() => { target.isLocked = false; }, 4000);
                }
            }
        },
        'SNAKE': {
            name: '噴射者', color: '#22c55e', skillInterval: 240,
            onSkill: (boss) => {
                enemies.forEach(e => e.speed *= 1.5);
                setTimeout(() => { enemies.forEach(e => e.speed /= 1.5); }, 2000);
            }
        }
    };

    // --- 2. 遊戲狀態與變數 ---
    const savedData = JSON.parse(localStorage.getItem('dice_game_data')) || { deck: ['fire', 'wind', 'ice', 'electric', 'poison'] };
    const deckData = savedData.deck;

    let powerUpState = {};
    deckData.forEach(id => {
        powerUpState[id] = { level: 1, baseCost: 100, costStep: 100 };
    });

    let battleState = { hp: 3, sp: 100, wave: 1, summonCost: 10, difficulty: 'normal', isStarted: false };
    let grid = { rows: 3, cols: 5, padding: 10, slotSize: 0, slots: [] };
    let drag = { isDragging: false, fromSlot: null, currentX: 0, currentY: 0, dice: null };
    let waveState = { totalEnemiesPerWave: 10, spawnedCount: 0, isWaiting: false, timer: 0 };
    let projectiles = [];
    let path = [];
    let enemies = [];
    const TICKS_PER_ATTACK = 60;

    // --- 3. 核心函數 ---
    function getPowerUpMultiplier(diceId) {
        const lv = powerUpState[diceId]?.level || 1;
        return 1 + (lv - 1) * 0.25;
    }

    function startGame(diff) {
        battleState.difficulty = diff;
        battleState.isStarted = true;
        document.getElementById('difficultyOverlay').style.display = 'none';
        initGame();
    }

   function initGame() {
        const canvas = document.getElementById('gameCanvas');
        const container = document.getElementById('canvas-container');
        
        // 修正 Canvas 解析度：根據容器的實際渲染尺寸設定
        canvas.width = container.offsetWidth;
        canvas.height = container.offsetHeight;
        
        initGrid(canvas);
        initPath(canvas);
        setupTouchEvents(canvas);
        renderPowerUpBar();
        updateUI();
        startRenderLoop();
    }

    function initGrid(canvas) {
        // 設定左右保留 30px 安全距離，避免被螢幕吃掉
        const sideMargin = 30;
        grid.slotSize = (canvas.width - (grid.cols + 1) * grid.padding - (sideMargin * 2)) / grid.cols;
        
        const totalGridHeight = grid.rows * (grid.slotSize + grid.padding);
        
        // y 座標設為畫布中間偏上，留給下方更多空間
        grid.y = (canvas.height * 0.45) - (totalGridHeight / 2);
        grid.h = totalGridHeight;
        
        // 記錄物理座標
        grid.left = sideMargin + grid.padding;
        grid.right = canvas.width - sideMargin - grid.padding;
        grid.top = grid.y;
        grid.bottom = grid.y + grid.h;

        grid.slots = [];
        for (let i = 0; i < grid.rows * grid.cols; i++) {
            const r = Math.floor(i / grid.cols);
            const c = i % grid.cols;
            grid.slots.push({
                x: grid.left + c * (grid.slotSize + grid.padding),
                y: grid.top + r * (grid.slotSize + grid.padding),
                dice: null, isLocked: false, isBeingDragged: false
            });
        }
    }

    function initPath(canvas) {
        // 怪物路徑距離骰子盤邊緣 15px
        const offset = 15;
        const L = grid.left - offset;
        const R = grid.right + offset;
        const T = grid.top - offset;
        const B = grid.bottom + offset;

        path = [
            { x: L, y: T }, // 左上 (起點)
            { x: R, y: T }, // 右上
            { x: R, y: B }, // 右下
            { x: L, y: B }, // 左下
            { x: L, y: T + 10 } // 終點 (稍微錯開避免重疊)
        ];
    }

    function setupTouchEvents(canvas) {
        canvas.addEventListener('touchstart', (e) => {
            const touch = e.touches[0], rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left, y = touch.clientY - rect.top;
            grid.slots.forEach(slot => {
                if (slot.dice && x > slot.x && x < slot.x + grid.slotSize && y > slot.y && y < slot.y + grid.slotSize) {
                    drag.isDragging = true;
                    drag.fromSlot = slot;
                    drag.dice = { ...slot.dice };
                    drag.currentX = x; drag.currentY = y;
                    slot.isBeingDragged = true;
                }
            });
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            if (!drag.isDragging) return;
            e.preventDefault();
            const touch = e.touches[0], rect = canvas.getBoundingClientRect();
            drag.currentX = touch.clientX - rect.left;
            drag.currentY = touch.clientY - rect.top;
        }, { passive: false });

        canvas.addEventListener('touchend', () => {
            if (!drag.isDragging) return;
            let targetSlot = grid.slots.find(s => drag.currentX > s.x && drag.currentX < s.x + grid.slotSize && drag.currentY > s.y && drag.currentY < s.y + grid.slotSize);

            if (targetSlot && targetSlot !== drag.fromSlot) {
                if (targetSlot.dice && targetSlot.dice.id === drag.dice.id && targetSlot.dice.lv === drag.dice.lv && targetSlot.dice.lv < 7) {
                    const newId = deckData[Math.floor(Math.random() * deckData.length)];
                    const db = ALL_DICES.find(d => d.id === newId);
                    targetSlot.dice = { 
                        id: newId, lv: drag.dice.lv + 1, 
                        color: db.baseColor,
                        qualityColor: QUALITIES[db.quality].color
                    };
                    drag.fromSlot.dice = null;
                } else if (!targetSlot.dice) {
                    targetSlot.dice = drag.dice;
                    drag.fromSlot.dice = null;
                }
            }
            drag.isDragging = false;
            if (drag.fromSlot) drag.fromSlot.isBeingDragged = false;
        });
    }

    function summonDice() {
        if (battleState.sp < battleState.summonCost) return;
        const emptySlots = grid.slots.filter(s => s.dice === null);
        if (emptySlots.length === 0) return;
        battleState.sp -= battleState.summonCost;
        battleState.summonCost += 10;
        const targetSlot = emptySlots[Math.floor(Math.random() * emptySlots.length)];
        const diceId = deckData[Math.floor(Math.random() * deckData.length)];
        const db = ALL_DICES.find(d => d.id === diceId);
        targetSlot.dice = { 
            id: diceId, lv: 1, 
            color: db.baseColor,
            qualityColor: QUALITIES[db.quality].color
        };
        updateUI();
    }

    function upgradeDice(diceId) {
        const s = powerUpState[diceId];
        const cost = s.baseCost + (s.level - 1) * s.costStep;
        if (battleState.sp >= cost && s.level < 5) {
            battleState.sp -= cost;
            s.level++;
            updateUI();
            renderPowerUpBar();
        }
    }

    function spawnEnemy() {
        let growthRate = (battleState.difficulty === 'hell' ? 0.5 : 0.35);
        const finalHp = 100 * Math.pow(1 + growthRate, battleState.wave - 1);
        enemies.push({
            x: path[0].x, y: path[0].y, pathIndex: 1, 
            maxHp: finalHp, hp: finalHp, virtualHp: finalHp, // 預判專用
            speed: 1.5 + (battleState.difficulty === 'hell' ? (battleState.wave * 0.05) : 0),
            rewardSp: 10 + Math.floor(battleState.wave / 2), isBoss: false
        });
        waveState.spawnedCount++;
    }

    function spawnBoss() {
        const typeKey = Object.keys(BOSS_TYPES)[Math.floor(Math.random() * 2)];
        const config = BOSS_TYPES[typeKey];
        const finalHp = 2000 * Math.pow(1.5, battleState.wave / 10);
        enemies.push({
            x: path[0].x, y: path[0].y, pathIndex: 1, 
            maxHp: finalHp, hp: finalHp, virtualHp: finalHp, // 預判專用
            speed: 0.7, rewardSp: 150 + (battleState.wave * 5), isBoss: true,
            bossType: typeKey, skillTimer: 0, size: 50, color: config.color
        });
    }

    function updateWave() {
        if (!waveState.isWaiting) {
            waveState.timer++;
            if (waveState.timer >= 90) {
                if (battleState.wave % 10 === 0 && waveState.spawnedCount === 0) {
                    spawnBoss();
                    waveState.spawnedCount = waveState.totalEnemiesPerWave;
                } else if (waveState.spawnedCount < waveState.totalEnemiesPerWave) {
                    spawnEnemy();
                    waveState.timer = 0;
                } else if (enemies.length === 0) {
                    waveState.isWaiting = true;
                    waveState.timer = 0;
                }
            }
        } else {
            waveState.timer++;
            if (waveState.timer >= 180) {
                battleState.wave++;
                waveState.spawnedCount = 0;
                waveState.totalEnemiesPerWave += 2;
                waveState.isWaiting = false;
                waveState.timer = 0;
                updateUI();
            }
        }
    }

  function updateCombat() {
        grid.slots.forEach(slot => {
            if (slot.dice && !slot.isBeingDragged && !slot.isLocked) {
                if (!slot.attackCooldown) slot.attackCooldown = 0;
                slot.attackCooldown++;
                
                const speedFactor = 1 + (slot.dice.lv - 1) * 0.2;
                if (slot.attackCooldown >= TICKS_PER_ATTACK / speedFactor) {
                    
                    // --- 預判邏輯開始 ---
                    // 1. 篩選出「還沒被預定打死」的怪 (virtualHp > 0)
                    // 2. 依然依照路徑進度排序，打最前面的
                    const availableEnemies = enemies.filter(e => (e.virtualHp === undefined ? e.hp : e.virtualHp) > 0);
                    const target = availableEnemies.sort((a, b) => b.pathIndex - a.pathIndex)[0];

                    if (target) {
                        const finalDamage = 10 * slot.dice.lv * (1 + (powerUpState[slot.dice.id].level - 1) * 0.25);
                        
                        // 初始化 virtualHp 並扣除預期傷害
                        if (target.virtualHp === undefined) target.virtualHp = target.hp;
                        target.virtualHp -= finalDamage;

                        projectiles.push({
                            x: slot.x + grid.slotSize / 2,
                            y: slot.y + grid.slotSize / 2,
                            target: target,
                            color: slot.dice.color,
                            speed: 8,
                            damage: finalDamage
                        });
                        slot.attackCooldown = 0;
                    }
                }
            }
        });

        for (let i = projectiles.length - 1; i >= 0; i--) {
            let p = projectiles[i];
            
            // 如果目標在飛行途中已經因為其他子彈「實際死亡」了
            if (!enemies.includes(p.target)) {
                projectiles.splice(i, 1);
                continue;
            }

            let dx = p.target.x - p.x, dy = p.target.y - p.y, dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 15) {
                // 實際扣血
                p.target.hp -= p.damage;
                
                if (p.target.hp <= 0) {
                    const idx = enemies.indexOf(p.target);
                    if (idx > -1) { 
                        battleState.sp += p.target.rewardSp; 
                        enemies.splice(idx, 1); 
                        updateUI(); 
                    }
                }
                projectiles.splice(i, 1);
            } else { 
                p.x += (dx / dist) * p.speed; 
                p.y += (dy / dist) * p.speed; 
            }
        }
    }

// 輔助函式：計算到下一個路徑點的距離
function distToNext(e) {
    const next = path[e.pathIndex];
    if (!next) return 0;
    return Math.sqrt((next.x - e.x)**2 + (next.y - e.y)**2);
}
    function updateEnemies() {
        for (let i = enemies.length - 1; i >= 0; i--) {
            let e = enemies[i];
            if (e.isBoss) {
                e.skillTimer++;
                const cfg = BOSS_TYPES[e.bossType];
                if (e.skillTimer >= cfg.skillInterval) { cfg.onSkill(e); e.skillTimer = 0; }
            }
            let target = path[e.pathIndex];
            let dx = target.x - e.x, dy = target.y - e.y, dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < e.speed) {
                e.pathIndex++;
                if (e.pathIndex >= path.length) {
                    battleState.hp--; enemies.splice(i, 1); updateUI();
                    if (battleState.hp <= 0) { 
                        alert("戰敗！即將返回大廳"); 
                        window.location.href = 'dice.html'; // 跳回大廳
                    }
                }
            } else { e.x += (dx / dist) * e.speed; e.y += (dy / dist) * e.speed; }
        }
    }

    function renderPowerUpBar() {
        document.getElementById('powerUpBar').innerHTML = deckData.map(id => {
            const d = ALL_DICES.find(dice => dice.id === id);
            const s = powerUpState[id], cost = s.baseCost + (s.level - 1) * s.costStep, isMax = s.level >= 5;
            const qColor = QUALITIES[d.quality].color;
            return `
                <div onclick="upgradeDice('${id}')" class="min-w-[85px] p-2 rounded-xl text-center border ${isMax ? 'bg-slate-700 opacity-80' : 'bg-slate-800 border-slate-700'} active:scale-95 transition-all">
                    <div class="text-[9px] ${isMax ? 'text-yellow-500' : 'text-slate-500'}">Lv.${s.level}</div>
                    <div class="font-bold text-sm" style="color:${d.baseColor}">${d.name}</div>
                    <div class="text-[10px] text-yellow-500">${isMax ? 'MAX' : cost + ' SP'}</div>
                </div>`;
        }).join('');
    }

    function updateUI() {
        document.getElementById('spText').innerText = Math.floor(battleState.sp);
        document.getElementById('summonCostText').innerText = battleState.summonCost;
        document.getElementById('hpText').innerText = battleState.hp;
        document.getElementById('waveText').innerText = battleState.wave;
    }

    function startRenderLoop() {
        const canvas = document.getElementById('gameCanvas'), ctx = canvas.getContext('2d');
        function frame() {
            if (!battleState.isStarted) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawPath(ctx);
            updateEnemies(); updateWave(); updateCombat();
            
            projectiles.forEach(p => { ctx.beginPath(); ctx.fillStyle = p.color; ctx.arc(p.x, p.y, 4, 0, Math.PI * 2); ctx.fill(); });
            enemies.forEach(e => {
                const s = e.isBoss ? e.size : 20;
                ctx.fillStyle = e.isBoss ? e.color : "#ef4444";
                ctx.fillRect(e.x - s/2, e.y - s/2, s, s);
                ctx.fillStyle = "rgba(0,0,0,0.5)"; ctx.fillRect(e.x-15, e.y-(s/2+8), 30, 3);
                ctx.fillStyle = "#22c55e"; ctx.fillRect(e.x-15, e.y-(s/2+8), (e.hp/e.maxHp)*30, 3);
            });

            grid.slots.forEach(slot => {
                ctx.fillStyle = "rgba(255, 255, 255, 0.05)";
                drawRoundedRect(ctx, slot.x, slot.y, grid.slotSize, grid.slotSize, 10); ctx.fill();
                
                if (slot.dice && !slot.isBeingDragged) {
                    // 1. 繪製品質外框 (使用 qualityColor)
                    ctx.strokeStyle = slot.dice.qualityColor || '#fff';
                    ctx.lineWidth = 3;
                    drawRoundedRect(ctx, slot.x + 4, slot.y + 4, grid.slotSize - 8, grid.slotSize - 8, 8);
                    ctx.stroke();

                    // 2. 繪製骰子本體 (使用屬性 baseColor)
                    ctx.fillStyle = slot.dice.color;
                    drawRoundedRect(ctx, slot.x + 6, slot.y + 6, grid.slotSize - 12, grid.slotSize - 12, 6);
                    ctx.fill();

                    // 3. 點數文字 (統一白色確保可讀性)
                    ctx.fillStyle = "#fff"; 
                    ctx.font = "bold 20px Arial"; ctx.textAlign = "center";
                    ctx.fillText(slot.dice.lv, slot.x+grid.slotSize/2, slot.y+grid.slotSize/2+7);
                    
                    if (slot.isLocked) { ctx.fillStyle = "rgba(0,0,0,0.7)"; drawRoundedRect(ctx, slot.x+5, slot.y+5, grid.slotSize-10, grid.slotSize-10, 8); ctx.fill(); }
                }
            });

            if (drag.isDragging) {
                ctx.globalAlpha = 0.7; ctx.fillStyle = drag.dice.color;
                drawRoundedRect(ctx, drag.currentX - grid.slotSize/2, drag.currentY - grid.slotSize/2, grid.slotSize, grid.slotSize, 10); ctx.fill();
                ctx.globalAlpha = 1; ctx.fillStyle = "#fff";
                ctx.fillText(drag.dice.lv, drag.currentX, drag.currentY+7);
            }
            requestAnimationFrame(frame);
        }
        frame();
    }

    function drawPath(ctx) {
        ctx.strokeStyle = "rgba(59, 130, 246, 0.1)"; ctx.lineWidth = 30; ctx.lineJoin = "round";
        ctx.beginPath(); ctx.moveTo(path[0].x, path[0].y);
        path.forEach(p => ctx.lineTo(p.x, p.y)); ctx.stroke();
    }

    function drawRoundedRect(ctx, x, y, w, h, r) {
        ctx.beginPath(); ctx.moveTo(x+r, y); ctx.lineTo(x+w-r, y); ctx.quadraticCurveTo(x+w, y, x+w, y+r);
        ctx.lineTo(x+w, y+h-r); ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h); ctx.lineTo(x+r, y+h);
        ctx.quadraticCurveTo(x, y+h, x, y+h-r); ctx.lineTo(x, y+r); ctx.quadraticCurveTo(x, y, x+r, y); ctx.closePath();
    }
</script>
</body>

</html>