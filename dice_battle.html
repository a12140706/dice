<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>éª°å­æˆ°çˆ­ - æˆ°å ´</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            height: 100dvh;
            /* ä½¿ç”¨ dvh ç¢ºä¿åœ¨æ‰‹æ©Ÿä¸Šè‡ªå‹•æ‰£é™¤ç¶²å€åˆ—é«˜åº¦ */
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            background-color: #020617;
        }

        /* å¤ªé™½çˆ†ç‚¸å…‰åœˆ */
        .sun-explosion {
            position: absolute;
            border: 3px solid #fb923c;
            /* åŠ ç²—ä¸€é»æ¯”è¼ƒæ˜é¡¯ */
            background: rgba(251, 146, 60, 0.3);
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            /* ç¢ºä¿åœ“å¿ƒå°æº–æ€ªç‰©çš„ (x, y) */
            animation: sunExplode 0.4s ease-out forwards;
            z-index: 100;
            /* ç¢ºä¿å¤§æ–¼ Canvas çš„ z-index */
            box-shadow: 0 0 15px orange;
            /* å¢åŠ ç™¼å…‰æ„Ÿ */
        }

        @keyframes sunExplode {
            0% {
                width: 0px;
                height: 0px;
                opacity: 1;
            }

            100% {
                width: 130px;
                height: 130px;
                opacity: 0;
            }
        }

        #header-info {
            flex-shrink: 0;
            /* å›ºå®šé ­éƒ¨é«˜åº¦ */
        }

        #footer-controls {
            flex-shrink: 0;
            /* å›ºå®šåº•éƒ¨é«˜åº¦ */
            padding: 12px;
            padding-bottom: env(safe-area-inset-bottom, 20px);
            /* é‡å° iPhone åº•éƒ¨ç™½æ¢çš„æ’ç‰ˆå„ªåŒ– */
            background: rgba(15, 23, 42, 0.95);
            border-top: 1px solid rgba(51, 65, 85, 0.5);
        }

        #canvas-container {
            position: relative;
            width: 100%;
            max-width: min(550px, 80vh);
            /* ç§»é™¤å›ºå®šçš„ 90vhï¼Œæ”¹ç”¨ flex-grow è®“å®ƒè‡ªå‹•ä½”æ»¿å‰©é¤˜ç©ºé–“ */
            flex-grow: 1;
            margin: 0 auto;
            overflow: hidden;
            background: #000;
        }

        #gameCanvas {
            background: radial-gradient(circle at center, #69ff69 0%, #40004d 100%);
            touch-action: none;
            width: 100%;
            height: 100%;
        }

        .glass-panel {
            background: rgba(30, 41, 49, 0.8);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .diff-card {
            transition: all 0.3s;
            border: 2px solid transparent;
            cursor: pointer;
        }

        .diff-card:active {
            transform: scale(0.95);
        }

        .energy-glow {
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.5);
        }

        .scroll-hide::-webkit-scrollbar {
            display: none;
        }

        .pb-safe {
            /* é€™è£¡ä½¿ç”¨ calc ç¢ºä¿åŸæœ¬çš„ p-3 (12px) åŠ ä¸Š iOS å®‰å…¨å€ */
            padding-bottom: calc(0.75rem + env(safe-area-inset-bottom)) !important;
        }

        /* ç¢ºä¿æ•´å€‹æˆ°é¬¥å®¹å™¨æ˜¯ä½”æ»¿è¢å¹•ä¸”ä¸æº¢å‡ºçš„ */
        body,
        html {
            height: 100%;
            margin: 0;
            overflow: hidden;
            /* é˜²æ­¢æ©¡çš®ç­‹å›å½ˆå½±éŸ¿æˆ°é¬¥ */
            display: flex;
            flex-direction: column;
        }

        /* ç¢ºä¿ Footer æ˜¯å›ºå®šé«˜åº¦æˆ–è‡ªå‹•æ’é–‹ï¼Œä¸è¢«é®æ“‹ */
        #footer-controls {
            background-color: #0f172a;
            /* çµ¦å®ƒä¸€å€‹å¯¦åº•è‰²ï¼Œé¿å…ç™½æ¢ç©¿é€çœ‹åˆ°èƒŒæ™¯ */
        }
    </style>
</head>

<body class="flex flex-col h-screen bg-slate-900">
    <div id="header-info" class="p-3 flex justify-between items-center bg-slate-900/50">
        <div class="flex items-center gap-4">
            <span class="text-red-500 font-bold">HP: <span id="hpText">3</span></span>
            <span class="text-blue-400 font-bold">SP: <span id="spText">100</span></span>
        </div>
        <div class="text-slate-400 font-bold text-sm">LEVEL: <span id="headerLevelText">1</span></div>
        <div class="text-slate-400 font-bold text-sm">WAVE: <span id="waveText">1</span></div>
    </div>

    <div id="canvas-container" class="flex-1 relative">
        <canvas id="gameCanvas"
            style="touch-action: none; user-select: none; -webkit-user-select: none; -webkit-touch-callout: none; width: 100%; height: 100%; display: block;"></canvas>
    </div>

    <div id="footer-controls" class="p-3 max-w-[500px] mx-auto w-full pb-safe">
        <div class="flex flex-nowrap w-full gap-1 mb-4">
            <div id="powerUpButtons" class="contents"></div>
        </div>
        <button onclick="summonDice()"
            class="w-full py-4 bg-blue-600 rounded-xl font-black text-xl shadow-lg active:scale-95 transition-all text-white">
            å¬å–šéª°å­ (<span id="summonCostText">10</span> SP)
        </button>
    </div>

    <div id="difficultyOverlay" class="fixed inset-0 z-50 bg-black/95 flex items-center justify-center p-6">
        <div class="w-full max-w-sm text-center">
            <h2 class="text-2xl font-black mb-2 text-blue-400">å†’éšªæ¨¡å¼</h2>
            <div class="bg-slate-800 p-6 rounded-3xl border border-slate-700 mb-8">
                <p class="text-slate-400 text-sm">ç•¶å‰é€²åº¦</p>
                <h1 class="text-4xl font-black text-white mt-1">ç¬¬ <span id="currentLevelText">1</span> é—œ</h1>
                <p class="text-xs text-slate-500 mt-2">æ¯é—œåŒ…å« 20 å±¤</p>
            </div>

            <button onclick="startGame()"
                class="w-full bg-blue-600 py-4 rounded-2xl font-bold text-xl text-white active:scale-95 transition-all">
                é–‹å§‹æŒ‘æˆ°
            </button>
        </div>
    </div>

    <div id="resultModal"
        style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index:9999; flex-direction:column; align-items:center; justify-content:center; color:white;">

        <h1 id="resTitle" style="font-size:40px; margin:10px 0;">æˆ°ç¸¾çµç®—</h1>

        <div
            style="background:#1e293b; padding:20px; border-radius:15px; border:2px solid #3b82f6; text-align:center; min-width:250px;">
            <p style="font-size:18px; margin:5px 0;">æ’éæ³¢æ•¸ï¼š<span id="resWave" style="color:#facc15;">0</span> / 20</p>
            <hr style="border:0; border-top:1px solid #475569; margin:15px 0;">
            <p style="margin:5px 0;">ç²å¾—çå‹µ</p>
            <div style="font-size:28px; font-weight:bold; color:#10b981; margin-top:10px;">
                ğŸ« æŠ½çåˆ¸ x <span id="resTickets">0</span>
            </div>
        </div>

        <button onclick="location.href='dice.html'"
            style="margin-top:30px; padding:12px 35px; font-size:18px; background:#3b82f6; color:white; border:none; border-radius:8px; font-weight:bold;">
            é ˜å–ä¸¦å›å¤§å»³
        </button>
    </div>
    <script>
        let userData = JSON.parse(localStorage.getItem('dice_game_data')) || {
            deck: ['fire', 'wind', 'ice', 'electric', 'poison'],
            diceLevels: { 'fire': 1, 'wind': 1, 'ice': 1, 'electric': 1, 'poison': 1 },
            tickets: 0,
            unlockLevel: 1, // æ–°å¢ï¼šç´€éŒ„æ­·å²æœ€é«˜å±¤æ•¸
            maxWave: 0
        };
        if (userData.tickets === undefined) userData.tickets = 0;
        document.getElementById('currentLevelText').innerText = userData.unlockLevel || 1;
        document.getElementById('headerLevelText').innerText = userData.unlockLevel || 1;
        const AudioManager = {
            ctx: new (window.AudioContext || window.webkitAudioContext)(),
            buffers: {},

            // é åŠ è¼‰éŸ³æ•ˆ (å‚³å…¥åç¨±èˆ‡è·¯å¾‘)
            async init() {
                const savedData = localStorage.getItem('dice_game_data');
                if (savedData) {
                    userData = JSON.parse(savedData);
                }
                const sounds = {
                    'hit': 'dice-sound/hit.wav'
                    // ä»¥å¾Œå¯ä»¥å¢åŠ æ›´å¤šï¼Œä¾‹å¦‚ 'summon': 'dice-sound/summon.wav'
                };

                for (const [name, url] of Object.entries(sounds)) {
                    try {
                        const response = await fetch(url);
                        const arrayBuffer = await response.arrayBuffer();
                        this.buffers[name] = await this.ctx.decodeAudioData(arrayBuffer);
                        console.log(`éŸ³æ•ˆåŠ è¼‰æˆåŠŸ: ${name}`);
                    } catch (e) {
                        console.error(`éŸ³æ•ˆåŠ è¼‰å¤±æ•—: ${name}`, e);
                    }
                }
            },

            // æ’­æ”¾æ‰“æ“ŠéŸ³æ•ˆ
            playHit() {
                // å¦‚æœéœéŸ³æˆ–å°šæœªåŠ è¼‰ï¼Œå‰‡è¿”å›
                if (!this.buffers['hit'] || (userData.settings && !userData.settings.sfx)) return;

                // iPhone è§£é–é‚è¼¯
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }

                const source = this.ctx.createBufferSource();
                source.buffer = this.buffers['hit'];

                // è¨­å®šéŸ³é‡ (15å€‹éª°å­ä¸€èµ·æ‰“ï¼ŒéŸ³é‡ä¸€å®šè¦å°ï¼Œå»ºè­° 0.05 ~ 0.1)
                const gainNode = this.ctx.createGain();
                gainNode.gain.value = 0.08;

                source.connect(gainNode);
                gainNode.connect(this.ctx.destination);
                source.start(0);
            }
        };

        // é é¢åŠ è¼‰æ™‚åŸ·è¡Œåˆå§‹åŒ–
        AudioManager.init();

        const QUALITIES = {
            common: { name: 'æ™®é€š', color: '#9ca3af', chance: 0.50 },
            rare: { name: 'ç¨€æœ‰', color: '#3b82f6', chance: 0.30 },
            epic: { name: 'å²è©©', color: '#a855f7', chance: 0.18 },
            legend: { name: 'å‚³èªª', color: '#eab308', chance: 0.019 },
            mythic: { name: 'ç¥è©±', color: '#ff00ff', chance: 0.001 }
        };

        const ALL_DICES = [
            // --- Common (æ™®é€š) ---
            {
                id: 'fire', name: 'ç«', quality: 'common', baseColor: '#ef4444', pattern: 'fire',
                stats: { atk: 18, speed: 55 }, grow: { atk: 6, speed: -1 },
                special: { label: 'æ¿ºå°„ç¯„åœ', value: 1.0, unit: 'æ ¼', grow: 0.1 }
            },
            {
                id: 'wind', name: 'é¢¨', quality: 'common', baseColor: '#10b981', pattern: 'wind',
                stats: { atk: 8, speed: 35 }, grow: { atk: 2, speed: -1.5 }, // å‰Šå¼±åŸºç¤ï¼Œè®“å‡ºå‰æœŸéœ¸ä¸»ä½ç½®
                special: { label: 'é€£æ“Šæ©Ÿç‡', value: 10, unit: '%', grow: 3 }
            },
            {
                id: 'ice', name: 'å†°', quality: 'common', baseColor: '#3b82f6', pattern: 'ice',
                stats: { atk: 7, speed: 60 }, grow: { atk: 1, speed: -1 },
                special: { label: 'ç·©é€Ÿæ•ˆæœ', value: 20, unit: '%', grow: 2 }
            },
            {
                id: 'electric', name: 'é›»', quality: 'common', baseColor: '#f59e0b', pattern: 'electric',
                stats: { atk: 6, speed: 45 }, grow: { atk: 2, speed: -1 },
                special: { label: 'é€£é–ç›®æ¨™', value: 3, unit: 'é«”', grow: 1 }
            },
            {
                id: 'poison', name: 'æ¯’', quality: 'common', baseColor: '#008000', pattern: 'poison',
                stats: { atk: 4, speed: 50 }, grow: { atk: 2, speed: -1 },
                special: { label: 'ä¸­æ¯’å‚·å®³', value: 12, unit: 'pt', grow: 4 }
            },

            // --- Rare (ç¨€æœ‰) ---
            {
                id: 'lock', name: 'é–å®š', quality: 'rare', baseColor: '#64748b', pattern: 'lock',
                stats: { atk: 12, speed: 55 }, grow: { atk: 4, speed: -1 },
                special: { label: 'ç¦éŒ®æ™‚é•·', value: 0.8, unit: 'ç§’', grow: 0.2 }
            },
            // --- æ˜“å‚·éª°å­ (æ›¿ä»£åŸæœ¬çš„ç ´ç”²) ---
            {
                id: 'crack', name: 'æ˜“å‚·', quality: 'rare', baseColor: '#f87171', pattern: 'crack',
                stats: { atk: 12, speed: 50 }, grow: { atk: 3, speed: -1 },
                special: { label: 'é¡å¤–å—å‚·', value: 8, unit: '%', grow: 1 }
            },
            // --- ç¤¦å±±éª°å­ (ç¶“æ¿Ÿå‹) ---
            {
                id: 'mine', name: 'ç¤¦å±±', quality: 'rare', baseColor: '#fbbf24', pattern: 'mine',
                stats: { atk: 0, speed: 40 }, grow: { atk: 0, speed: -5 }, // ä¸æ”»æ“Šï¼Œé€Ÿåº¦ä»£è¡¨ç”¢éŒ¢é–“éš”
                special: { label: 'ç”¢å‡ºSP', value: 10, unit: 'pt', grow: 5 }
            },

            // --- Epic (å²è©©) ---
            {
                id: 'laser', name: 'é›·å°„', quality: 'epic', baseColor: '#ec4899', pattern: 'laser_beam',
                stats: { atk: 8, speed: 40 }, grow: { atk: 2, speed: 0 },
                special: { label: 'å¢å¹…ä¸Šé™', value: 5, unit: 'å€', grow: 1 }
                // åŠŸèƒ½ï¼šæŒçºŒæ”»æ“ŠåŒä¸€å€‹ç›®æ¨™æ™‚ï¼Œå‚·å®³æœƒéš¨æ”»æ“Šæ¬¡æ•¸ä¸æ–·çˆ¬å‡
            },
            {
                id: 'teleport', name: 'å‚³é€', quality: 'epic', baseColor: '#8b5cf6', pattern: 'teleport',
                stats: { atk: 10, speed: 65 }, grow: { atk: 3, speed: -1 },
                special: { label: 'å‚³é€å›èµ·é»', value: 5, unit: '%', grow: 2 }
            },
            {
                id: 'gear', name: 'é½’è¼ª', quality: 'epic', baseColor: '#475569', pattern: 'gear',
                stats: { atk: 15, speed: 50 }, grow: { atk: 8, speed: -1 },
                special: { label: 'é€£çµåŠ æˆ', value: 12, unit: '%', grow: 6 }
            },

            // --- Legend (å‚³èªª) ---
            {
                id: 'mighty_wind', name: 'å¼·é¢¨', quality: 'legend', baseColor: '#a5f3fc', pattern: 'mighty_wind',
                stats: { atk: 15, speed: 40 }, grow: { atk: 6, speed: -1 },
                special: { label: 'ç‹‚æš´æ™‚é•·', value: 2, unit: 'ç§’', grow: 0.5 }
            },
            {
                id: 'joker', name: 'å°ä¸‘', quality: 'legend', baseColor: '#f87171', pattern: 'joker',
                stats: { atk: 5, speed: 50 }, grow: { atk: 1, speed: 0 },
                special: { label: 'ç¹¼æ‰¿æ¯”ä¾‹', value: 80, unit: '%', grow: 2 } // ä¾ç…§ä½ çš„æ¸¬è©¦ä¿ç•™ 80%
            },
            {
                id: 'growth', name: 'æˆé•·', quality: 'legend', baseColor: '#f472b6', pattern: 'growth',
                stats: { atk: 5, speed: 50 }, grow: { atk: 1, speed: -1 },
                special: { label: 'æˆé•·æ™‚é–“', value: 40, unit: 'ç§’', grow: -2 } // å› æ‡‰ç¯€å¥èª¿å¿«ï¼Œç¸®çŸ­è‡³ 40 ç§’
            },
            {
                id: 'sun', name: 'å¤ªé™½', quality: 'legend', baseColor: '#fbbf24', pattern: 'sun',
                stats: { atk: 35, speed: 55 }, grow: { atk: 15, speed: -0.5 },
                special: { label: 'æ¿ºå°„å‚·å®³', value: 100, unit: '%', grow: 25 }
            },
            {
                id: 'sanctuary', name: 'è–åŸŸ', quality: 'legend', baseColor: '#fbbf24', pattern: 'sanctuary',
                stats: { atk: 15, speed: 60 }, grow: { atk: 6, speed: -1 },
                special: { label: 'åŠ é€Ÿç¯„åœ', value: 30, unit: '%', grow: 5 }
            },
            {
                id: 'comet', name: 'å½—æ˜Ÿ', quality: 'legend', baseColor: '#3b82f6', pattern: 'comet',
                stats: { atk: 18, speed: 45 }, grow: { atk: 7, speed: -1 },
                special: { label: 'å……èƒ½å€ç‡', value: 500, unit: '%', grow: 100 }
            },

            // --- Epic (å²è©©) æ–°å¢ ---
            {
                id: 'chain', name: 'é€£é–', quality: 'epic', baseColor: '#8b5cf6', pattern: 'chain',
                stats: { atk: 15, speed: 50 }, grow: { atk: 5, speed: -1 },
                special: { label: 'å½ˆå°„å¢å‚·', value: 50, unit: '%', grow: 10 }
            },

            // --- Mythic (ç¥è©±) ---
            {
                id: 'doom', name: 'æ¯€æ»…', quality: 'mythic', baseColor: '#7c3aed', pattern: 'doom',
                stats: { atk: 45, speed: 50 }, grow: { atk: 20, speed: -1 },
                special: { label: 'æ–¬æ®ºæ¯”ä¾‹', value: 35, unit: '%', grow: 5 }
            },
            {
                id: 'galaxy', name: 'éŠ€æ²³', quality: 'mythic', baseColor: '#6366f1', pattern: 'galaxy',
                stats: { atk: 60, speed: 50 }, grow: { atk: 30, speed: -1 },
                special: { label: 'é»‘æ´åå™¬', value: 2, unit: '%', grow: 1 }
            }
        ];

        const BOSS_TYPES = {
            'CRUSHER': {
                name: 'ç²‰ç¢è€…',
                color: '#ff4444',
                // æ›´æ–°ç‚º PNG æª”æ¡ˆè·¯å¾‘
                img: (() => { const i = new Image(); i.src = 'dice-boss/lock.png'; return i; })(),
                skillInterval: 300,
                onSkill: (boss) => {
                    const occupied = grid.slots.filter(s => s.dice && !s.isLocked);
                    if (occupied.length > 0) {
                        const target = occupied[Math.floor(Math.random() * occupied.length)];
                        target.isLocked = true;
                        setTimeout(() => { target.isLocked = false; }, 4000);
                    }
                }
            },
            'SNAKE': {
                name: 'å™´å°„è€…',
                color: '#22c55e',
                img: (() => { const i = new Image(); i.src = 'dice-boss/speed.png'; return i; })(),
                skillInterval: 240,
                onSkill: (boss) => {
                    enemies.forEach(e => e.speed *= 1.5);
                    setTimeout(() => { enemies.forEach(e => e.speed /= 1.5); }, 2000);
                }
            }
        };
        const BALANCE = {
            // --- æ™®é€šæ€ªç‰© ---
            ENEMY_BASE_HP: 100,        // åŸºç¤è¡€é‡
            ENEMY_LEVEL_GROWTH: 1.25,  // è·¨é—œå¡æˆé•· (æ¯å¤šä¸€é—œå¤š 25% è¡€é‡)
            ENEMY_WAVE_GROWTH: 1.20,   // æ¯æ³¢æˆé•· (æ¯å¤šä¸€æ³¢å¤š 15% è¡€é‡)
            //ENEMY_SPEED_BASE: 1.5,     // åˆå§‹ç§»é€Ÿ
            //ENEMY_SPEED_WAVE_ADD: 0.015, // æ¯æ³¢å¢åŠ çš„ç§»é€Ÿ

            // --- Boss ---
            BOSS_BASE_HP: 3000,        // Boss åŸºç¤è¡€é‡
            BOSS_LEVEL_GROWTH: 1.6,    // Boss è·¨é—œå¡æˆé•·
            BOSS_WAVE_GROWTH: 1.8,     // Boss éš¨æ³¢æ¬¡æˆé•·ç³»æ•¸ (ä»¥ 10 æ³¢ç‚ºå–®ä½)
            //BOSS_SPEED_BASE: 1.0,      // Boss åˆå§‹ç§»é€Ÿ
            // BOSS_SPEED_WAVE_ADD: 0.01  // Boss æ¯æ³¢å¢åŠ çš„ç§»é€Ÿ
        };

        let battleState = { hp: 3, sp: 100, wave: 1, summonCost: 10, difficulty: 'normal', isStarted: false };
        let powerUpLevels = {};
        userData.deck.forEach(id => { powerUpLevels[id] = 1; });
        let frameCount = 0;
        let grid = { rows: 3, cols: 5, padding: 10, slotSize: 0, slots: [], y: 0 };
        let drag = { isDragging: false, fromSlot: null, currentX: 0, currentY: 0, dice: null };
        let waveState = { totalEnemiesPerWave: 10, spawnedCount: 0, isWaiting: false, timer: 0 };
        let projectiles = [], enemies = [], path = [], damagePopups = [];
        let visualEffects = []; // æ–°å¢ï¼šè¦–è¦ºç‰¹æ•ˆåˆ—è¡¨

        function startGame(diff) {
            // --- æ–°å¢ï¼šè§£é–éŸ³è¨Š (iPhone é—œéµ) ---
            if (typeof AudioManager !== 'undefined' && AudioManager.ctx) {
                if (AudioManager.ctx.state === 'suspended') {
                    AudioManager.ctx.resume().then(() => {
                        console.log("AudioContext resumed successfully");
                    });
                }
            }

            // --- åŸæœ‰é‚è¼¯ ---
            battleState.difficulty = diff;
            battleState.isStarted = true;
            document.getElementById('difficultyOverlay').style.display = 'none';
            initGame();
        }

        function initGame() {
            const canvas = document.getElementById('gameCanvas');
            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;

            initGrid(canvas);
            initPath(canvas);
            setupTouchEvents(canvas);
            updateUI();
            startRenderLoop();
        }

        function initGrid(canvas) {
            // å¢åŠ å´é‚Šé‚Šè·ï¼Œæ‰‹æ©Ÿä¸Šå»ºè­°çµ¦åˆ°ç•«å¸ƒå¯¬åº¦çš„ 15% å·¦å³ï¼Œé¿å…ä½”æ»¿å·¦å³
            const sideMargin = canvas.width * 0.12;

            // è¨ˆç®—å–®å€‹æ ¼å­çš„å°ºå¯¸
            grid.slotSize = (canvas.width - (grid.cols + 1) * grid.padding - (sideMargin * 2)) / grid.cols;

            const totalGridHeight = grid.rows * (grid.slotSize + grid.padding);
            // è®“éª°å­å€ç¨å¾®å¾€ä¸‹é ä¸€é»ï¼Œçµ¦ä¸Šæ–¹ç•™å‡ºæˆ°é¬¥ç©ºé–“
            grid.y = (canvas.height / 2) - (totalGridHeight / 2);

            grid.slots = [];
            for (let i = 0; i < grid.rows * grid.cols; i++) {
                const r = Math.floor(i / grid.cols), c = i % grid.cols;
                grid.slots.push({
                    x: sideMargin + grid.padding + c * (grid.slotSize + grid.padding),
                    y: grid.y + r * (grid.slotSize + grid.padding),
                    dice: null, isLocked: false, isBeingDragged: false, attackCooldown: 0
                });
            }
        }
        function getDiceSpecialValue(diceId) {
            if (!diceId) return 0;
            const dice = ALL_DICES.find(d => d.id === diceId);
            if (!dice || !dice.special) return 0;

            const lv = (userData.diceLevels && userData.diceLevels[diceId]) ? userData.diceLevels[diceId] : 1;

            // åŠ ä¸Š || 0 ç¢ºä¿å¦‚æœè³‡æ–™è¡¨æ²’å¯« value æˆ– growï¼Œä¸æœƒè®Šæˆ NaN
            const base = dice.special.value || 0;
            const grow = dice.special.grow || 0;

            return base + (lv - 1) * grow;
        }
        function transformJoker(jokerDice, targetDice) {
            const ratio = getDiceSpecialValue('joker') / 100; // æ‹¿åˆ° 0.8, 0.82...

            jokerDice.name = targetDice.name;
            jokerDice.baseColor = targetDice.baseColor;

            // ç¹¼æ‰¿æ”»æ“ŠåŠ› (å—æ¯”ä¾‹å½±éŸ¿)
            jokerDice.atk = targetDice.atk * ratio;

            // å¦‚æœè¤‡è£½çš„æ˜¯æˆé•·éª°å­ï¼Œæ™‚é–“è¦è®Šé•· (æ•ˆç‡é™ä½)
            if (targetDice.id === 'growth') {
                const targetTime = getDiceSpecialValue('growth');
                jokerDice.timer = targetTime / ratio; // ä¾‹å¦‚ 60 / 0.8 = 75ç§’
            }
        }
        function handleGameOver(isVictory) {
            let earnedTickets = 0;

            // 1. æ›´æ–°æœ€é«˜å±¤æ•¸ç´€éŒ„ (ç›®å‰çš„æ³¢æ•¸é€²åº¦)
            if (battleState.wave > (userData.maxWave || 0)) {
                userData.maxWave = battleState.wave;
            }

            // 2. è™•ç†å‹è² èˆ‡çå‹µé‚è¼¯
            if (isVictory) {
                // --- æˆåŠŸé€šé—œ ---
                // çå‹µæ”¹ç‚ºï¼šç•¶å‰é—œå¡ * 2 (ä¾‹å¦‚ç¬¬ 3 é—œé€šé—œçµ¦ 6 å¼µ)
                earnedTickets = (userData.unlockLevel || 1) * 2;

                // è§£é–ä¸‹ä¸€é—œ
                userData.unlockLevel = (userData.unlockLevel || 1) + 1;

                // é‡ç½®æœ€é«˜å±¤æ•¸ (å› ç‚ºæŒ‘æˆ°æ–°é—œå¡äº†)
                userData.maxWave = 0;
            } else {
                // --- å¤±æ•— ---
                // å¤±æ•—çå‹µå¯ä»¥ä¿ç•™åŸæœ¬çš„ã€Œæ¯ 5 å±¤çµ¦ 1 å¼µã€ï¼Œæˆ–æ˜¯ä½ ä¹Ÿå¯ä»¥æ”¹æˆ 0
                earnedTickets = Math.floor(battleState.wave / 10);
            }

            // 3. ç´¯åŠ é‡‘å¹£/åˆ¸ ä¸¦ å­˜æª”
            userData.tickets = (userData.tickets || 0) + earnedTickets;
            localStorage.setItem('dice_game_data', JSON.stringify(userData));

            // 4. å¼·åˆ¶æ›´æ–° HTML ä¸Šçš„æ–‡å­— (è§£æ±ºä½ æåˆ°çš„é¡¯ç¤ºæ²’è®Šçš„å•é¡Œ)
            // é€™è£¡æˆ‘å€‘åŒæ™‚æ›´æ–°ä½ é‚£å…©å€‹ id (header å’Œ overlay)
            const currentLv = userData.unlockLevel || 1;
            if (document.getElementById('currentLevelText')) {
                document.getElementById('currentLevelText').innerText = currentLv;
            }
            // å‡è¨­ä½ å¾Œä¾†æ”¹äº† ID å€åˆ†
            if (document.getElementById('headerLevelText')) {
                document.getElementById('headerLevelText').innerText = currentLv;
            }

            // 5. é¡¯ç¤ºçµç®—ç•«é¢
            showResultModal(isVictory, currentLv, battleState.wave, earnedTickets);
        }
        function showResultModal(isVictory, level, wave, tickets) {
            const modal = document.getElementById('resultModal');
            const title = document.getElementById('resTitle');

            if (isVictory) {
                title.innerText = "ğŸ‰ å®Œç¾é€šé—œ";
                title.style.color = "#facc15"; // é‡‘è‰²
            } else {
                title.innerText = "ğŸ’€ æˆ°æ•—";
                title.style.color = "#ef4444"; // ç´…è‰²
            }

            // é¡¯ç¤ºæ ¼å¼ï¼šç¬¬ 1 é—œ - 20 å±¤
            document.getElementById('resWave').innerText = `ç¬¬ ${level} é—œ - ${wave} å±¤`;
            document.getElementById('resTickets').innerText = tickets;
            modal.style.display = 'flex';
        }
        function initPath(canvas) {
            // 1. å–å¾—éª°å­é•·æ–¹å½¢çš„å››å€‹é‚Šç•Œ
            const gridTop = grid.y;
            const gridBottom = grid.y + (grid.rows * (grid.slotSize + grid.padding));

            // 2. è¨­å®šæ€ªç‰©èˆ‡éª°å­æ ¼çš„ã€Œé–“è·ã€(Gap)
            // å¦‚æœ Gap è¨­ç‚º 0ï¼Œæ€ªç‰©å°±æœƒç›´æ¥å£“åœ¨éª°å­é‚Šç·šä¸Šèµ°
            const gap = 35;

            // 3. è¨­å®šå·¦å³é‚Šç•Œ (åƒè€ƒä¹‹å‰ç¸®å°å¾Œçš„ grid å¯¬åº¦)
            const L = grid.slots[0].x - gap; // ä»¥æœ€å·¦é‚Šçš„éª°å­æ ¼åº§æ¨™å¾€å¤–æ¨
            const R = grid.slots[grid.cols - 1].x + grid.slotSize + gap; // ä»¥æœ€å³é‚Šå¾€å¤–æ¨

            // 4. å®šç¾©è·¯å¾‘ï¼Œè®“å®ƒè®Šæˆä¸€å€‹ã€Œè²¼åˆéª°å­å€ã€çš„é•·æ–¹å½¢
            const T = gridTop - gap;
            const B = gridBottom + gap;

            path = [
                { x: L, y: T }, // å·¦ä¸Š
                { x: R, y: T }, // å³ä¸Š
                { x: R, y: B }, // å³ä¸‹
                { x: L, y: B }, // å·¦ä¸‹
                { x: L, y: T + 5 } // çµ‚é» (ç•¥å¾®åç§»é¿å…é‡ç–Š)
            ];
        }

        function summonDice() {
            if (battleState.sp < battleState.summonCost) return;
            const emptySlots = grid.slots.filter(s => s.dice === null);
            if (emptySlots.length === 0) return;

            battleState.sp -= battleState.summonCost;
            battleState.summonCost += 10;

            const targetSlot = emptySlots[Math.floor(Math.random() * emptySlots.length)];
            const diceId = userData.deck[Math.floor(Math.random() * userData.deck.length)];
            const db = ALL_DICES.find(d => d.id === diceId);

            // ç¢ºä¿ slot ç‹€æ…‹ä¹¾æ·¨
            targetSlot.isLocked = false;
            targetSlot.isBeingDragged = false;
            targetSlot.attackCooldown = 0; // é‡ç½®è©²ä½ç½®çš„å†·å»

            // å®Œæ•´çš„éª°å­è³‡æ–™ç‰©ä»¶
            targetSlot.dice = {
                id: diceId,
                lv: 1,
                baseColor: db.baseColor, // å¿…é ˆæ–°å¢é€™è¡Œï¼
                color: db.baseColor,     // å…¼å®¹èˆŠé‚è¼¯
                pattern: db.pattern || diceId, // ç¢ºä¿æœ‰åœ–é¨°è³‡è¨Š
                qualityColor: QUALITIES[db.quality].color,
                growthTimer: 0,
                isPowered: false
            };

            // å¦‚æœ slot ç‰©ä»¶æœ¬èº«æ²’æœ‰ x, y åƒç´ å€¼ï¼Œè¦åœ¨é€™è£¡è¨ˆç®—çµ¦ updateCombat ç”¨
            if (targetSlot.x === undefined) {
                targetSlot.x = targetSlot.col * grid.slotSize;
                targetSlot.y = targetSlot.row * grid.slotSize;
            }

            updateUI();
            if (typeof refreshSunState === 'function') refreshSunState();
        }

        function powerUpDice(id) {
            const lv = powerUpLevels[id] || 1;
            const cost = 100 * Math.pow(2, lv - 1);
            if (battleState.sp >= cost && lv < 5) {
                battleState.sp -= cost;
                powerUpLevels[id] = lv + 1;
                updateUI();
            }
        }

        function spawnEnemy() {
            // ç¢ºä¿å¾ userData æŠ“å–ï¼Œè‹¥ç‚º undefined å‰‡ä¿åº•ç‚º 1
            const level = Number(userData.unlockLevel) || 1;
            const wave = Number(battleState.wave) || 1;

            // åŸºç¤ HP è¨ˆç®—ï¼ŒåŠ å…¥ Math.max ç¢ºä¿ä¸æœƒæœ‰ 0 è¡€æ€ª
            const hp = Math.max(1,
                BALANCE.ENEMY_BASE_HP * Math.pow(BALANCE.ENEMY_LEVEL_GROWTH, level - 1) * Math.pow(BALANCE.ENEMY_WAVE_GROWTH, wave - 1)
            );

            enemies.push({
                x: path[0].x,
                y: path[0].y,
                pathIndex: 1,
                maxHp: hp,
                hp: hp,
                virtualHp: hp, // åŒæ­¥è™›æ“¬è¡€é‡
                speed: 1.5,
                rewardSp: 10 + Math.floor((battleState.wave - 1) / 5) * 5,
                isBoss: false
            });
        }

        function spawnBoss() {
            // å–å¾—ç•¶å‰é—œå¡ï¼Œè‹¥ç„¡å‰‡é è¨­ç‚º 1
            const level = userData.unlockLevel || 1;
            const wave = Number(battleState.wave) || 1;
            // éš¨æ©Ÿé¸å– Boss ç¨®é¡
            const typeKeys = Object.keys(BOSS_TYPES);
            const type = typeKeys[Math.floor(Math.random() * typeKeys.length)];

            // --- Boss HP å…¬å¼èª¿æ•´ ---
            // åŸºç¤ 2000 * (é—œå¡é›£åº¦åŠ æˆ 1.5å€) * (å±¤æ•¸åŠ æˆ)
            // é€™æ¨£ç¬¬ 2 é—œçš„ç¬¬ 10 æ³¢ Boss æœƒæ¯”ç¬¬ 1 é—œçš„ç¬¬ 20 æ³¢æ›´æœ‰æŒ‘æˆ°æ€§
            const hp = BALANCE.BOSS_BASE_HP * Math.pow(BALANCE.BOSS_LEVEL_GROWTH, level - 1) * Math.pow(BALANCE.BOSS_WAVE_GROWTH, (wave / 10));
            enemies.push({
                x: path[0].x,
                y: path[0].y,
                pathIndex: 1,
                maxHp: hp,
                hp: hp,
                virtualHp: hp,
                speed: 1, // éš¨é—œå¡ç¨å¾®æå‡ç§»é€Ÿï¼Œå¢åŠ é›£åº¦
                rewardSp: 200 + (level * 2), // è¶Šå¾Œé¢çš„ Boss çµ¦è¶Šå¤š SP
                isBoss: true,
                bossType: type,
                skillTimer: 0,
                size: 55, // Boss å¤§ä¸€é»æ¯”è¼ƒæœ‰éœ¸æ°£
                color: BOSS_TYPES[type].color
            });
        }

        function updateCombat() {
            if (typeof isSunActivated === 'undefined') window.isSunActivated = false;

            // --- æª¢æŸ¥è–åŸŸå…‰ç’° (å…¨å±€åŠ é€Ÿ) ---
            let sanctuaryBoost = 0;
            grid.slots.forEach(slot => {
                if (slot.dice && slot.dice.id === 'sanctuary' && !slot.isLocked) {
                    const pLv = userData.diceLevels['sanctuary'] || 1;
                    const db = ALL_DICES.find(d => d.id === 'sanctuary');
                    const boostPercent = (db.special.value + (pLv - 1) * db.special.grow) / 100;
                    sanctuaryBoost = Math.max(sanctuaryBoost, boostPercent); // å–æœ€é«˜å€¼ï¼Œä¸ç–ŠåŠ 
                }
            });

            grid.slots.forEach(slot => {
                if (slot.dice && slot.dice.id && !slot.isBeingDragged && slot.isLocked !== true) {
                    const db = ALL_DICES.find(d => d.id === slot.dice.id);
                    if (!db) return;
                    // åœ¨ updateCombat å‡½æ•¸å…§ï¼Œgrid.slots.forEach å¾ªç’°ä¸­
                    if (slot.dice.id === 'mighty_wind') {
                        const cycle = (Date.now() % 8000); // 7ç§’ä¸€è¼ª
                        const burstTime = getDiceSpecialValue('mighty_wind') * 1000;
                        if (cycle < burstTime) {
                            spd = 6; // æ¥µé€Ÿæ¨¡å¼
                            slot.dice.color = "#ffffff"; // è¦–è¦ºè®ŠåŒ–
                        } else {
                            slot.dice.color = db.baseColor;
                        }
                    }
                    if (slot.dice.id === 'mine') {
                        slot.mineTimer = (slot.mineTimer || 0) + 1;
                        const pLv = userData.diceLevels['mine'] || 1;
                        // è¨ˆç®—ç”¢éŒ¢é€Ÿåº¦ (spd)
                        let spd = Math.max(60, db.stats.speed + (pLv - 1) * db.grow.speed);

                        if (slot.mineTimer >= spd) {
                            const spAmount = getDiceSpecialValue('mine') * slot.dice.lv;
                            battleState.sp += spAmount;

                            // å¢åŠ ä¸€å€‹é‡‘å¹£è·³å‡ºçš„è¦–è¦ºå›é¥‹
                            if (damagePopups.length < 15) {
                                damagePopups.push({
                                    x: slot.x + grid.slotSize / 2,
                                    y: slot.y,
                                    val: `+${spAmount} SP`,
                                    life: 40,
                                    color: "#fbbf24"
                                });
                            }
                            slot.mineTimer = 0;
                            if (typeof updateUI === 'function') updateUI();
                        }
                        return; // ç¤¦å±±éª°å­ä¸åŸ·è¡Œä¸‹æ–¹çš„å°‹æ•µæ”»æ“Šé‚è¼¯
                    }
                    // --- A. æˆé•·éª°å­é‚è¼¯ (ä¿æŒåŸæ¨£) ---
                    if (slot.dice.id === 'growth') {
                        if (!slot.dice.growthTimer) slot.dice.growthTimer = 0;
                        slot.dice.growthTimer++;
                        const targetSeconds = getDiceSpecialValue('growth');
                        if (slot.dice.growthTimer >= targetSeconds * 60) {
                            if (slot.dice.lv < 7) {
                                const newId = userData.deck[Math.floor(Math.random() * userData.deck.length)];
                                const newDb = ALL_DICES.find(d => d.id === newId);
                                slot.dice = {
                                    id: newId,
                                    lv: slot.dice.lv + 1,
                                    baseColor: newDb.baseColor,
                                    color: newDb.baseColor,
                                    qualityColor: QUALITIES[newDb.quality].color,
                                    growthTimer: 0,
                                    attackCooldown: 0
                                };
                                if (typeof updateUI === 'function') updateUI();
                                if (typeof refreshSunState === 'function') refreshSunState();
                            }
                        }
                    }

                    // --- B. æ”»é€Ÿèˆ‡æ”»æ“Š ---
                    const pLv = userData.diceLevels[slot.dice.id] || 1;
                    let spd = Math.max(10, db.stats.speed + (pLv - 1) * db.grow.speed);

                    // è–åŸŸåŠ é€Ÿ
                    if (sanctuaryBoost > 0 && slot.dice.id !== 'sanctuary') {
                        spd *= (1 - sanctuaryBoost);
                    }

                    if (slot.dice.id === 'sun' && isSunActivated) spd /= 1.5;
                    if (spd < 5) spd = 5;

                    slot.attackCooldown = (slot.attackCooldown || 0) + 1;

                    if (slot.attackCooldown >= spd) {
                        // --- æ ¸å¿ƒä¿®æ”¹ï¼šç²¾ç¢ºé–å®šæœ€å‰æ€ªç‰© ---
                        const target = enemies
                            .filter(e => e.hp > 0 && (e.virtualHp !== undefined ? e.virtualHp : e.hp) > 0)
                            .sort((a, b) => {
                                // 1. å…ˆæ¯”è·¯å¾‘é€²åº¦ (å“ªä¸€å€‹ç¶“éçš„è·¯å¾‘é»å¤š)
                                if (b.pathIndex !== a.pathIndex) {
                                    return b.pathIndex - a.pathIndex;
                                }
                                // 2. å¦‚æœè·¯å¾‘é»ä¸€æ¨£ï¼Œæ¯”è·é›¢ä¸‹ä¸€å€‹é»çš„è·é›¢ (è¶Šå°ä»£è¡¨è¶Šå‰é¢)
                                // æˆ‘å€‘ç°¡å–®ç”¨ç•¶å‰åº§æ¨™èˆ‡ path[pathIndex] çš„è·é›¢ä¾†æ¯”
                                const nextPoint = path[a.pathIndex];
                                if (nextPoint) {
                                    const distA = Math.hypot(a.x - nextPoint.x, a.y - nextPoint.y);
                                    const distB = Math.hypot(b.x - nextPoint.x, b.y - nextPoint.y);
                                    return distA - distB;
                                }
                                return 0;
                            })[0];

                        if (target) {
                            const powerUpLv = powerUpLevels[slot.dice.id] || 1;
                            let dmg = (db.stats.atk + (pLv - 1) * db.grow.atk) * slot.dice.lv * (1 + (powerUpLv - 1) * 0.4);

                            // é½’è¼ªåŠ æˆé‚è¼¯ä¿æŒåŸæ¨£
                            if (slot.dice.id === 'gear') {
                                const idx = grid.slots.indexOf(slot);
                                const col = idx % grid.cols;
                                const row = Math.floor(idx / grid.cols);
                                let neighbors = 0;
                                grid.slots.forEach((s, sIdx) => {
                                    if (s.dice && s.dice.id === 'gear' && s !== slot) {
                                        let sCol = sIdx % grid.cols;
                                        let sRow = Math.floor(sIdx / grid.cols);
                                        if (Math.abs(sCol - col) + Math.abs(sRow - row) === 1) neighbors++;
                                    }
                                });
                                dmg *= (1 + neighbors * 0.5);
                            }

                            // --- å½—æ˜Ÿå……èƒ½æ©Ÿåˆ¶ ---
                            let isCometCharged = false;
                            if (slot.dice.id === 'comet') {
                                slot.dice.chargeCount = (slot.dice.chargeCount || 0) + 1;
                                if (slot.dice.chargeCount >= 5) {
                                    const cometDb = ALL_DICES.find(d => d.id === 'comet');
                                    const cometBoost = (cometDb.special.value + (pLv - 1) * cometDb.special.grow) / 100;
                                    dmg *= cometBoost; // 500% = Ã—5
                                    isCometCharged = true;
                                    slot.dice.chargeCount = 0;
                                }
                            }

                            slot.dice.tempSlotIdx = grid.slots.indexOf(slot);
                            slot.dice.tempIsCometCharged = isCometCharged; // å‚³éçµ¦ executeAttack
                            executeAttack(
                                slot.dice,
                                target,
                                dmg,
                                slot.x + grid.slotSize / 2,
                                slot.y + grid.slotSize / 2,
                                isSunActivated
                            );
                            slot.attackCooldown = 0;
                        }
                    }
                }
            });

            // å­å½ˆç§»å‹•é‚è¼¯ (ä¿æŒåŸæ¨£)
            for (let i = projectiles.length - 1; i >= 0; i--) {
                let p = projectiles[i];
                if (!enemies.includes(p.target) || p.target.hp <= 0) {
                    projectiles.splice(i, 1);
                    continue;
                }
                let dx = p.target.x - p.x;
                let dy = p.target.y - p.y;
                let dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < 15) {
                    applyHitEffect(p);
                    projectiles.splice(i, 1);
                } else {
                    p.x += (dx / dist) * (p.speed || 10);
                    p.y += (dy / dist) * (p.speed || 10);
                }
            }
        }
        // ç‰¹æ®Šéª°å­æ•ˆæœ
        // ã€ç™¼å°„ç«¯ã€‘è™•ç†ï¼šè™›æ“¬è¡€é‡ã€å¤ªé™½ AOEã€ç”¢ç”Ÿå­å½ˆ
        function executeAttack(dice, target, damage, startX, startY, isSunActivated) {
            if (!target) return;

            if (dice.id === 'sun' && isSunActivated) {
                // --- 1. CSS çˆ†ç‚¸ç‰¹æ•ˆ ---
                const gameContainer = document.getElementById('canvas-container');
                if (gameContainer) {
                    const effect = document.createElement('div');
                    effect.className = 'sun-explosion';
                    effect.style.left = target.x + 'px';
                    effect.style.top = target.y + 'px';
                    gameContainer.appendChild(effect);
                    setTimeout(() => effect.remove(), 400);
                }

                // --- 2. AOE å‚·å®³èˆ‡ Popup ---
                const tx = target.x;
                const ty = target.y;

                // è¦–è¦ºï¼šåŠ å…¥ä¸€å€‹æŒçºŒæ“´æ•£çš„åœ“åœˆç‰¹æ•ˆ
                visualEffects.push({
                    type: 'explosion',
                    x: tx, y: ty,
                    radius: 80,
                    color: 'rgba(251, 146, 60, 0.6)',
                    life: 20, maxLife: 20
                });

                enemies.forEach(e => {
                    const dx = Math.abs(e.x - tx);

                    const dy = Math.abs(e.y - ty);
                    // ç¯„åœåˆ¤æ–·
                    if (e.hp > 0 && dx < 65 && dy < 65) {
                        e.hp -= damage;
                        e.virtualHp = e.hp;

                        // --- æ–°å¢ï¼šæ¯ä¸€éš»è¢«æ‰“åˆ°çš„æ€ªéƒ½è·³ Popup ---
                        // é™åˆ¶ä¸€ä¸‹æ•¸é‡ä¸Šé™é¿å…ç•«é¢å¤ªäº‚ (é€™è£¡è¨­ç‚º 15)
                        if (damagePopups.length < 15) {
                            damagePopups.push({
                                x: e.x + (Math.random() * 20 - 10), // ç¨å¾®åç§»è®“æ•¸å­—ä¸é‡ç–Š
                                y: e.y + (Math.random() * 20 - 10),
                                val: Math.floor(damage),
                                life: 20,
                                color: "#ffaa00" // å¤ªé™½å‚·å®³ç”¨äº®æ©˜è‰²
                            });
                        }
                    }
                });
                return;
            }

            if (dice.id === 'laser') {
                // é›·å°„æ˜¯å³æ™‚å‚·å®³ï¼Œä¸ç”¢å­å½ˆï¼Œç›´æ¥ç•«ç·š + æ‰£è¡€
                // å¦‚æœåŸæœ¬é‚è¼¯æ˜¯ç”¢ bulletï¼Œæˆ‘å€‘å¯ä»¥æ”¹æˆï¼š
                // 1. ç”¢ç”Ÿä¸€å€‹é›·å°„ç‰¹æ•ˆ
                visualEffects.push({
                    type: 'laser',
                    start: { x: startX, y: startY },
                    end: { x: target.x, y: target.y },
                    color: '#ec4899', // Pink
                    life: 5, maxLife: 5
                });
                // 2. ç‚ºäº†ç›¸å®¹åŸæœ¬çš„ applyHitEffect é‚è¼¯ (æ‰£è¡€ã€ç‰¹æ•ˆ)ï¼Œæˆ‘å€‘ç›´æ¥å‘¼å« applyHitEffect
                // ä½† applyHitEffect éœ€è¦ä¸€å€‹ projectile ç‰©ä»¶
                applyHitEffect({
                    target: target,
                    damage: damage,
                    diceId: dice.id,
                    diceUid: `slot_${dice.tempSlotIdx}`,
                    // æ¨¡æ“¬ä½ç½®
                    x: target.x, y: target.y
                });
                return;
            }

            // --- å½—æ˜Ÿæšˆçœ©æ•ˆæœ ---
            if (dice.id === 'comet' && dice.tempIsCometCharged) {
                // é€ æˆæšˆçœ©
                const originalSpeed = target.speed;
                target.speed = 0;
                setTimeout(() => {
                    if (target && target.speed === 0) target.speed = originalSpeed;
                }, 1000);

                // å½—æ˜Ÿçˆ†ç™¼ç‰¹æ•ˆ
                visualEffects.push({
                    type: 'explosion',
                    x: target.x, y: target.y,
                    radius: 80,
                    color: 'rgba(59, 130, 246, 0.8)', // è—è‰²
                    life: 25, maxLife: 25
                });
            }

            // --- é€£é–å½ˆå°„æ©Ÿåˆ¶ ---
            if (dice.id === 'chain') {
                // 1. ä¸»ç›®æ¨™å‚·å®³ï¼ˆæ­£å¸¸å­å½ˆï¼‰
                if (target.virtualHp === undefined) target.virtualHp = target.hp;
                target.virtualHp -= damage;

                projectiles.push({
                    x: startX,
                    y: startY,
                    target: target,
                    damage: damage,
                    diceId: dice.id,
                    diceUid: `slot_${dice.tempSlotIdx}`,
                    color: dice.color || "#8b5cf6",
                    speed: 12,
                    isChainPrimary: true
                });

                // 2. å°‹æ‰¾å½ˆå°„ç›®æ¨™
                const chainDb = ALL_DICES.find(d => d.id === 'chain');
                const pLv = userData.diceLevels['chain'] || 1;
                const boostPercent = (chainDb.special.value + (pLv - 1) * chainDb.special.grow) / 100;

                let currentTarget = target;
                let currentDamage = damage;
                const bouncedTargets = [target];

                for (let i = 0; i < 2; i++) {
                    // æ‰¾æœ€è¿‘çš„æœªå½ˆå°„æ•µäºº
                    const nextTarget = enemies
                        .filter(e => e.hp > 0 && !bouncedTargets.includes(e))
                        .sort((a, b) => {
                            const distA = Math.hypot(a.x - currentTarget.x, a.y - currentTarget.y);
                            const distB = Math.hypot(b.x - currentTarget.x, b.y - currentTarget.y);
                            return distA - distB;
                        })[0];

                    if (!nextTarget) break;

                    currentDamage *= (1 + boostPercent); // éå¢å‚·å®³
                    if (nextTarget.virtualHp === undefined) nextTarget.virtualHp = nextTarget.hp;
                    nextTarget.virtualHp -= currentDamage;

                    projectiles.push({
                        x: currentTarget.x,
                        y: currentTarget.y,
                        target: nextTarget,
                        damage: currentDamage,
                        diceId: dice.id,
                        diceUid: `slot_${dice.tempSlotIdx}_chain${i + 1}`,
                        color: "#a78bfa", // å½ˆå°„ç”¨æ›´äº®çš„ç´«è‰²
                        speed: 15,
                        isChainBounce: true
                    });

                    bouncedTargets.push(nextTarget);
                    currentTarget = nextTarget;
                }
                return; // é€£é–è™•ç†å®Œç•¢ï¼Œä¸åŸ·è¡Œä¸‹é¢çš„æ™®é€šå­å½ˆ
            }

            // --- å…¶ä»–å­å½ˆé¡æ”»æ“Š (ä¿æŒåŸæ¨£) ---
            if (target.virtualHp === undefined) target.virtualHp = target.hp;
            target.virtualHp -= damage;

            projectiles.push({
                x: startX,
                y: startY,
                target: target,
                damage: damage,
                diceId: dice.id,
                // å¾éª°å­ç‰©ä»¶è£¡æŠŠå‰›æ‰å¡é€²å»çš„ç´¢å¼•æ‹¿å‡ºä¾†ç•¶ UID
                diceUid: `slot_${dice.tempSlotIdx}`,
                color: dice.color || "#ffffff",
                speed: 12
            });
        }
        // ã€æ’æ“Šç«¯ã€‘è™•ç†ï¼šå–®é«”å‚·å®³ã€åŠŸèƒ½æ€§æ•ˆæœ (æ¸›é€Ÿã€ä¸­æ¯’ã€å‚³é€ã€é€£é–)
        // ã€æ’æ“Šç«¯ã€‘è™•ç†ï¼šå–®é«”å‚·å®³ã€åŠŸèƒ½æ€§æ•ˆæœ
        function applyHitEffect(p) {
            const target = p.target;
            if (!target || target.hp <= 0) return;

            if (target.vulnerability) {
                // å¦‚æœæ€ªç¸èº«ä¸Šæœ‰æ˜“å‚·æ¨™è¨˜ï¼Œå‚·å®³ä¹˜ä»¥åŠ æˆç™¾åˆ†æ¯”
                p.damage *= (1 + target.vulnerability / 100);
            }
            // --- æ–°å¢ï¼šè§¸ç™¼æ‰“æ“ŠéŸ³æ•ˆ ---
            // é€™è£¡å‘¼å«æˆ‘å€‘ä¹‹å‰å¯«å¥½çš„å°ˆæ¥­ Web Audio API æ’­æ”¾å™¨
            if (typeof AudioManager !== 'undefined' && AudioManager.playHit) {
                AudioManager.playHit();
            }

            // 1. åŸºç¤å‚·å®³
            target.hp -= p.damage;
            if (damagePopups.length < 20) {
                damagePopups.push({
                    x: target.x,
                    y: target.y,
                    val: Math.floor(p.damage),
                    life: 30,
                    color: target.vulnerability ? "#f87171" : "#ffffff"
                });
            }

            // 2. åŸ·è¡ŒåŠŸèƒ½æ€§æ•ˆæœ
            const spec = getDiceSpecialValue(p.diceId);
            switch (p.diceId) {
                case 'crack': // æ˜“å‚·éª°å­æ’æ“Šæ™‚ï¼Œçµ¦æ€ªç‰©æ›ä¸Šæ¨™è¨˜
                    // å–ç•¶å‰éª°å­ç­‰ç´šå°æ‡‰çš„æ˜“å‚·ç™¾åˆ†æ¯”
                    // å¦‚æœæ€ªç‰©å·²æœ‰æ˜“å‚·ï¼Œå‰‡å–æœ€é«˜å€¼è€Œä¸å †ç–Š (å¹³è¡¡è€ƒé‡)
                    target.vulnerability = Math.max(target.vulnerability || 0, spec);
                    break;
                case 'ice':
                    target.speed = Math.max(0.3, 1.5 * (1 - spec / 100));
                    clearTimeout(target.iceTimer);
                    target.iceTimer = setTimeout(() => { target.speed = 1.5; }, 1000);
                    break;
                case 'lock':
                    if (Math.random() < 0.2) {
                        target.speed = 0;
                        setTimeout(() => { target.speed = 1.5; }, spec * 1000);
                    }
                    break;
                case 'electric':
                    // é›»åŠ›é€£é– (æ’æ“Šæ‰è·³é›»ï¼Œè¦–è¦ºæ¯”è¼ƒè‡ªç„¶)
                    enemies.forEach(e => {
                        if (e !== target && e.hp > 0 && Math.hypot(e.x - target.x, e.y - target.y) < 100) {
                            let chainDmg = p.damage * 0.5;
                            e.hp -= chainDmg;
                            e.virtualHp -= chainDmg;

                            // --- æ–°å¢ï¼šé›»æ“Šé€£ç·šç‰¹æ•ˆ ---
                            visualEffects.push({
                                type: 'lightning',
                                start: { x: target.x, y: target.y },
                                end: { x: e.x, y: e.y },
                                life: 10, maxLife: 10
                            });

                            if (damagePopups.length < 10) {
                                damagePopups.push({ x: e.x, y: e.y, val: Math.floor(chainDmg), life: 20, color: "#fde047" });
                            }
                            // å¦‚æœé›»åŠ›é€£é–ä¹Ÿæƒ³è¦æœ‰è²éŸ³ï¼Œå¯ä»¥åœ¨é€™è£¡ä¹ŸåŠ ä¸€å€‹æ¥µå°è²çš„ playHit
                        }
                    });
                    break;
                case 'poison':
                    target.poisonStacks = (target.poisonStacks || 0) + 1;
                    break;
                case 'teleport':
                    const teleportChance = spec / 100; // ä½¿ç”¨èˆ‡å°æ€ªç›¸åŒçš„æ©Ÿç‡
                    if (Math.random() < teleportChance) {
                        if (target.isBoss) {
                            // Bossï¼šçœ©æšˆ 1 ç§’ï¼ˆé–å®šç§»å‹•ï¼‰
                            const originalSpeed = target.speed;
                            target.speed = 0;
                            setTimeout(() => {
                                target.speed = originalSpeed;
                            }, 1000);
                        } else {
                            // å°æ€ªï¼šå‚³é€å›èµ·é»
                            target.x = path[0].x;
                            target.y = path[0].y;
                            target.pathIndex = 1;
                        }
                        // è¦–è¦ºç‰¹æ•ˆï¼šå‚³é€è§¸ç™¼
                        visualEffects.push({
                            type: 'explosion',
                            x: target.x, y: target.y,
                            radius: 40,
                            color: '#8b5cf6', // Purple
                            life: 15, maxLife: 15
                        });
                    }
                    break;
                // åœ¨ applyHitEffect switch å…§
                case 'laser':
                    // å¦‚æœæ€ªç‰©æ²’è®Šï¼Œç–ŠåŠ å¢å‚·
                    if (target.lastHitId === p.diceUid) {
                        target.laserStack = Math.min((target.laserStack || 1) + 1, spec);
                    } else {
                        target.laserStack = 1;
                        target.lastHitId = p.diceUid;
                    }
                    p.damage *= target.laserStack;
                    break;
                case 'galaxy':
                    // ç”¢ç”Ÿä¸€å€‹å°å‹é»‘æ´æ•ˆæœ
                    const pullRange = 100; // å¸å¼•åŠå¾‘


                    enemies.forEach(e => {
                        if (e !== target && e.hp > 0) {
                            const dx = target.x - e.x;
                            const dy = target.y - e.y;
                            const dist = Math.hypot(dx, dy);

                            if (dist < pullRange) {
                                // æ‹‰åŠ›éš¨è·é›¢éæ¸›
                                const pullStrength = (pullRange - dist) / pullRange * spec;

                                // åŸ·è¡Œä½ç§»
                                e.x += (dx / dist) * pullStrength;
                                e.y += (dy / dist) * pullStrength;

                                // ğŸ’¡ é‡è¦ï¼šå¦‚æœä½ çš„æ€ªç‰©ç§»å‹•æ˜¯é  pathIndexï¼Œ
                                // è¢«æ‹‰å‹•å¾Œçš„ e.x, e.y æœƒåœ¨ä¸‹ä¸€å¹€ updateEnemy æ™‚è‡ªå‹•ä¿®æ­£å›è»Œé“æ–¹å‘ï¼Œ
                                // é€™æœƒç”¢ç”Ÿä¸€ç¨®ã€Œæ™æ‰ã€çš„è¦–è¦ºæ„Ÿï¼Œæ•ˆæœå¾ˆå¥½ã€‚
                            }
                        }
                    });

                    // é¡å¤–å‚·å®³ï¼šæ—¢ç„¶æ˜¯ç¥è©±ç´šï¼Œè¢«å‘½ä¸­çš„ç›®æ¨™é€šå¸¸è¦æ‰£ä¸€é»æœ€å¤§ç”Ÿå‘½ % æ•¸
                    // target.hp -= target.maxHp * (spec / 100); 
                    break;

                case 'doom':
                    // æ¯€æ»…éª°å­ï¼šå»¶é²æ–¬æ®º
                    const doomDb = ALL_DICES.find(d => d.id === 'doom');
                    const doomLv = userData.diceLevels['doom'] || 1;
                    const doomPercent = (doomDb.special.value + (doomLv - 1) * doomDb.special.grow) / 100;

                    // æ¨™è¨˜ç›®æ¨™
                    target.doomMark = {
                        damage: target.maxHp * doomPercent,
                        timer: 15000, // 15ç§’
                        startTime: Date.now()
                    };

                    // è¦–è¦ºç‰¹æ•ˆï¼šæœ«æ—¥æ™‚é˜æ¨™è¨˜
                    visualEffects.push({
                        type: 'explosion',
                        x: target.x, y: target.y,
                        radius: 50,
                        color: 'rgba(124, 58, 237, 0.7)', // æ·±ç´«è‰²
                        life: 20, maxLife: 20
                    });
                    break;
            }

            // 3. çµ±ä¸€æ¸…ç†æ­»äº¡æ€ªç‰©
            for (let i = enemies.length - 1; i >= 0; i--) {
                if (enemies[i].hp <= 0) {
                    battleState.sp += enemies[i].rewardSp || 10;
                    enemies.splice(i, 1);
                }
            }
        }
        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                let e = enemies[i];

                // --- 1. è™•ç†ä¸­æ¯’æŒçºŒå‚·å®³ ---
                if (e.poisonStacks > 0) {
                    // æ¯ç§’é€ æˆ (å±¤æ•¸ * åŸºç¤å‚·å®³)
                    // åŸºç¤æ¯’å‚·è¨­ç‚º 2ï¼Œä½ å¯ä»¥æ ¹æ“š db.stats èª¿æ•´æ›´ç²¾ç¢ºçš„æ•¸å€¼
                    const poisonDmgPerFrame = (e.poisonStacks * 2) / 60;
                    e.hp -= poisonDmgPerFrame;

                    // æ¯ç§’ (60å¹€) é¡¯ç¤ºä¸€æ¬¡ç´«è‰²æ¯’å‚·æ•¸å­—
                    if (frameCount % 60 === 0) {
                        damagePopups.push({
                            x: e.x,
                            y: e.y - 15,
                            val: Math.floor(e.poisonStacks * 2),
                            color: "#a855f7", // ç´«è‰²ä»£è¡¨æ¯’ç´ 
                            life: 30
                        });
                    }
                }

                // --- 2. Boss æŠ€èƒ½é‚è¼¯ ---
                if (e.isBoss) {
                    if (!e.skillTimer) e.skillTimer = 0; // ç¢ºä¿ timer å­˜åœ¨
                    e.skillTimer++;
                    if (e.skillTimer >= BOSS_TYPES[e.bossType].skillInterval) {
                        BOSS_TYPES[e.bossType].onSkill(e);
                        e.skillTimer = 0;
                    }
                }

                // --- 2.5. æ¯€æ»…æ¨™è¨˜å€’æ•¸æª¢æŸ¥ ---
                if (e.doomMark) {
                    const elapsed = Date.now() - e.doomMark.startTime;
                    if (elapsed >= e.doomMark.timer) {
                        // æ™‚é–“åˆ°ï¼ŒåŸ·è¡Œæ–¬æ®º
                        e.hp -= e.doomMark.damage;

                        // é¡¯ç¤ºæ–¬æ®ºå‚·å®³
                        if (damagePopups.length < 10) {
                            damagePopups.push({
                                x: e.x,
                                y: e.y,
                                val: Math.floor(e.doomMark.damage),
                                life: 40,
                                color: "#7c3aed" // æ·±ç´«è‰²
                            });
                        }

                        // æ–¬æ®ºç‰¹æ•ˆ
                        visualEffects.push({
                            type: 'explosion',
                            x: e.x, y: e.y,
                            radius: 100,
                            color: 'rgba(124, 58, 237, 0.9)',
                            life: 30, maxLife: 30
                        });

                        delete e.doomMark; // ç§»é™¤æ¨™è¨˜
                    }
                }

                // --- 3. ç§»å‹•é‚è¼¯ ---
                let target = path[e.pathIndex];
                let dx = target.x - e.x, dy = target.y - e.y, dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < e.speed) {
                    e.pathIndex++;
                    if (e.pathIndex >= path.length) {
                        battleState.hp--;
                        enemies.splice(i, 1);
                        updateUI();

                        // æˆ°æ•—åˆ¤æ–·
                        if (battleState.hp <= 0) {
                            handleGameOver(false); // å»ºè­°æ”¹ç”¨ function è™•ç†çµç®—ï¼Œè€Œä¸æ˜¯ç›´æ¥ reload
                            return;
                        }
                    }
                } else {
                    e.x += (dx / dist) * e.speed;
                    e.y += (dy / dist) * e.speed;
                }

                // --- 4. æª¢æŸ¥ä¸­æ¯’æˆ– DOT å°è‡´çš„æ­»äº¡ ---
                if (e.hp <= 0) {
                    battleState.sp += e.rewardSp || 10;
                    enemies.splice(i, 1);
                    updateUI();
                }
                if (battleState.wave > 20 && enemies.length === 0) {
                    handleGameOver(true); // å‚³å…¥ true ä»£è¡¨ã€Œå®Œå…¨é€šé—œã€
                    return;
                }
            }
        }
        function updateWave() {
            if (!waveState.isWaiting) {
                waveState.timer++;

                // --- æ–°å¢ï¼šå‹•æ…‹è¨ˆç®—ç”Ÿæ€ªé€Ÿåº¦ ---
                // æ¯é 1 å±¤æ¸›å°‘ 1 å¹€é–“éš”ï¼Œæœ€å¿«ç¶­æŒåœ¨ 10 å¹€ç”Ÿä¸€éš» (å¯è‡ªè¡Œèª¿æ•´)
                let currentSpawnInterval = Math.max(10, 30 - Math.floor(battleState.wave) / 2);

                if (waveState.timer >= currentSpawnInterval) {
                    if (battleState.wave % 10 === 0 && waveState.spawnedCount === 0) {
                        spawnBoss();
                        waveState.spawnedCount = waveState.totalEnemiesPerWave;
                    }
                    else if (waveState.spawnedCount < waveState.totalEnemiesPerWave) {
                        spawnEnemy();
                        waveState.spawnedCount++;
                        waveState.timer = 0;
                    }
                    else if (enemies.length === 0) {
                        waveState.isWaiting = true;
                        waveState.timer = 0;
                    }
                }
            } else {
                waveState.timer++;
                // é€™è£¡ç¶­æŒ 60 å¹€ (ç´„ 1 ç§’) çš„éå ´ç­‰å¾…ï¼Œè®“ç©å®¶æœ‰æ™‚é–“å–˜å£æ°£åˆæˆéª°å­
                if (waveState.timer >= 60) {
                    if (battleState.wave >= 20) {
                        handleGameOver(true);
                        return;
                    }
                    battleState.wave++;
                    waveState.spawnedCount = 0;
                    waveState.totalEnemiesPerWave += 1;
                    waveState.isWaiting = false;
                    waveState.timer = 0;
                    updateUI();
                }
            }
        }

        // å°ˆé–€è™•ç†æ¯å¹€éƒ½è¦å³æ™‚è®Šå‹•çš„æ•¸å­—
        function updateLiveStats() {
            const spEl = document.getElementById('spText');
            const costEl = document.getElementById('summonCostText');
            const hpEl = document.getElementById('hpText');
            const waveEl = document.getElementById('waveText');

            if (spEl) spEl.innerText = Math.floor(battleState.sp);
            if (costEl) costEl.innerText = battleState.summonCost;
            if (hpEl) hpEl.innerText = battleState.hp;
            if (waveEl) waveEl.innerText = battleState.wave;

            // (é¸åš) é€™è£¡é‚„å¯ä»¥å³æ™‚æª¢æŸ¥æŒ‰éˆ•æ˜¯å¦è©²è®Šäº®/è®Šæš—ï¼Œè€Œä¸é‡æ–°ç¹ªè£½æŒ‰éˆ•
        }

        // åªæœ‰åœ¨ã€Œå¼·åŒ–ç­‰ç´šæ”¹è®Šã€æˆ–ã€Œå¬å–šéª°å­ã€æ™‚æ‰å‘¼å«é€™å€‹
        function updateUI() {
            // å…ˆåŒæ­¥ä¸€æ¬¡æ•¸å­—
            updateLiveStats();

            const container = document.getElementById('powerUpButtons');
            if (!container) return;

            // 1. ç”¢ç”Ÿå¼·åŒ–æŒ‰éˆ•çš„ HTML
            container.innerHTML = userData.deck.map((id) => {
                const dice = ALL_DICES.find(d => d.id === id);
                const lv = powerUpLevels[id] || 1;
                const cost = 100 * Math.pow(2, lv - 1);
                const q = QUALITIES[dice.quality] || QUALITIES.common;

                // --- æ–°å¢åˆ¤æ–·é‚è¼¯ ---
                const isMax = lv >= 5;
                // æ»¿ç­‰é¡¯ç¤º MAXï¼Œå¦å‰‡é¡¯ç¤ºæ•¸å€¼ + SP
                const costDisplay = isMax ? "MAX" : `${cost >= 1000 ? (cost / 1000).toFixed(1) + 'k' : cost} SP`;
                // é¡è‰²èˆ‡é‚Šæ¡†å‹•æ…‹åˆ‡æ›
                const costColor = isMax ? "text-orange-500" : "text-slate-400";
                const borderColor = isMax ? "border-yellow-500 shadow-[0_0_5px_rgba(234,179,8,0.3)]" :
                    (battleState.sp >= cost ? 'border-blue-500' : 'border-slate-700');

                return `
        <button onclick="${isMax ? '' : `powerUpDice('${id}')`}" 
            class="flex-1 min-w-0 bg-slate-800 border ${borderColor} rounded-lg py-1.5 flex flex-col items-center ${isMax ? '' : 'active:scale-95'} transition-all">
            <div class="w-8 h-8 rounded bg-white relative mb-1 overflow-hidden" style="border: 1px solid ${q.color}">
                <canvas id="pwr-canvas-${id}" width="32" height="32" class="absolute inset-0 pointer-events-none"></canvas>
            </div>
            <div class="text-[9px] text-yellow-500 font-bold leading-none">Lv.${lv}</div>
            <div class="text-[8px] ${costColor} mt-1 font-bold tracking-tighter">${costDisplay}</div>
        </button>`;
            }).join('');

            // 2. ç¹ªè£½æŒ‰éˆ•ä¸Šçš„éª°å­åœ–æ¡ˆ (ç¶­æŒåŸæœ‰çš„ç•°æ­¥ç¹ªè£½é‚è¼¯)
            setTimeout(() => {
                userData.deck.forEach(id => {
                    const dice = ALL_DICES.find(d => d.id === id);
                    const canvas = document.getElementById(`pwr-canvas-${id}`);
                    if (canvas && dice) {
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        drawDiceFeature(ctx, 0, 0, canvas.width, dice.pattern || dice.id, dice.baseColor);
                        drawDiceStars(ctx, 0, 0, canvas.width, 1, dice.baseColor, dice.id);
                    }
                });
            }, 0);
        }
        let bgOffset = 0; // ç”¨æ–¼æ§åˆ¶ç¶²æ ¼ç§»å‹•çš„åç§»é‡

        function drawDynamicBackground(ctx, width, height) {
            // 1. ç¹ªè£½å‹•æ…‹ç¶²æ ¼
            bgOffset += 0.2; // æ§åˆ¶ç¶²æ ¼ç§»å‹•é€Ÿåº¦
            if (bgOffset > 40) bgOffset = 0;

            ctx.strokeStyle = 'rgba(56, 189, 248, 0.1)'; // æ·¡æ·¡çš„ç§‘æŠ€è—
            ctx.lineWidth = 1;
            const gridSize = 40;

            // å‚ç›´ç·š
            for (let x = (bgOffset % gridSize); x < width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }
            // æ°´å¹³ç·š
            for (let y = (bgOffset % gridSize); y < height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // 2. ç¹ªè£½å››å€‹è§’è½çš„è£é£¾æ€§å…‰æšˆ (ä¸éš¨ç¶²æ ¼ç§»å‹•)
            const time = Date.now() * 0.001;
            const pulse = Math.sin(time) * 10; // å‘¼å¸ç‡ˆæ•ˆæœ

            ctx.fillStyle = 'rgba(56, 189, 248, 0.05)';
            // å·¦ä¸Šè§’
            ctx.beginPath();
            ctx.arc(0, 0, 150 + pulse, 0, Math.PI * 2);
            ctx.fill();
            // å³ä¸‹è§’
            ctx.beginPath();
            ctx.arc(width, height, 200 + pulse, 0, Math.PI * 2);
            ctx.fill();
        }
        function refreshSunState() {
            const totalSunCount = grid.slots.filter(s => s.dice && s.dice.id === 'sun').length;
            isSunActivated = [1, 4, 7].includes(totalSunCount);
        }
        function startRenderLoop() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');

            function frame() {
                // 1. å¦‚æœéŠæˆ²æ²’é–‹å§‹æˆ–å·²çµæŸï¼Œåœæ­¢å¾ªç’°
                if (!battleState.isStarted) return;
                const modal = document.getElementById('resultModal');
                if (modal && modal.style.display === 'flex') return;

                frameCount++;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // --- é‚è¼¯æ›´æ–° ---
                updateEnemies();
                updateWave();
                updateCombat();
                updateLiveStats();

                // --- èƒŒæ™¯èˆ‡åº•å±¤è£é£¾ ---
                drawDynamicBackground(ctx, canvas.width, canvas.height);
                // ç•« 3x5 ç§‘æŠ€æ„Ÿ L é‚Šæ¡†èˆ‡å‡¹æ§½
                drawEnhancedGridBase(ctx, grid);
                // ç•«ç™¼å…‰è»Œé“èˆ‡å‚³é€é–€
                drawEnhancedPath(ctx, path);

                // --- ç•«å­å½ˆ ---
                projectiles.forEach(p => {
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                });

                // --- ç•«ç¬æ™‚ç‰¹æ•ˆ (é›»æ“Šã€çˆ†ç‚¸) ---
                drawVisualEffects(ctx);

                // --- ç•«æ•µäºº (å« Boss PNG é‚è¼¯) ---
                enemies.forEach(e => {
                    const s = e.isBoss ? e.size : 20;

                    if (e.isBoss && e.bossType && BOSS_TYPES[e.bossType]) {
                        ctx.save();
                        // å¹« Boss PNG åŠ ä¸€é»ç¬¦åˆå±¬æ€§çš„å¤–ç™¼å…‰
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = e.color || BOSS_TYPES[e.bossType].color;

                        const bossImg = BOSS_TYPES[e.bossType].img;
                        // ç¢ºä¿åœ–ç‰‡å·²è¼‰å…¥å®Œæˆæ‰ç¹ªè£½ï¼Œå¦å‰‡ç•«è‰²å¡Šå¢Šåº•
                        if (bossImg && bossImg.complete && bossImg.naturalWidth !== 0) {
                            ctx.drawImage(bossImg, e.x - s / 2, e.y - s / 2, s, s);
                        } else {
                            ctx.fillStyle = e.color || "#ef4444";
                            ctx.fillRect(e.x - s / 2, e.y - s / 2, s, s);
                        }
                        ctx.restore();
                    } else {
                        // ä¸€èˆ¬å°æ€ªç¶­æŒåŸæ¨£ (ç´…è‰²æ–¹å¡Š)
                        ctx.fillStyle = "#ef4444";
                        ctx.fillRect(e.x - s / 2, e.y - s / 2, s, s);
                    }

                    // è¡€æ¢é‚è¼¯ (å±…ä¸­æ–¼æ•µäººä¸Šæ–¹)
                    ctx.fillStyle = "rgba(0,0,0,0.5)";
                    ctx.fillRect(e.x - 15, e.y - (s / 2 + 8), 30, 3);
                    ctx.fillStyle = "#22c55e";
                    ctx.fillRect(e.x - 15, e.y - (s / 2 + 8), (e.hp / e.maxHp) * 30, 3);

                    // --- æ–°å¢ï¼šç‹€æ…‹åœ–ç¤º (å†°å‡ã€é–å®šã€æ¯’ã€æ˜“å‚·) ---
                    let iconOffset = 0;
                    if (e.iceTimer > 0) {
                        drawStatusIcon(ctx, e.x - 10 + iconOffset, e.y - s / 2 - 20, 'â„ï¸');
                        iconOffset += 15;
                    }
                    if (e.lockTimer > 0) { // å‡è¨­é–å®šä¹Ÿæœ‰ Timer
                        // e.lockTimer might not be defined in updateEnemies loop but applyHitEffect sets speed directly or sets timer? 
                        // Check boss skill logic: `target.isLocked = true` with timeout. For mobs `target.speed=0`.
                        // Let's assume if speed is 0 and hp > 0, it's locked.
                        if (e.speed === 0) {
                            drawStatusIcon(ctx, e.x - 10 + iconOffset, e.y - s / 2 - 20, 'ğŸ”’');
                            iconOffset += 15;
                        }
                    }
                    if (e.poisonStacks > 0) {
                        drawStatusIcon(ctx, e.x - 10 + iconOffset, e.y - s / 2 - 20, 'â˜ ï¸');
                        iconOffset += 15;
                    }
                    if (e.vulnerability) {
                        drawStatusIcon(ctx, e.x - 10 + iconOffset, e.y - s / 2 - 20, 'ğŸ’”');
                    }
                });

                // --- ç•«å‚·å®³å­—é«” (ç¢ºä¿åœ¨æ•µäººä¹‹ä¸Š) ---
                for (let i = damagePopups.length - 1; i >= 0; i--) {
                    let d = damagePopups[i];
                    ctx.save();
                    ctx.fillStyle = `rgba(255, 255, 255, ${d.life / 30})`;
                    ctx.font = "bold 14px Arial";
                    ctx.textAlign = "center";
                    ctx.fillText(d.val, d.x, d.y);
                    ctx.restore();

                    // å‚·å®³å‹•ç•«ï¼šå‘ä¸Šé£„ç§»èˆ‡ç”Ÿå‘½é€±æœŸéæ¸›
                    d.y -= 1;
                    d.life--;
                    if (d.life <= 0) damagePopups.splice(i, 1);
                }

                // --- ç•«éª°å­ (åŸæœ¬é‚è¼¯) ---
                grid.slots.forEach(slot => {
                    if (slot.dice && !slot.isBeingDragged) {
                        // å¤ªé™½/é½’è¼ªç‰¹æ•ˆ
                        if (slot.dice.id === 'sun' && isSunActivated) {
                            ctx.save();
                            ctx.beginPath();
                            ctx.setLineDash([5, 5]);
                            ctx.strokeStyle = "orange";
                            ctx.lineWidth = 3;
                            ctx.strokeRect(slot.x + 4, slot.y + 4, grid.slotSize - 8, grid.slotSize - 8);
                            ctx.restore();
                        }
                        if (slot.dice.id === 'gear' && slot.dice.isPowered) {
                            drawEffect(slot, "#00ccff");

                            // --- æ–°å¢ï¼šé½’è¼ªé€£ç·šç‰¹æ•ˆ ---
                            drawGearConnections(ctx, slot);
                        }
                        // ç¹ªè£½éª°å­ä¸»é«”èˆ‡æ˜Ÿæ•¸
                        renderDice(ctx, slot.x, slot.y, slot.dice, slot.isLocked);
                    }
                });

                // --- ç•«æ­£åœ¨æ‹–æ‹½ä¸­çš„éª°å­ (æœ€é ‚å±¤) ---
                if (drag.isDragging) {
                    renderDice(ctx, drag.currentX - grid.slotSize / 2, drag.currentY - grid.slotSize / 2, drag.dice, false);
                }

                requestAnimationFrame(frame);
            }

            // å•Ÿå‹•å¾ªç’°
            frame();
        }

        // ---ç§»æ¤è‡ª dice_cooper.html çš„å‚³é€é–€ç¹ªè£½å‡½å¼---
        function drawPortal(ctx, x, y, color, angle, isStart) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);

            // å¤–åœˆå…‰ç’°
            const gradient = ctx.createRadialGradient(0, 0, 10, 0, 0, 30);
            gradient.addColorStop(0, color);
            gradient.addColorStop(1, 'rgba(0,0,0,0)');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, 30, 0, Math.PI * 2);
            ctx.fill();

            // æ—‹è½‰ç´‹è·¯
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            for (let i = 0; i < 4; i++) {
                ctx.rotate(Math.PI / 2);
                ctx.beginPath();
                ctx.moveTo(10, 0);
                ctx.quadraticCurveTo(20, 10, 25, 0);
                ctx.stroke();
            }

            // ä¸­å¿ƒé»‘æ´/äº®é»
            ctx.fillStyle = isStart ? '#000' : '#fff';
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // --- æ–°å¢ï¼šç¹ªè£½å„ç¨®ç¬æ™‚è¦–è¦ºç‰¹æ•ˆ ---
        function drawVisualEffects(ctx) {
            for (let i = visualEffects.length - 1; i >= 0; i--) {
                const fx = visualEffects[i];
                fx.life--;
                if (fx.life <= 0) {
                    visualEffects.splice(i, 1);
                    continue;
                }

                ctx.save();
                if (fx.type === 'lightning') {
                    // é–ƒé›»ï¼šç•«å¤šæ®µæŠ˜ç·š
                    ctx.strokeStyle = '#fde047'; // é»ƒè‰²
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 5;
                    ctx.shadowColor = '#fde047';
                    ctx.beginPath();
                    ctx.moveTo(fx.start.x, fx.start.y);

                    const steps = 5;
                    const dx = (fx.end.x - fx.start.x) / steps;
                    const dy = (fx.end.y - fx.start.y) / steps;

                    for (let j = 1; j < steps; j++) {
                        const offset = (Math.random() - 0.5) * 20; // åç§»é‡
                        ctx.lineTo(
                            fx.start.x + dx * j + (Math.random() - 0.5) * 10,
                            fx.start.y + dy * j + (Math.random() - 0.5) * 10
                        );
                    }
                    ctx.lineTo(fx.end.x, fx.end.y);
                    ctx.stroke();
                }
                else if (fx.type === 'explosion') {
                    // çˆ†ç‚¸ï¼šæ“´æ•£åœ“åœˆ
                    const progress = 1 - (fx.life / fx.maxLife); // 0 -> 1
                    ctx.beginPath();
                    ctx.arc(fx.x, fx.y, fx.radius * progress, 0, Math.PI * 2);
                    ctx.fillStyle = fx.color || 'orange';
                    ctx.globalAlpha = 1 - progress;
                    ctx.fill();

                    // è¡æ“Šæ³¢é‚Šæ¡†
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                else if (fx.type === 'laser') {
                    // é›·å°„ï¼šç›´ç·šå…‰æŸ
                    ctx.beginPath();
                    ctx.moveTo(fx.start.x, fx.start.y);
                    ctx.lineTo(fx.end.x, fx.end.y);
                    ctx.strokeStyle = fx.color || '#ff0000';
                    ctx.lineWidth = 3 + Math.sin(Date.now() / 50) * 1; // è„ˆè¡å¯¬åº¦
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = fx.color || '#ff0000';
                    ctx.lineCap = 'round';
                    ctx.stroke();

                    // æ“Šä¸­é»å…‰æšˆ
                    ctx.beginPath();
                    ctx.arc(fx.end.x, fx.end.y, 6, 0, Math.PI * 2);
                    ctx.fillStyle = '#fff';
                    ctx.fill();
                }
                ctx.restore();
            }
        }

        // --- æ–°å¢ï¼šç¹ªè£½ç‹€æ…‹å°åœ–ç¤º ---
        function drawStatusIcon(ctx, x, y, text) {
            ctx.save();
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#000';
            ctx.shadowBlur = 2;
            ctx.fillStyle = '#fff';
            ctx.fillText(text, x, y);
            ctx.restore();
        }

        // --- æ–°å¢ï¼šç¹ªè£½é½’è¼ªé€£ç·š ---
        function drawGearConnections(ctx, slot) {
            // åªç•«å‘å³å’Œå‘ä¸‹çš„é€£ç·šï¼Œé¿å…é‡è¤‡ç¹ªè£½
            const idx = grid.slots.indexOf(slot);
            if (idx === -1) return;

            const col = idx % grid.cols;
            const row = Math.floor(idx / grid.cols);

            // å³é‚Šé„°å±…
            if (col < grid.cols - 1) {
                const rightSlot = grid.slots[idx + 1];
                if (rightSlot.dice && rightSlot.dice.id === 'gear') {
                    drawGearLine(ctx, slot, rightSlot);
                }
            }
            // ä¸‹æ–¹é„°å±…
            if (row < grid.rows - 1) {
                const downSlot = grid.slots[idx + grid.cols];
                if (downSlot.dice && downSlot.dice.id === 'gear') {
                    drawGearLine(ctx, slot, downSlot);
                }
            }
        }

        function drawGearLine(ctx, a, b) {
            ctx.save();
            ctx.strokeStyle = '#94a3b8'; // éµç°è‰²
            ctx.lineWidth = 6;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(a.x + grid.slotSize / 2, a.y + grid.slotSize / 2);
            ctx.lineTo(b.x + grid.slotSize / 2, b.y + grid.slotSize / 2);
            ctx.stroke();

            // äº®èŠ¯
            ctx.strokeStyle = '#e2e8f0';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();
        }

        // A. ç¹ªè£½ç™¼å…‰è»Œé“èˆ‡èµ·çµ‚é»
        function drawEnhancedPath(ctx, path) {
            if (!path || path.length < 2) return;

            ctx.save();
            // 1. ç™¼å…‰åº•å±¤
            ctx.beginPath();
            ctx.strokeStyle = "rgba(59, 130, 246, 0.2)"; // æ·¡æ·¡è—å…‰
            ctx.lineWidth = 35;
            ctx.lineJoin = "round";
            ctx.lineCap = "round";
            ctx.moveTo(path[0].x, path[0].y);
            path.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.stroke();

            // 2. è»Œé“ä¸­å¿ƒç·š (ç§‘æŠ€æ„Ÿè™›ç·š)
            ctx.beginPath();
            ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 20]);
            ctx.moveTo(path[0].x, path[0].y);
            path.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.stroke();
            ctx.setLineDash([]);

            // 3. èµ·é»ï¼šå‚³é€é–€ (Portal) - ä½¿ç”¨æ–°æ¨£å¼
            const start = path[0];
            const angle = (Date.now() / 1000) % (Math.PI * 2);
            drawPortal(ctx, start.x, start.y, '#3b82f6', angle, true);


            // 4. çµ‚é»ï¼šæ ¸å¿ƒ (Core)
            const end = path[path.length - 1];
            const pulse = 0.5 + Math.abs(Math.sin(Date.now() / 400)) * 0.5;
            ctx.fillStyle = `rgba(239, 68, 68, ${pulse * 0.5})`;
            ctx.fillRect(end.x - 15, end.y - 15, 30, 30);
            ctx.strokeStyle = "#ef4444";
            ctx.lineWidth = 2;
            ctx.strokeRect(end.x - 15, end.y - 15, 30, 30);

            ctx.restore();
        }

        // B. ç¹ªè£½ 3x5 å€åŸŸçš„å‡¹æ§½èˆ‡å››è§’ L é‚Šæ¡†
        function drawEnhancedGridBase(ctx, grid) {
            const margin = 10;
            const left = grid.slots[0].x - margin;
            const top = grid.slots[0].y - margin;
            const right = grid.slots[grid.cols - 1].x + grid.slotSize + margin;
            const bottom = grid.slots[grid.slots.length - 1].y + grid.slotSize + margin;
            const LSize = 20;

            // 1. ç¹ªè£½å››è§’ L é‚Šæ¡†
            ctx.strokeStyle = "#3b82f6";
            ctx.lineWidth = 3;
            // å·¦ä¸Š
            ctx.beginPath(); ctx.moveTo(left, top + LSize); ctx.lineTo(left, top); ctx.lineTo(left + LSize, top); ctx.stroke();
            // å³ä¸Š
            ctx.beginPath(); ctx.moveTo(right - LSize, top); ctx.lineTo(right, top); ctx.lineTo(right, top + LSize); ctx.stroke();
            // å·¦ä¸‹
            ctx.beginPath(); ctx.moveTo(left, bottom - LSize); ctx.lineTo(left, bottom); ctx.lineTo(left + LSize, bottom); ctx.stroke();
            // å³ä¸‹
            ctx.beginPath(); ctx.moveTo(right - LSize, bottom); ctx.lineTo(right, bottom); ctx.lineTo(right, bottom - LSize); ctx.stroke();

            // 2. ç¹ªè£½æ ¼å­çš„å‡¹æ§½èƒŒæ™¯
            grid.slots.forEach(slot => {
                // æ·±è‰²èƒŒæ™¯
                ctx.fillStyle = "rgba(15, 23, 42, 0.8)";
                drawRoundedRect(ctx, slot.x + 2, slot.y + 2, grid.slotSize - 4, grid.slotSize - 4, 10);
                ctx.fill();

                // å…§é™°å½±
                ctx.strokeStyle = "rgba(0, 0, 0, 0.6)";
                ctx.lineWidth = 1;
                ctx.stroke();
            });
        }
        function drawDiceFeature(ctx, x, y, size, pattern, diceColor) {
            if (!pattern) return;

            const m = size / 2;
            ctx.save();
            ctx.translate(x, y);

            const r = parseInt(diceColor.slice(1, 3), 16);
            const g = parseInt(diceColor.slice(3, 5), 16);
            const b = parseInt(diceColor.slice(5, 7), 16);
            ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.3)`; // ç¨å¾®åŠ æ·±ä¸€é»é»ï¼Œæ›´æ˜é¡¯
            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.12)`;
            ctx.lineWidth = 4;
            ctx.lineCap = "round";
            ctx.lineJoin = "round";

            switch (pattern) {
                // --- Common ---
                case 'fire':
                    ctx.beginPath();
                    ctx.moveTo(m, size * 0.2); ctx.lineTo(size * 0.8, size * 0.8); ctx.lineTo(size * 0.2, size * 0.8);
                    ctx.closePath(); ctx.stroke(); ctx.fill();
                    break;
                case 'ice':
                    ctx.beginPath(); ctx.arc(m, m, size * 0.35, 0, Math.PI * 2);
                    ctx.moveTo(m, size * 0.1); ctx.lineTo(m, size * 0.9);
                    ctx.moveTo(size * 0.1, m); ctx.lineTo(size * 0.9, m);
                    ctx.stroke();
                    break;
                case 'wind':
                    ctx.beginPath();
                    for (let i = -1; i <= 1; i++) {
                        ctx.moveTo(size * 0.2, m + (i * 12)); ctx.lineTo(size * 0.8, m + (i * 12));
                    }
                    ctx.stroke();
                    break;
                case 'electric':
                    ctx.beginPath();
                    ctx.moveTo(m + 5, size * 0.15); ctx.lineTo(m - 10, m + 5);
                    ctx.lineTo(m + 10, m - 5); ctx.lineTo(m - 5, size * 0.85);
                    ctx.stroke();
                    break;
                case 'poison':
                    ctx.beginPath();
                    ctx.moveTo(m, size * 0.2); ctx.lineTo(size * 0.75, m);
                    ctx.lineTo(m, size * 0.8); ctx.lineTo(size * 0.25, m);
                    ctx.closePath(); ctx.stroke(); ctx.fill();
                    break;

                // --- Rare & Epic ---
                case 'laser_beam': // é›·å°„ï¼šç§‘æŠ€æ„Ÿåå­—æº–æ˜Ÿ + è„ˆè¡å…‰ç’°
                    // 1. å¤–åœˆæ—‹è½‰å…‰ç’°
                    ctx.save();
                    ctx.translate(m, m);
                    ctx.rotate(Date.now() / 500);
                    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.4)`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.35, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();

                    // 2. ä¸­å¿ƒåå­—ç·š (æº–æ˜Ÿ)
                    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.8)`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(m - size * 0.2, m); ctx.lineTo(m + size * 0.2, m);
                    ctx.moveTo(m, m - size * 0.2); ctx.lineTo(m, m + size * 0.2);
                    ctx.stroke();

                    // 3. å››å€‹è§’è½å®šä½é»
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.6)`;
                    const corners = [
                        [size * 0.15, size * 0.15],
                        [size * 0.85, size * 0.15],
                        [size * 0.15, size * 0.85],
                        [size * 0.85, size * 0.85]
                    ];
                    corners.forEach(([cx, cy]) => {
                        ctx.beginPath();
                        ctx.arc(cx, cy, 2, 0, Math.PI * 2);
                        ctx.fill();
                    });

                    // 4. ä¸­å¿ƒç™¼å…‰é»
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.9)`;
                    ctx.beginPath();
                    ctx.arc(m, m, size * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'lock': // é–å®šï¼šæ–¹æ¡†ä¸­å¸¶ä¸€å€‹åœ“é»
                    ctx.strokeRect(size * 0.25, size * 0.25, size * 0.5, size * 0.5);
                    ctx.beginPath(); ctx.arc(m, m, 4, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'teleport': // å‚³é€ï¼šå…©å€‹æ¼©æ¸¦æ‹¬è™Ÿ
                    ctx.beginPath();
                    ctx.arc(size * 0.3, m, size * 0.3, -Math.PI / 2, Math.PI / 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(size * 0.7, m, size * 0.3, Math.PI / 2, -Math.PI / 2);
                    ctx.stroke();
                    break;
                case 'gear': // é½’è¼ªï¼šå¤–åœˆå…«å€‹é½’ï¼ˆç”¨è™›ç·šæ¨¡æ“¬ï¼‰
                    ctx.beginPath();
                    ctx.setLineDash([5, 5]);
                    ctx.arc(m, m, size * 0.35, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]); // æ¢å¾©å¯¦ç·š
                    ctx.beginPath(); ctx.arc(m, m, size * 0.15, 0, Math.PI * 2); ctx.stroke();
                    break;

                // --- Legend ---
                case 'mighty_wind': // å¼·é¢¨ï¼šå¤šé‡æ°£æµç·šæ¢
                    ctx.beginPath();
                    for (let i = -1; i <= 1; i++) {
                        ctx.moveTo(size * 0.2, m + i * size * 0.15);
                        ctx.bezierCurveTo(m, m + i * size * 0.4, m, m - i * size * 0.4, size * 0.8, m + i * size * 0.15);
                    }
                    ctx.stroke();
                    break;

                // --- è–åŸŸ (Sanctuary) å…‰ç’°åœ“åœˆ ---
                case 'sanctuary':
                    // 1. å¤–åœˆå…‰ç’°
                    ctx.beginPath();
                    ctx.arc(m, m, size * 0.35, 0, Math.PI * 2);
                    ctx.stroke();
                    // 2. ä¸­åœˆå…‰ç’°
                    ctx.beginPath();
                    ctx.arc(m, m, size * 0.25, 0, Math.PI * 2);
                    ctx.stroke();
                    // 3. ä¸­å¿ƒåå­—
                    ctx.beginPath();
                    ctx.moveTo(m - size * 0.1, m); ctx.lineTo(m + size * 0.1, m);
                    ctx.moveTo(m, m - size * 0.1); ctx.lineTo(m, m + size * 0.1);
                    ctx.stroke();
                    // 4. å››å€‹å…‰é»
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.6)`;
                    [0, 90, 180, 270].forEach(angle => {
                        const rad = angle * Math.PI / 180;
                        const px = m + Math.cos(rad) * size * 0.3;
                        const py = m + Math.sin(rad) * size * 0.3;
                        ctx.beginPath();
                        ctx.arc(px, py, size * 0.04, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    break;

                // --- å½—æ˜Ÿ (Comet) å½—æ˜Ÿæ‹–å°¾ ---
                case 'comet':
                    // 1. å½—æ˜Ÿæœ¬é«”
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.8)`;
                    ctx.beginPath();
                    ctx.arc(size * 0.65, size * 0.35, size * 0.12, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    // 2. æ‹–å°¾ï¼ˆä¸‰æ¢æµå…‰ï¼‰
                    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.5)`;
                    for (let i = -1; i <= 1; i++) {
                        ctx.beginPath();
                        ctx.moveTo(size * 0.65, size * 0.35);
                        ctx.quadraticCurveTo(
                            size * 0.4, size * 0.5 + i * size * 0.1,
                            size * 0.15, size * 0.7 + i * size * 0.15
                        );
                        ctx.stroke();
                    }
                    // 3. å°¾éƒ¨æ˜Ÿé»
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.4)`;
                    [[0.3, 0.55], [0.2, 0.65], [0.15, 0.75]].forEach(([px, py]) => {
                        ctx.beginPath();
                        ctx.arc(size * px, size * py, size * 0.03, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    break;

                // --- é€£é– (Chain) é–ƒé›»éˆ ---
                case 'chain':
                    // ä¸‰å€‹ç›®æ¨™é»
                    const chainPoints = [
                        [size * 0.2, size * 0.25],
                        [size * 0.5, size * 0.65],
                        [size * 0.8, size * 0.35]
                    ];
                    // ç¹ªè£½é–ƒé›»é€£ç·š
                    ctx.lineWidth = 2.5;
                    for (let i = 0; i < chainPoints.length - 1; i++) {
                        const [x1, y1] = chainPoints[i];
                        const [x2, y2] = chainPoints[i + 1];
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        // é‹¸é½’æ•ˆæœ
                        const segments = 3;
                        for (let s = 1; s <= segments; s++) {
                            const t = s / segments;
                            const mx = x1 + (x2 - x1) * t;
                            const my = y1 + (y2 - y1) * t;
                            const offset = (s % 2 === 0 ? 1 : -1) * size * 0.08;
                            ctx.lineTo(mx + offset, my);
                        }
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                    // ç¹ªè£½ç›®æ¨™é»
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.7)`;
                    chainPoints.forEach(([px, py]) => {
                        ctx.beginPath();
                        ctx.arc(px, py, size * 0.06, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    break;

                // --- æ¯€æ»… (Doom) æœ«æ—¥æ™‚é˜ ---
                case 'doom':
                    // 1. æ™‚é˜å¤–åœˆ
                    ctx.beginPath();
                    ctx.arc(m, m, size * 0.35, 0, Math.PI * 2);
                    ctx.stroke();
                    // 2. 12é»åˆ»åº¦
                    [0, 90, 180, 270].forEach(angle => {
                        const rad = angle * Math.PI / 180 - Math.PI / 2;
                        const x1 = m + Math.cos(rad) * size * 0.3;
                        const y1 = m + Math.sin(rad) * size * 0.3;
                        const x2 = m + Math.cos(rad) * size * 0.35;
                        const y2 = m + Math.sin(rad) * size * 0.35;
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    });
                    // 3. æŒ‡é‡ï¼ˆæŒ‡å‘12é» - æ­»äº¡è±¡å¾µï¼‰
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.9)`;
                    ctx.beginPath();
                    ctx.moveTo(m, m);
                    ctx.lineTo(m, m - size * 0.25);
                    ctx.stroke();
                    // 4. ä¸­å¿ƒé»
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.8)`;
                    ctx.beginPath();
                    ctx.arc(m, m, size * 0.06, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'joker': // å°ä¸‘ï¼šå€’ä¸‰è§’å½¢åŠ ä¸Šä¸Šæ–¹å…©é»
                    ctx.beginPath();
                    ctx.moveTo(size * 0.2, size * 0.3); ctx.lineTo(size * 0.8, size * 0.3);
                    ctx.lineTo(m, size * 0.8); ctx.closePath(); ctx.stroke();
                    ctx.beginPath(); ctx.arc(size * 0.35, size * 0.2, 3, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(size * 0.65, size * 0.2, 3, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'growth': // æˆé•·ï¼šå‘ä¸Šçš„ç®­é ­
                    ctx.beginPath();
                    ctx.moveTo(m, size * 0.15); ctx.lineTo(m, size * 0.85);
                    ctx.moveTo(m, size * 0.15); ctx.lineTo(size * 0.3, size * 0.4);
                    ctx.moveTo(m, size * 0.15); ctx.lineTo(size * 0.7, size * 0.4);
                    ctx.stroke();
                    break;
                case 'sun': // å¤ªé™½ï¼šåœ“å½¢æ”¾å°„ç‹€ (å„ªåŒ–ç‰ˆï¼šç¸®å°å°„ç·šç¯„åœï¼Œé¿é–‹æ˜Ÿæ•¸é»é»)
                    // 1. ä¸­å¿ƒåœ“ç¸®å°ä¸€é»é»
                    ctx.beginPath();
                    ctx.arc(m, m, size * 0.15, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.fill();

                    // 2. å°„ç·šèª¿æ•´ï¼šç¸®çŸ­é•·åº¦ï¼Œä¸¦å°‡ç·šæ¢è®Šç´°ï¼Œé¿å…å¹²æ“¾
                    ctx.lineWidth = 2; // å°„ç·šç”¨ç´°ç·š
                    for (let i = 0; i < 8; i++) {
                        ctx.save();
                        ctx.translate(m, m);
                        // æ—‹è½‰ 22.5 åº¦ (Math.PI / 8)ï¼Œè®“å°„ç·šéŒ¯é–‹æ­£æ–¹å½¢çš„å››è§’èˆ‡æ­£ä¸­å¿ƒ
                        ctx.rotate((i * Math.PI / 4) + (Math.PI / 8));
                        ctx.beginPath();
                        // å°„ç·šå¾ä¸­å¿ƒ 0.22 å»¶ä¼¸åˆ° 0.32ï¼Œç¢ºä¿å®ƒç•™åœ¨éª°å­ä¸­é–“å€åŸŸï¼Œä¸ç¢°åˆ°é‚Šç·£çš„æ˜Ÿé»
                        ctx.moveTo(0, -size * 0.22);
                        ctx.lineTo(0, -size * 0.32);
                        ctx.stroke();
                        ctx.restore();
                    }
                    // æ¢å¾©åŸå§‹ç·šå¯¬ä¾›å¾ŒçºŒåœ–å½¢ä½¿ç”¨
                    ctx.lineWidth = 4;
                    break;

                // --- Mythic ---
                case 'galaxy': // éŠ€æ²³ï¼šæ—‹æ¸¦ç‹€ S å‹
                    ctx.beginPath();
                    ctx.moveTo(m, size * 0.1);
                    ctx.bezierCurveTo(size * 0.9, size * 0.1, size * 0.1, size * 0.9, m, size * 0.9);
                    ctx.stroke();
                    ctx.beginPath(); ctx.arc(m, m, size * 0.1, 0, Math.PI * 2); ctx.fill();
                    break;
                // --- æ˜“å‚· (Crack) å¤–è§€ï¼šç¢è£‚æ°´æ™¶æ•ˆæœ ---
                case 'crack':
                    // 1. ä¸­å¿ƒçˆ†è£‚é»
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.5)`;
                    ctx.beginPath();
                    ctx.arc(m, m, size * 0.12, 0, Math.PI * 2);
                    ctx.fill();

                    // 2. å¤šæ–¹å‘è£‚ç´‹æ“´æ•£
                    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.7)`;
                    ctx.lineWidth = 2.5;
                    const crackAngles = [0, 45, 90, 135, 180, 225, 270, 315];
                    crackAngles.forEach(angle => {
                        const rad = angle * Math.PI / 180;
                        const x1 = m + Math.cos(rad) * size * 0.12;
                        const y1 = m + Math.sin(rad) * size * 0.12;
                        const x2 = m + Math.cos(rad) * size * 0.42;
                        const y2 = m + Math.sin(rad) * size * 0.42;

                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    });

                    // 3. å¤–åœç¢ç‰‡é»ç¶´
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.4)`;
                    [0.1, 0.25, 0.75, 0.9].forEach(ratio => {
                        ctx.beginPath();
                        ctx.arc(size * ratio, size * 0.15, 1.5, 0, Math.PI * 2);
                        ctx.arc(size * ratio, size * 0.85, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    break;

                // --- ç¤¦å±± (Mine) å¤–è§€ï¼šä¸€å€‹ T å­—å‹çš„é¬é ­ ---
                case 'mine':
                    ctx.beginPath();
                    // é¬é ­çš„å¼§å½¢é‡‘å±¬éƒ¨åˆ†
                    ctx.moveTo(size * 0.25, size * 0.35);
                    ctx.quadraticCurveTo(m, size * 0.15, size * 0.75, size * 0.35);
                    ctx.stroke();
                    // é¬é ­çš„æœ¨æŸ„
                    ctx.beginPath();
                    ctx.moveTo(m, size * 0.25);
                    ctx.lineTo(m, size * 0.75);
                    ctx.stroke();
                    // è£é£¾ä¸€å€‹å°éŒ¢å¹£åœ“é»
                    ctx.beginPath();
                    ctx.arc(m + size * 0.15, size * 0.7, size * 0.08, 0, Math.PI * 2);
                    ctx.fill(); ctx.stroke();
                    break;
            }
            ctx.restore();
        }
        function drawDiceStars(ctx, x, y, size, stars, diceColor, diceId) {
            const db = ALL_DICES.find(d => d.id === diceId);
            const quality = db ? db.quality : 'common';

            // --- è™•ç† 7 æ˜Ÿå¤§æ˜Ÿæ˜Ÿçš„é¡è‰² ---
            if (stars >= 7) {
                ctx.save();

                let starColor = "#fbbf24"; // é è¨­é‡‘è‰²

                if (quality === 'mythic') {
                    // ç¥è©±ç´š 7 æ˜Ÿï¼šå¤§æ˜Ÿæ˜Ÿä¹Ÿè¦è™¹å½©é–ƒçˆï¼
                    const hue = (Date.now() / 10) % 360;
                    starColor = `hsl(${hue}, 80%, 60%)`;
                } else if (quality === 'epic') {
                    starColor = "#c084fc"; // å²è©© 7 æ˜Ÿå¯ä»¥ç”¨ç´«è‰²å¤§æ˜Ÿæ˜Ÿï¼Œæˆ–è€…ç¶­æŒé‡‘è‰²
                }

                ctx.fillStyle = starColor;
                ctx.font = `bold ${size * 0.7}px Arial`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";

                // å¢åŠ ä¸€å€‹ç™¼å…‰é™°å½±è®“ç¥è©±å¤§æ˜Ÿæ˜Ÿæ›´éœ¸æ°£
                if (quality === 'mythic') {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = starColor;
                }

                ctx.fillText("â˜…", x + size / 2, y + size / 2 + size * 0.05);
                ctx.restore();
                return;
            }

            // --- è™•ç† 1-6 æ˜Ÿé»é»çš„é¡è‰² ---
            let dotColor = diceColor || "#333";

            switch (quality) {
                case 'rare': dotColor = "#60a5fa"; break;
                case 'epic': dotColor = "#c084fc"; break;
                case 'legend': dotColor = "#fbbf24"; break;
                case 'mythic':
                    const hue = (Date.now() / 10) % 360;
                    dotColor = `hsl(${hue}, 80%, 60%)`;
                    break;
                default: dotColor = "#ffffff"; break;
            }

            ctx.fillStyle = dotColor;

            // --- ç¹ªè£½ 1-6 é¡†é»é»çš„é‚è¼¯ (ç¶­æŒä¸è®Š) ---
            const dotSize = size * 0.07;
            const p = size * 0.22;
            const m = size / 2;
            const l = p, r = size - p;
            const t = p, b = size - p;

            let dots = [];
            if (stars === 1) dots = [[m, m]];
            else if (stars === 2) dots = [[l, t], [r, b]];
            else if (stars === 3) dots = [[l, t], [m, m], [r, b]];
            else if (stars === 4) dots = [[l, t], [r, t], [l, b], [r, b]];
            else if (stars === 5) dots = [[l, t], [r, t], [m, m], [l, b], [r, b]];
            else if (stars === 6) dots = [[l, t], [r, t], [l, m], [r, m], [l, b], [r, b]];

            dots.forEach(dot => {
                ctx.beginPath();
                ctx.arc(x + dot[0], y + dot[1], dotSize, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // --- æ–°å¢ï¼šå“è³ªé‚Šæ¡†ç‰¹æ•ˆ ---
        function drawQualityBorder(ctx, x, y, size, diceId) {
            if (!diceId) return;

            const db = ALL_DICES.find(d => d.id === diceId);
            if (!db) return;

            const quality = db.quality;
            const time = Date.now() / 1000;

            ctx.save();

            if (quality === 'legend') {
                // å‚³èªªï¼šå„ªé›…é‡‘æ¡†ï¼ˆå‘å¤–æ“´å±•ï¼Œä¸é®æ“‹å…§éƒ¨ï¼‰
                const pulse = 0.6 + Math.abs(Math.sin(time * 1.5)) * 0.3;

                // 1. å¤–æ¡†é‡‘é‚Šï¼ˆæ“´å±•åˆ°å¤–å´ï¼‰
                ctx.shadowColor = '#eab308';
                ctx.shadowBlur = 8 + pulse * 5;
                ctx.strokeStyle = `rgba(234, 179, 8, ${0.5 + pulse * 0.3})`;
                ctx.lineWidth = 3;

                ctx.beginPath();
                drawRoundedRect(ctx, x - 2, y - 2, size + 4, size + 4, 12); // å‘å¤–æ“´å±•2px
                ctx.stroke();

                // 2. å››è§’è£é£¾ï¼ˆå°å‹å…‰é»ï¼Œåœ¨å¤–å´è§’è½ï¼‰
                const cornerSize = 8;
                const corners = [
                    { cx: x - 3, cy: y - 3 },           // å·¦ä¸Šå¤–å´
                    { cx: x + size + 3, cy: y - 3 },    // å³ä¸Šå¤–å´
                    { cx: x - 3, cy: y + size + 3 },    // å·¦ä¸‹å¤–å´
                    { cx: x + size + 3, cy: y + size + 3 } // å³ä¸‹å¤–å´
                ];

                ctx.fillStyle = `rgba(250, 204, 21, ${0.6 + pulse * 0.4})`;
                ctx.shadowBlur = 10;
                corners.forEach(corner => {
                    // ç¹ªè£½è±å½¢å…‰é»
                    ctx.beginPath();
                    ctx.moveTo(corner.cx, corner.cy - cornerSize / 2);
                    ctx.lineTo(corner.cx + cornerSize / 2, corner.cy);
                    ctx.lineTo(corner.cx, corner.cy + cornerSize / 2);
                    ctx.lineTo(corner.cx - cornerSize / 2, corner.cy);
                    ctx.closePath();
                    ctx.fill();
                });

                // 3. å…§æ¡†ï¼ˆæ·¡é‡‘è‰²ç´°ç·šï¼Œç·Šè²¼éª°å­é‚Šç·£ï¼‰
                ctx.shadowBlur = 3;
                ctx.strokeStyle = `rgba(250, 204, 21, ${0.3 + pulse * 0.2})`;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                drawRoundedRect(ctx, x + 1, y + 1, size - 2, size - 2, 8);
                ctx.stroke();
            }
            else if (quality === 'mythic') {
                // ç¥è©±ï¼šç’€ç’¨æ˜Ÿç’°ï¼ˆå¤§ç¯„åœå¤–æ“´ï¼Œæ¥µè‡´è¯éº—ï¼‰
                const hueShift = (time * 120) % 360; // æ›´å¿«è‰²å½©å¾ªç’°

                // 1. å¤šå±¤å½©è™¹å…‰ç’°ï¼ˆå‘å¤–æ“´å±•ï¼‰
                for (let i = 0; i < 5; i++) { // 5å±¤
                    const layerHue = (hueShift + i * 72) % 360; // äº”è‰²å¾ªç’°
                    const offset = Math.sin(time * 5 + i * Math.PI / 2.5) * 4; // æ›´å¤§æµå‹•å¹…åº¦
                    const expansion = i * 2; // æ¯å±¤å‘å¤–æ“´å±•2px

                    ctx.shadowColor = `hsl(${layerHue}, 100%, 70%)`;
                    ctx.shadowBlur = 18 + i * 3;
                    ctx.strokeStyle = `hsla(${layerHue}, 100%, 75%, ${0.7 - i * 0.12})`;
                    ctx.lineWidth = 7 - i * 1.2;

                    ctx.beginPath();
                    drawRoundedRect(
                        ctx,
                        x - expansion + offset,
                        y - expansion + offset,
                        size + expansion * 2,
                        size + expansion * 2,
                        12
                    );
                    ctx.stroke();
                }

                // 2. å¤–åœæ˜Ÿåº§ï¼ˆåœ¨éª°å­å¤–å´åœç¹ï¼‰
                ctx.shadowBlur = 12;
                const starRadius = size / 2 + 15; // æ˜Ÿé»åœç¹åŠå¾‘ï¼ˆå¤–æ“´ï¼‰
                const centerX = x + size / 2;
                const centerY = y + size / 2;
                const starCount = 16; // æ›´å¤šæ˜Ÿé»
                const stars = [];

                for (let i = 0; i < starCount; i++) {
                    const angle = (i / starCount) * Math.PI * 2;
                    const wobble = Math.sin(time * 3 + i) * 3; // è¼•å¾®æ“ºå‹•
                    stars.push({
                        sx: centerX + Math.cos(angle) * (starRadius + wobble),
                        sy: centerY + Math.sin(angle) * (starRadius + wobble)
                    });
                }

                // ç¹ªè£½æ˜Ÿé»ï¼ˆæ›´å¤§æ›´äº®ï¼‰
                stars.forEach((star, idx) => {
                    const starHue = (hueShift + idx * 360 / starCount) % 360;
                    const twinkle = Math.sin(time * 6 + idx * 0.5) * 0.4 + 0.6;

                    ctx.fillStyle = `hsla(${starHue}, 100%, 90%, ${twinkle})`;
                    ctx.beginPath();
                    ctx.arc(star.sx, star.sy, 3, 0, Math.PI * 2);
                    ctx.fill();
                });

                // ç¹ªè£½æ˜Ÿåº§é€£ç·šï¼ˆé€£æ¥ç›¸é„°æ˜Ÿé»ï¼‰
                ctx.strokeStyle = `hsla(${hueShift}, 95%, 80%, 0.35)`;
                ctx.lineWidth = 1.5;
                for (let i = 0; i < stars.length; i++) {
                    const nextIdx = (i + 1) % stars.length;
                    ctx.beginPath();
                    ctx.moveTo(stars[i].sx, stars[i].sy);
                    ctx.lineTo(stars[nextIdx].sx, stars[nextIdx].sy);
                    ctx.stroke();
                }

                // 3. å››è§’è¶…ç´šæ˜ŸèŠ’ï¼ˆåœ¨å¤–å´è§’è½ï¼‰
                const starCorners = [
                    { cx: x - 6, cy: y - 6 },
                    { cx: x + size + 6, cy: y - 6 },
                    { cx: x - 6, cy: y + size + 6 },
                    { cx: x + size + 6, cy: y + size + 6 }
                ];

                starCorners.forEach((corner, idx) => {
                    const particleHue = (hueShift + idx * 90) % 360;
                    const twinkle = Math.sin(time * 7 + idx) * 0.5 + 0.5;

                    if (twinkle > 0.2) { // å¹¾ä¹ä¸€ç›´é¡¯ç¤º
                        ctx.save();
                        ctx.translate(corner.cx, corner.cy);

                        // 16æ¢å°„ç·šï¼ˆé›™å±¤ï¼‰
                        for (let layer = 0; layer < 2; layer++) {
                            const rayCount = layer === 0 ? 16 : 8;
                            const rayLength = layer === 0 ? 12 : 8;

                            ctx.strokeStyle = `hsla(${particleHue}, 100%, ${80 - layer * 10}%, ${twinkle * (0.9 - layer * 0.3)})`;
                            ctx.lineWidth = 2 - layer * 0.5;

                            for (let i = 0; i < rayCount; i++) {
                                ctx.save();
                                ctx.rotate(i * Math.PI / rayCount + time * 3 * (layer === 0 ? 1 : -1)); // åå‘æ—‹è½‰
                                ctx.beginPath();
                                ctx.moveTo(0, 0);
                                ctx.lineTo(0, -rayLength * twinkle);
                                ctx.stroke();
                                ctx.restore();
                            }
                        }

                        // è¶…å¤§ä¸­å¿ƒå…‰çƒ
                        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 5);
                        gradient.addColorStop(0, `hsla(${particleHue}, 100%, 95%, ${twinkle})`);
                        gradient.addColorStop(0.5, `hsla(${particleHue}, 100%, 80%, ${twinkle * 0.6})`);
                        gradient.addColorStop(1, `hsla(${particleHue}, 100%, 60%, 0)`);
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(0, 0, 5, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.restore();
                    }
                });
            }

            ctx.restore();
        }

        function renderDice(ctx, x, y, dice, isLocked) {
            if (!dice) return;
            const slotSize = grid.slotSize;

            // 1. ç•«å¤–æ¡† (å“è³ªé¡è‰²)
            ctx.beginPath();
            ctx.strokeStyle = dice.qualityColor || '#fff';
            ctx.lineWidth = 3;
            drawRoundedRect(ctx, x + 4, y + 4, slotSize - 8, slotSize - 8, 8);
            ctx.stroke();

            // 2. ç•«å¡«å……èƒŒæ™¯ (ç™½è‰²)
            ctx.beginPath();
            ctx.fillStyle = "#ffffff";
            drawRoundedRect(ctx, x + 6, y + 6, slotSize - 12, slotSize - 12, 6);
            ctx.fill();

            // æº–å‚™ç¹ªåœ–åƒæ•¸
            const dColor = dice.baseColor || dice.color || "#333";
            const pattern = dice.pattern || dice.id;
            const drawX = x + 6;
            const drawY = y + 6;
            const drawSize = slotSize - 12;

            // 2.5. ç¹ªè£½å“è³ªé‚Šæ¡†ç‰¹æ•ˆï¼ˆå‚³èªª/ç¥è©±ï¼‰
            if (typeof drawQualityBorder === 'function') {
                drawQualityBorder(ctx, x, y, slotSize, dice.id);
            }

            // 3. ç•«ç‰¹å¾µåœ–æ¡ˆ
            if (typeof drawDiceFeature === 'function') {
                drawDiceFeature(ctx, drawX, drawY, drawSize, pattern, dColor);
            }

            // 4. ç•«é»æ•¸
            if (typeof drawDiceStars === 'function') {
                drawDiceStars(ctx, drawX, drawY, drawSize, dice.lv, dColor, dice.id);
            }

            // 5. ç•« Boss é–å®š/ç¦éŒ®é®ç½©
            if (isLocked) {
                ctx.save();
                // ç•«ä¸€å€‹æ·±è‰²çš„åŠé€æ˜å±¤ï¼Œä»£è¡¨è¢«å°å°
                ctx.beginPath();
                ctx.fillStyle = "rgba(15, 23, 42, 0.75)"; // ä½¿ç”¨æ·±è‰² Slate è‰²èª¿
                drawRoundedRect(ctx, x + 5, y + 5, slotSize - 10, slotSize - 10, 8);
                ctx.fill();

                // ç•«ä¸€å€‹ç°¡å–®çš„ã€ŒXã€ç¬¦è™Ÿï¼Œè¡¨ç¤ºåŠŸèƒ½åœç”¨
                ctx.beginPath();
                ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
                ctx.lineWidth = 2;
                const padding = slotSize * 0.3;
                ctx.moveTo(x + padding, y + padding);
                ctx.lineTo(x + slotSize - padding, y + slotSize - padding);
                ctx.moveTo(x + slotSize - padding, y + padding);
                ctx.lineTo(x + padding, y + slotSize - padding);
                ctx.stroke();
                ctx.restore();
            }
        }

        function drawRoundedRect(ctx, x, y, w, h, r) {
            ctx.beginPath(); ctx.moveTo(x + r, y); ctx.lineTo(x + w - r, y); ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r); ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h); ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r); ctx.lineTo(x, y + r); ctx.quadraticCurveTo(x, y, x + r, y); ctx.closePath();
        }

        function setupTouchEvents(canvas) {
            const fingerPadding = 15; // æ‰‹æŒ‡å¯¬å®¹åº¦ï¼šå¢åŠ é»æ“Šåˆ¤å®šç¯„åœ

            canvas.addEventListener('touchstart', (e) => {
                const touch = e.touches[0], rect = canvas.getBoundingClientRect();

                // è¨ˆç®— Canvas åƒç´ èˆ‡ CSS é¡¯ç¤ºå¤§å°çš„æ¯”ä¾‹
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;

                // å–å¾—ä¿®æ­£å¾Œçš„ç•«å¸ƒåº§æ¨™
                const x = (touch.clientX - rect.left) * scaleX;
                const y = (touch.clientY - rect.top) * scaleY;

                grid.slots.forEach(slot => {
                    // é»æ“Šåˆ¤å®šï¼šåŠ å…¥ fingerPadding è®“åˆ¤å®šå€åŸŸå¾€å¤–æ“´å¼µ
                    if (slot.dice &&
                        x > slot.x - fingerPadding &&
                        x < slot.x + grid.slotSize + fingerPadding &&
                        y > slot.y - fingerPadding &&
                        y < slot.y + grid.slotSize + fingerPadding) {

                        drag.isDragging = true;
                        drag.fromSlot = slot;
                        drag.dice = { ...slot.dice }; // æ·ºæ‹·è²é¿å…ç›´æ¥ä¿®æ”¹åŸæ•¸æ“š
                        drag.currentX = x;
                        drag.currentY = y;
                        slot.isBeingDragged = true;
                    }
                });
            });

            canvas.addEventListener('touchmove', (e) => {
                if (!drag.isDragging) return;
                e.preventDefault(); // é˜»æ­¢æ‰‹æ©Ÿé é¢æ²å‹•

                const touch = e.touches[0], rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;

                // æ›´æ–°ç•¶å‰æ‹–æ‹½ä½ç½® (åŒæ¨£éœ€è¦æ¯”ä¾‹ä¿®æ­£)
                drag.currentX = (touch.clientX - rect.left) * scaleX;
                drag.currentY = (touch.clientY - rect.top) * scaleY;
            }, { passive: false });

            canvas.addEventListener('touchend', () => {
                if (!drag.isDragging) return;

                // å°‹æ‰¾ç›®æ¨™æ ¼å­ï¼šåŒæ¨£åŠ å…¥ fingerPadding è®“åˆæˆæ“ä½œæ›´è¼•é¬†
                let targetSlot = grid.slots.find(s =>
                    drag.currentX > s.x - fingerPadding &&
                    drag.currentX < s.x + grid.slotSize + fingerPadding &&
                    drag.currentY > s.y - fingerPadding &&
                    drag.currentY < s.y + grid.slotSize + fingerPadding
                );

                if (targetSlot && targetSlot !== drag.fromSlot && targetSlot.dice) {
                    // --- å°ä¸‘éª°å­è®Šèº«é‚è¼¯ ---
                    if (drag.dice.id === 'joker' && drag.dice.lv === targetSlot.dice.lv && targetSlot.dice.id !== 'joker') {
                        const targetId = targetSlot.dice.id;
                        const db = ALL_DICES.find(d => d.id === targetId);

                        drag.fromSlot.dice = {
                            id: targetId,
                            lv: drag.dice.lv,
                            color: db.baseColor,
                            qualityColor: QUALITIES[db.quality].color,
                            growthTimer: 0,
                            attackCooldown: 0
                        };

                        drag.isDragging = false;
                        drag.fromSlot.isBeingDragged = false;
                        updateUI();
                        refreshSunState();
                        return;
                    }

                    // --- ä¸€èˆ¬åˆæˆé‚è¼¯ (åŒ…å«å°ä¸‘ç¢°å°ä¸‘) ---
                    if (targetSlot.dice.id === drag.dice.id && targetSlot.dice.lv === drag.dice.lv && targetSlot.dice.lv < 7) {
                        const newId = userData.deck[Math.floor(Math.random() * userData.deck.length)];
                        const db = ALL_DICES.find(d => d.id === newId);

                        targetSlot.dice = {
                            id: newId,
                            lv: drag.dice.lv + 1,
                            color: db.baseColor,
                            qualityColor: QUALITIES[db.quality].color,
                            growthTimer: 0,
                            attackCooldown: 0
                        };
                        drag.fromSlot.dice = null;
                        updateUI();
                        refreshSunState();
                    }
                }
                // --- ç§»åˆ°ç©ºä½ ---
                else if (targetSlot && !targetSlot.dice) {
                    targetSlot.dice = { ...drag.dice, growthTimer: drag.dice.growthTimer || 0 };
                    drag.fromSlot.dice = null;
                }

                // çµ±ä¸€é‡ç½®ç‹€æ…‹
                drag.isDragging = false;
                if (drag.fromSlot) drag.fromSlot.isBeingDragged = false;
                updateUI();
                refreshSunState();
            });
        }
        function drawEffect(slot, color) {
            // 1. æœ€åŸºç¤çš„å®‰å…¨æª¢æŸ¥
            if (!slot || isNaN(slot.x)) return;

            // 2. ä¸è¦ä½¿ç”¨ save() å’Œ restore()ï¼Œé€™åœ¨æ‰‹æ©Ÿ Loop ä¸­éå¸¸é‡
            // 3. ç›´æ¥è¨­å®šå±¬æ€§ï¼Œç•«å®Œå¾Œæ‰‹å‹•æ”¹å›ä¾†
            ctx.globalAlpha = 0.4;
            ctx.strokeStyle = color;
            ctx.lineWidth = 4;

            // 4. åªç•«æœ€ç°¡å–®çš„çŸ©å½¢é‚Šæ¡† (strokeRect æ˜¯ Canvas ä¸­æ•ˆèƒ½æœ€é«˜çš„æŒ‡ä»¤ä¹‹ä¸€)
            ctx.strokeRect(
                slot.x + 2,
                slot.y + 2,
                grid.slotSize - 4,
                grid.slotSize - 4
            );

            // 5. æ‰‹å‹•é‡ç½®å…¨åŸŸå±¬æ€§ï¼Œé¿å…æ±™æŸ“å¾Œé¢çš„ç¹ªåœ–
            ctx.globalAlpha = 1.0;
            ctx.lineWidth = 1;
        }
    </script>
</body>

</html>