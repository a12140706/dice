<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>éª°å­æˆ°çˆ­ - æˆ°å ´</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            height: 100dvh;
            /* ä½¿ç”¨ dvh ç¢ºä¿åœ¨æ‰‹æ©Ÿä¸Šè‡ªå‹•æ‰£é™¤ç¶²å€åˆ—é«˜åº¦ */
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            background-color: #020617;
        }

        /* å¤ªé™½çˆ†ç‚¸å…‰åœˆ */
        .sun-explosion {
            position: absolute;
            border: 3px solid #fb923c;
            /* åŠ ç²—ä¸€é»æ¯”è¼ƒæ˜é¡¯ */
            background: rgba(251, 146, 60, 0.3);
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            /* ç¢ºä¿åœ“å¿ƒå°æº–æ€ªç‰©çš„ (x, y) */
            animation: sunExplode 0.4s ease-out forwards;
            z-index: 100;
            /* ç¢ºä¿å¤§æ–¼ Canvas çš„ z-index */
            box-shadow: 0 0 15px orange;
            /* å¢åŠ ç™¼å…‰æ„Ÿ */
        }

        @keyframes sunExplode {
            0% {
                width: 0px;
                height: 0px;
                opacity: 1;
            }

            100% {
                width: 130px;
                height: 130px;
                opacity: 0;
            }
        }

        #header-info {
            flex-shrink: 0;
            /* å›ºå®šé ­éƒ¨é«˜åº¦ */
        }

        #footer-controls {
            flex-shrink: 0;
            /* å›ºå®šåº•éƒ¨é«˜åº¦ */
            padding: 12px;
            padding-bottom: env(safe-area-inset-bottom, 20px);
            /* é‡å° iPhone åº•éƒ¨ç™½æ¢çš„æ’ç‰ˆå„ªåŒ– */
            background: rgba(15, 23, 42, 0.95);
            border-top: 1px solid rgba(51, 65, 85, 0.5);
        }

        #canvas-container {
            position: relative;
            width: 100%;
            max-width: min(550px, 80vh);
            /* ç§»é™¤å›ºå®šçš„ 90vhï¼Œæ”¹ç”¨ flex-grow è®“å®ƒè‡ªå‹•ä½”æ»¿å‰©é¤˜ç©ºé–“ */
            flex-grow: 1;
            margin: 0 auto;
            overflow: hidden;
            background: #000;
        }

        #gameCanvas {
            background: radial-gradient(circle at center, #69ff69 0%, #40004d 100%);
            touch-action: none;
            width: 100%;
            height: 100%;
        }

        .glass-panel {
            background: rgba(30, 41, 49, 0.8);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .diff-card {
            transition: all 0.3s;
            border: 2px solid transparent;
            cursor: pointer;
        }

        .diff-card:active {
            transform: scale(0.95);
        }

        .energy-glow {
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.5);
        }

        .scroll-hide::-webkit-scrollbar {
            display: none;
        }

        .pb-safe {
            /* é€™è£¡ä½¿ç”¨ calc ç¢ºä¿åŸæœ¬çš„ p-3 (12px) åŠ ä¸Š iOS å®‰å…¨å€ */
            padding-bottom: calc(0.75rem + env(safe-area-inset-bottom)) !important;
        }

        /* ç¢ºä¿æ•´å€‹æˆ°é¬¥å®¹å™¨æ˜¯ä½”æ»¿è¢å¹•ä¸”ä¸æº¢å‡ºçš„ */
        body,
        html {
            height: 100%;
            margin: 0;
            overflow: hidden;
            /* é˜²æ­¢æ©¡çš®ç­‹å›å½ˆå½±éŸ¿æˆ°é¬¥ */
            display: flex;
            flex-direction: column;
        }

        /* ç¢ºä¿ Footer æ˜¯å›ºå®šé«˜åº¦æˆ–è‡ªå‹•æ’é–‹ï¼Œä¸è¢«é®æ“‹ */
        #footer-controls {
            background-color: #0f172a;
            /* çµ¦å®ƒä¸€å€‹å¯¦åº•è‰²ï¼Œé¿å…ç™½æ¢ç©¿é€çœ‹åˆ°èƒŒæ™¯ */
        }
    </style>
</head>

<body class="flex flex-col h-screen bg-slate-900">
    <div id="header-info" class="p-3 flex justify-between items-center bg-slate-900/50">
        <div class="flex items-center gap-4">
            <span class="text-red-500 font-bold">HP: <span id="hpText">3</span></span>
            <span class="text-blue-400 font-bold">SP: <span id="spText">100</span></span>
        </div>
        <div class="text-slate-400 font-bold text-sm">LEVEL: <span id="headerLevelText">1</span></div>
        <div class="text-slate-400 font-bold text-sm">WAVE: <span id="waveText">1</span></div>
    </div>

    <div id="canvas-container" class="flex-1 relative">
        <canvas id="gameCanvas"
            style="touch-action: none; user-select: none; -webkit-user-select: none; -webkit-touch-callout: none; width: 100%; height: 100%; display: block;"></canvas>
    </div>

    <div id="footer-controls" class="p-3 max-w-[500px] mx-auto w-full pb-safe">
        <div class="flex flex-nowrap w-full gap-1 mb-4">
            <div id="powerUpButtons" class="contents"></div>
        </div>
        <button onclick="summonDice()"
            class="w-full py-4 bg-blue-600 rounded-xl font-black text-xl shadow-lg active:scale-95 transition-all text-white">
            å¬å–šéª°å­ (<span id="summonCostText">10</span> SP)
        </button>
    </div>

    <div id="difficultyOverlay" class="fixed inset-0 z-50 bg-black/95 flex items-center justify-center p-6">
        <div class="w-full max-w-sm text-center">
            <h2 class="text-2xl font-black mb-2 text-blue-400">å†’éšªæ¨¡å¼</h2>
            <div class="bg-slate-800 p-6 rounded-3xl border border-slate-700 mb-8">
                <p class="text-slate-400 text-sm">ç•¶å‰é€²åº¦</p>
                <h1 class="text-4xl font-black text-white mt-1">ç¬¬ <span id="currentLevelText">1</span> é—œ</h1>
                <p class="text-xs text-slate-500 mt-2">æ¯é—œåŒ…å« 20 å±¤</p>
            </div>

            <button onclick="startGame()"
                class="w-full bg-blue-600 py-4 rounded-2xl font-bold text-xl text-white active:scale-95 transition-all">
                é–‹å§‹æŒ‘æˆ°
            </button>
        </div>
    </div>

    <div id="resultModal"
        style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index:9999; flex-direction:column; align-items:center; justify-content:center; color:white;">

        <h1 id="resTitle" style="font-size:40px; margin:10px 0;">æˆ°ç¸¾çµç®—</h1>

        <div
            style="background:#1e293b; padding:20px; border-radius:15px; border:2px solid #3b82f6; text-align:center; min-width:250px;">
            <p style="font-size:18px; margin:5px 0;">æ’éæ³¢æ•¸ï¼š<span id="resWave" style="color:#facc15;">0</span> / 20</p>
            <hr style="border:0; border-top:1px solid #475569; margin:15px 0;">
            <p style="margin:5px 0;">ç²å¾—çå‹µ</p>
            <div style="font-size:28px; font-weight:bold; color:#10b981; margin-top:10px;">
                ğŸ« æŠ½çåˆ¸ x <span id="resTickets">0</span>
            </div>
        </div>

        <button onclick="location.href='dice.html?fromBattle=1'"
            style="margin-top:30px; padding:12px 35px; font-size:18px; background:#3b82f6; color:white; border:none; border-radius:8px; font-weight:bold;">
            é ˜å–ä¸¦å›å¤§å»³
        </button>
    </div>
    <script>
        let userData = JSON.parse(localStorage.getItem('dice_game_data')) || {
            deck: ['fire', 'wind', 'ice', 'electric', 'poison'],
            diceLevels: { 'fire': 1, 'wind': 1, 'ice': 1, 'electric': 1, 'poison': 1 },
            tickets: 0,
            unlockLevel: 1, // æ–°å¢ï¼šç´€éŒ„æ­·å²æœ€é«˜å±¤æ•¸
            maxWave: 0
        };
        if (userData.tickets === undefined) userData.tickets = 0;
        document.getElementById('currentLevelText').innerText = userData.unlockLevel || 1;
        document.getElementById('headerLevelText').innerText = userData.unlockLevel || 1;
        const AudioManager = {
            ctx: new (window.AudioContext || window.webkitAudioContext)(),
            buffers: {},

            // é åŠ è¼‰éŸ³æ•ˆ (å‚³å…¥åç¨±èˆ‡è·¯å¾‘)
            async init() {
                const savedData = localStorage.getItem('dice_game_data');
                if (savedData) {
                    userData = JSON.parse(savedData);
                }
                const sounds = {
                    'hit': 'dice-sound/hit.wav'
                    // ä»¥å¾Œå¯ä»¥å¢åŠ æ›´å¤šï¼Œä¾‹å¦‚ 'summon': 'dice-sound/summon.wav'
                };

                for (const [name, url] of Object.entries(sounds)) {
                    try {
                        const response = await fetch(url);
                        const arrayBuffer = await response.arrayBuffer();
                        this.buffers[name] = await this.ctx.decodeAudioData(arrayBuffer);
                        console.log(`éŸ³æ•ˆåŠ è¼‰æˆåŠŸ: ${name}`);
                    } catch (e) {
                        console.error(`éŸ³æ•ˆåŠ è¼‰å¤±æ•—: ${name}`, e);
                    }
                }
            },

            // æ’­æ”¾æ‰“æ“ŠéŸ³æ•ˆ
            playHit() {
                // å¦‚æœéœéŸ³æˆ–å°šæœªåŠ è¼‰ï¼Œå‰‡è¿”å›
                if (!this.buffers['hit'] || (userData.settings && !userData.settings.sfx)) return;

                // iPhone è§£é–é‚è¼¯
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }

                const source = this.ctx.createBufferSource();
                source.buffer = this.buffers['hit'];

                // è¨­å®šéŸ³é‡ (15å€‹éª°å­ä¸€èµ·æ‰“ï¼ŒéŸ³é‡ä¸€å®šè¦å°ï¼Œå»ºè­° 0.05 ~ 0.1)
                const gainNode = this.ctx.createGain();
                gainNode.gain.value = 0.08;

                source.connect(gainNode);
                gainNode.connect(this.ctx.destination);
                source.start(0);
            }
        };

        // é é¢åŠ è¼‰æ™‚åŸ·è¡Œåˆå§‹åŒ–
        AudioManager.init();

        const QUALITIES = {
            common: { name: 'æ™®é€š', color: '#9ca3af', chance: 0.50 },
            rare: { name: 'ç¨€æœ‰', color: '#3b82f6', chance: 0.30 },
            epic: { name: 'å²è©©', color: '#a855f7', chance: 0.18 },
            legend: { name: 'å‚³èªª', color: '#eab308', chance: 0.019 },
            mythic: { name: 'ç¥è©±', color: '#ff00ff', chance: 0.001 }
        };

        const ALL_DICES = [
            // --- Common (æ™®é€š) ---
            {
                id: 'fire', name: 'ç«', quality: 'common', baseColor: '#ef4444', pattern: 'fire',
                stats: { atk: 18, speed: 0.92 }, grow: { atk: 6, speed: -0.017 },
                special: { label: 'æ¿ºå°„ç¯„åœ', value: 1.0, unit: 'æ ¼', grow: 0.1 }
            },
            {
                id: 'wind', name: 'é¢¨', quality: 'common', baseColor: '#10b981', pattern: 'wind',
                stats: { atk: 8, speed: 0.58 }, grow: { atk: 2, speed: -0.025 }, // å‰Šå¼±åŸºç¤ï¼Œè®“å‡ºå‰æœŸéœ¸ä¸»ä½ç½®
                special: { label: 'é€£æ“Šæ©Ÿç‡', value: 10, unit: '%', grow: 3 }
            },
            {
                id: 'ice', name: 'å†°', quality: 'common', baseColor: '#3b82f6', pattern: 'ice',
                stats: { atk: 7, speed: 1.0 }, grow: { atk: 1, speed: -0.017 },
                special: { label: 'ç·©é€Ÿæ•ˆæœ', value: 20, unit: '%', grow: 2 }
            },
            {
                id: 'electric', name: 'é›»', quality: 'common', baseColor: '#f59e0b', pattern: 'electric',
                stats: { atk: 6, speed: 0.75 }, grow: { atk: 2, speed: -0.017 },
                special: { label: 'é€£é–ç›®æ¨™', value: 3, unit: 'é«”', grow: 1 }
            },
            {
                id: 'poison', name: 'æ¯’', quality: 'common', baseColor: '#008000', pattern: 'poison',
                stats: { atk: 4, speed: 0.83 }, grow: { atk: 2, speed: -0.017 },
                special: { label: 'ä¸­æ¯’å‚·å®³', value: 12, unit: 'pt', grow: 4 }
            },

            // --- Rare (ç¨€æœ‰) ---
            {
                id: 'lock', name: 'é–å®š', quality: 'rare', baseColor: '#64748b', pattern: 'lock',
                stats: { atk: 12, speed: 0.92 }, grow: { atk: 4, speed: -0.017 },
                special: { label: 'ç¦éŒ®æ™‚é•·', value: 0.8, unit: 'ç§’', grow: 0.2 }
            },
            // --- æ˜“å‚·éª°å­ (æ›¿ä»£åŸæœ¬çš„ç ´ç”²) ---
            {
                id: 'crack', name: 'æ˜“å‚·', quality: 'rare', baseColor: '#f87171', pattern: 'crack',
                stats: { atk: 12, speed: 0.83 }, grow: { atk: 3, speed: -0.017 },
                special: { label: 'é¡å¤–å—å‚·', value: 8, unit: '%', grow: 1 }
            },
            // --- ç¤¦å±±éª°å­ (ç¶“æ¿Ÿå‹) ---
            {
                id: 'mine', name: 'ç¤¦å±±', quality: 'rare', baseColor: '#fbbf24', pattern: 'mine',
                stats: { atk: 0, speed: 15.0 }, grow: { atk: 0, speed: -0.5 }, // ä¸æ”»æ“Šï¼Œé€Ÿåº¦ä»£è¡¨ç”¢éŒ¢é–“éš” (15ç§’)
                special: { label: 'ç”¢å‡ºSP', value: 10, unit: 'pt', grow: 5 }
            },

            // --- Epic (å²è©©) ---
            {
                id: 'laser', name: 'é›·å°„', quality: 'epic', baseColor: '#ec4899', pattern: 'laser_beam',
                stats: { atk: 8, speed: 0.67 }, grow: { atk: 2, speed: 0 },
                special: { label: 'å¢å¹…ä¸Šé™', value: 5, unit: 'å€', grow: 1 }
                // åŠŸèƒ½ï¼šæŒçºŒæ”»æ“ŠåŒä¸€å€‹ç›®æ¨™æ™‚ï¼Œå‚·å®³æœƒéš¨æ”»æ“Šæ¬¡æ•¸ä¸æ–·çˆ¬å‡
            },
            {
                id: 'teleport', name: 'å‚³é€', quality: 'epic', baseColor: '#8b5cf6', pattern: 'teleport',
                stats: { atk: 10, speed: 1.08 }, grow: { atk: 3, speed: -0.017 },
                special: { label: 'å‚³é€å›èµ·é»', value: 5, unit: '%', grow: 2 }
            },
            {
                id: 'gear', name: 'é½’è¼ª', quality: 'epic', baseColor: '#475569', pattern: 'gear',
                stats: { atk: 15, speed: 0.83 }, grow: { atk: 8, speed: -0.017 },
                special: { label: 'é€£çµåŠ æˆ', value: 12, unit: '%', grow: 6 }
            },

            // --- Legend (å‚³èªª) ---
            {
                id: 'mighty_wind', name: 'å¼·é¢¨', quality: 'legend', baseColor: '#a5f3fc', pattern: 'mighty_wind',
                stats: { atk: 20, speed: 0.67 }, grow: { atk: 6, speed: -0.017 },
                special: { label: 'ç‹‚æš´æ™‚é•·', value: 2, unit: 'ç§’', grow: 0.5 }
            },
            {
                id: 'joker', name: 'å°ä¸‘', quality: 'legend', baseColor: '#f87171', pattern: 'joker',
                stats: { atk: 5, speed: 0.83 }, grow: { atk: 1, speed: 0 },
                special: { label: 'ç¹¼æ‰¿æ¯”ä¾‹', value: 80, unit: '%', grow: 2 } // ä¾ç…§ä½ çš„æ¸¬è©¦ä¿ç•™ 80%
            },
            {
                id: 'growth', name: 'æˆé•·', quality: 'legend', baseColor: '#f472b6', pattern: 'growth',
                stats: { atk: 5, speed: 0.83 }, grow: { atk: 1, speed: -0.017 },
                special: { label: 'æˆé•·æ™‚é–“', value: 40, unit: 'ç§’', grow: -2 } // å› æ‡‰ç¯€å¥èª¿å¿«ï¼Œç¸®çŸ­è‡³ 40 ç§’
            },
            {
                id: 'sun', name: 'å¤ªé™½', quality: 'legend', baseColor: '#fbbf24', pattern: 'sun',
                stats: { atk: 35, speed: 0.92 }, grow: { atk: 15, speed: -0.008 },
                special: { label: 'æ¿ºå°„å‚·å®³', value: 100, unit: '%', grow: 25 }
            },
            {
                id: 'sanctuary', name: 'è–åŸŸ', quality: 'legend', baseColor: '#fbbf24', pattern: 'sanctuary',
                stats: { atk: 15, speed: 1.0 }, grow: { atk: 6, speed: -0.017 },
                special: { label: 'å…¨å ´æ”»é€Ÿ', value: 10, unit: '%', grow: 2 }
            },
            {
                id: 'comet', name: 'å½—æ˜Ÿ', quality: 'legend', baseColor: '#3b82f6', pattern: 'comet',
                stats: { atk: 18, speed: 0.75 }, grow: { atk: 7, speed: -0.017 },
                special: { label: 'å……èƒ½å€ç‡', value: 500, unit: '%', grow: 100 }
            },

            // --- Epic (å²è©©) æ–°å¢ ---
            {
                id: 'chain', name: 'é€£é–', quality: 'epic', baseColor: '#8b5cf6', pattern: 'chain',
                stats: { atk: 15, speed: 0.83 }, grow: { atk: 5, speed: -0.017 },
                special: { label: 'å½ˆå°„å¢å‚·', value: 50, unit: '%', grow: 10 }
            },

            // --- Mythic (ç¥è©±) ---
            {
                id: 'doom', name: 'æ¯€æ»…', quality: 'mythic', baseColor: '#7c3aed', pattern: 'doom',
                stats: { atk: 45, speed: 0.83 }, grow: { atk: 20, speed: -0.017 },
                special: { label: 'æ–¬æ®ºæ¯”ä¾‹', value: 35, unit: '%', grow: 5 }
            },
            {
                id: 'galaxy', name: 'éŠ€æ²³', quality: 'mythic', baseColor: '#6366f1', pattern: 'galaxy',
                stats: { atk: 60, speed: 0.83 }, grow: { atk: 30, speed: -0.017 },
                special: { label: 'é»‘æ´åå™¬', value: 2, unit: '%', grow: 1 }
            }
        ];

        const BOSS_TYPES = {
            'CRUSHER': {
                name: 'ç²‰ç¢è€…',
                color: '#ff4444',
                img: (() => { const i = new Image(); i.src = 'dice-boss/lock.png'; return i; })(),
                skillInterval: 500,
                onSkill: (boss) => {
                    const occupied = grid.slots.filter(s => s.dice && !s.isLocked);
                    if (occupied.length > 0) {
                        const target = occupied[Math.floor(Math.random() * occupied.length)];
                        target.isLocked = true;
                        setTimeout(() => { target.isLocked = false; }, 4000);
                    }
                }
            },
            'SNAKE': {
                name: 'å™´å°„è€…',
                color: '#22c55e',
                img: (() => { const i = new Image(); i.src = 'dice-boss/speed.png'; return i; })(),
                skillInterval: 500,
                onSkill: (boss) => {
                    // åªåŠ é€Ÿè‡ªå·±ï¼Œä¸å½±éŸ¿å…¶ä»–æ•µäºº
                    const originalSpeed = boss.speed;
                    boss.speed *= 2;
                    boss.isSprinting = true;

                    // åŠ é€Ÿè¦–è¦ºæ•ˆæœï¼šç•«é¢é‚Šç·£é–ƒç¶ å…‰
                    const container = document.getElementById('canvas-container');
                    if (container) {
                        container.style.boxShadow = 'inset 0 0 60px #22c55e';
                    }

                    setTimeout(() => {
                        if (enemies.includes(boss)) {
                            boss.speed = originalSpeed;
                            boss.isSprinting = false;
                        }
                        if (container) container.style.boxShadow = '';
                    }, 2500);
                }
            },
            'HACKER': {
                name: 'æ··äº‚è€…',
                color: '#a855f7',
                img: (() => { const i = new Image(); i.src = 'dice-boss/hack.png'; return i; })(),
                skillInterval: 500,
                onSkill: (boss) => {
                    // 1. å®‰å…¨æª¢æŸ¥ï¼šç¢ºä¿ grid å­˜åœ¨
                    if (!grid || !grid.slots) return;

                    // 2. å–å¾—å ´ä¸Šæœ‰éª°å­çš„æ ¼å­
                    const occupied = grid.slots.filter(s => s && s.dice);

                    if (occupied.length > 0) {
                        occupied.forEach(slot => {
                            // 3. å¾ç©å®¶çš„ã€Œå‡ºæˆ°ç‰Œçµ„ (userData.deck)ã€éš¨æ©Ÿé¸ä¸€å€‹ ID
                            const randomId = userData.deck[Math.floor(Math.random() * userData.deck.length)];

                            // 4. å¾ç¸½è³‡æ–™åº«æ‰¾åˆ°è©² ID çš„æ¨£æ¿
                            const template = ALL_DICES.find(d => d.id === randomId);

                            if (template && slot.dice) {
                                const currentLv = slot.dice.lv; // ä¿æŒåŸæœ¬æ˜Ÿç´š

                                // 5. åŸ·è¡Œè®Šæ› (ä¿æŒæ˜Ÿç´šï¼Œæ›´æ›ç¨®é¡å±¬æ€§)
                                slot.dice = {
                                    id: template.id,
                                    lv: currentLv,
                                    baseColor: template.baseColor,
                                    color: template.baseColor,
                                    pattern: template.pattern || template.id,
                                    qualityColor: QUALITIES[template.quality].color,
                                    growthTimer: 0,
                                    attackCooldown: 0
                                };
                            }
                        });

                        // 6. è¦–è¦ºæ•ˆæœï¼šç´«å…‰é–ƒçˆ
                        const container = document.getElementById('canvas-container');
                        if (container) {
                            container.style.boxShadow = 'inset 0 0 50px #a855f7';
                            setTimeout(() => { if (container) container.style.boxShadow = ''; }, 500);
                        }

                        // 7. é‡è¦ï¼šç‹€æ…‹é‡ç½® (å¤ªé™½ç‹€æ…‹ã€UI æ›´æ–°)
                        if (typeof refreshSunState === 'function') refreshSunState();
                        updateUI();
                    }
                }
            },
            'GRAVITY': {
                name: 'é‡åŠ›è€…',
                color: '#1e293b',
                img: (() => { const i = new Image(); i.src = 'dice-boss/gravity.png'; return i; })(),
                skillInterval: 600,
                onSkill: (boss) => {
                    // æŠ€èƒ½ï¼šå¼·å¤§é‡åŠ›å ´ï¼Œéš¨æ©Ÿè®“å ´ä¸Šä¸€å€‹éª°å­é™ 1 æ˜Ÿ
                    const occupied = grid.slots.filter(s => s.dice);
                    if (occupied.length > 0) {
                        const target = occupied[Math.floor(Math.random() * occupied.length)];

                        // é™æ˜Ÿ
                        target.dice.lv -= 1;

                        // åˆ¤æ–·ï¼šå¦‚æœæ˜Ÿç´šé™åˆ° 0ï¼Œå‰‡éª°å­æ¶ˆå¤±
                        if (target.dice.lv <= 0) {
                            target.dice = null;
                            // è¦–è¦ºæç¤ºï¼šéª°å­æ¶ˆå¤±è™•å†’å‡ºä¸€é»ç°ç…™
                            visualEffects.push({
                                type: 'explosion',
                                x: target.x + grid.slotSize / 2,
                                y: target.y + grid.slotSize / 2,
                                radius: 40,
                                color: 'rgba(30, 41, 59, 0.5)', // æ·±è‰²ç…™éœ§
                                life: 15, maxLife: 15
                            });
                        }

                        // æ›´æ–° UI èˆ‡å¤ªé™½é™£å‹ç‹€æ…‹
                        updateUI();
                        if (typeof refreshSunState === 'function') refreshSunState();
                    }
                }
            },
            'GLITCH': {
                name: 'å¹²æ“¾è€…',
                color: '#3b82f6',
                img: (() => { const i = new Image(); i.src = 'dice-boss/glitch.png'; return i; })(),
                skillInterval: 500,
                onSkill: (boss) => {
                    let occupiedSlots = grid.slots.filter(s => s && s.dice);
                    if (occupiedSlots.length < 2) return;

                    // ä¿®æ­£ï¼šä½¿ç”¨æ·±æ‹·è²ï¼Œç¢ºä¿æ¯å€‹éª°å­ç‰©ä»¶ç¨ç«‹ï¼Œé¿å…æ´—ç‰Œå¾Œå‡ºç¾é€£é«”å¬°éŒ¯èª¤
                    let allDiceData = occupiedSlots.map(s => JSON.parse(JSON.stringify(s.dice)));

                    for (let i = allDiceData.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [allDiceData[i], allDiceData[j]] = [allDiceData[j], allDiceData[i]];
                    }

                    occupiedSlots.forEach((slot, index) => {
                        slot.dice = allDiceData[index];
                    });

                    const container = document.getElementById('canvas-container');
                    if (container) {
                        container.style.filter = 'hue-rotate(90deg) contrast(1.5)';
                        setTimeout(() => { if (container) container.style.filter = ''; }, 400);
                    }
                    // æ´—ç‰Œå¾Œä¹Ÿè¦æª¢æŸ¥å¤ªé™½
                    if (typeof refreshSunState === 'function') refreshSunState();
                }
            }
        };
        const BALANCE = {
            // --- æ™®é€šæ€ªç‰© ---
            ENEMY_BASE_HP: 100,        // åŸºç¤è¡€é‡
            ENEMY_LEVEL_GROWTH: 1.10,  // è·¨é—œå¡æˆé•· (æ¯å¤šä¸€é—œå¤š 25% è¡€é‡)
            ENEMY_WAVE_GROWTH: 1.20,   // æ¯æ³¢æˆé•· (æ¯å¤šä¸€æ³¢å¤š 15% è¡€é‡)
            //ENEMY_SPEED_BASE: 1.5,     // åˆå§‹ç§»é€Ÿ
            //ENEMY_SPEED_WAVE_ADD: 0.015, // æ¯æ³¢å¢åŠ çš„ç§»é€Ÿ

            // --- Boss ---
            BOSS_BASE_HP: 3000,        // Boss åŸºç¤è¡€é‡
            BOSS_LEVEL_GROWTH: 1.35,    // Boss è·¨é—œå¡æˆé•·
            BOSS_WAVE_GROWTH: 1.5,     // Boss éš¨æ³¢æ¬¡æˆé•·ç³»æ•¸ (ä»¥ 10 æ³¢ç‚ºå–®ä½)
            //BOSS_SPEED_BASE: 1.0,      // Boss åˆå§‹ç§»é€Ÿ
            // BOSS_SPEED_WAVE_ADD: 0.01  // Boss æ¯æ³¢å¢åŠ çš„ç§»é€Ÿ
        };

        let battleState = { hp: 3, sp: 100, wave: 1, summonCost: 10, difficulty: 'normal', isStarted: false };
        let powerUpLevels = {};
        userData.deck.forEach(id => { powerUpLevels[id] = 1; });
        let frameCount = 0;
        let grid = { rows: 3, cols: 5, padding: 10, slotSize: 0, slots: [], y: 0 };
        let drag = { isDragging: false, fromSlot: null, currentX: 0, currentY: 0, dice: null };
        let waveState = { totalEnemiesPerWave: 10, spawnedCount: 0, isWaiting: false, timer: 0 };
        let projectiles = [], enemies = [], path = [], damagePopups = [];
        let visualEffects = []; // æ–°å¢ï¼šè¦–è¦ºç‰¹æ•ˆåˆ—è¡¨

        function startGame(diff) {
            // --- æ–°å¢ï¼šè§£é–éŸ³è¨Š (iPhone é—œéµ) ---
            if (typeof AudioManager !== 'undefined' && AudioManager.ctx) {
                if (AudioManager.ctx.state === 'suspended') {
                    AudioManager.ctx.resume().then(() => {
                        console.log("AudioContext resumed successfully");
                    });
                }
            }

            // --- åŸæœ‰é‚è¼¯ ---
            battleState.difficulty = diff;
            battleState.isStarted = true;
            document.getElementById('difficultyOverlay').style.display = 'none';
            initGame();
        }

        function initGame() {
            const canvas = document.getElementById('gameCanvas');
            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;

            initGrid(canvas);
            initPath(canvas);
            setupTouchEvents(canvas);
            updateUI();
            startRenderLoop();
        }

        function initGrid(canvas) {
            // å¢åŠ å´é‚Šé‚Šè·ï¼Œæ‰‹æ©Ÿä¸Šå»ºè­°çµ¦åˆ°ç•«å¸ƒå¯¬åº¦çš„ 15% å·¦å³ï¼Œé¿å…ä½”æ»¿å·¦å³
            const sideMargin = canvas.width * 0.12;

            // è¨ˆç®—å–®å€‹æ ¼å­çš„å°ºå¯¸
            grid.slotSize = (canvas.width - (grid.cols + 1) * grid.padding - (sideMargin * 2)) / grid.cols;

            const totalGridHeight = grid.rows * (grid.slotSize + grid.padding);
            // è®“éª°å­å€ç¨å¾®å¾€ä¸‹é ä¸€é»ï¼Œçµ¦ä¸Šæ–¹ç•™å‡ºæˆ°é¬¥ç©ºé–“
            grid.y = (canvas.height / 2) - (totalGridHeight / 2);

            grid.slots = [];
            for (let i = 0; i < grid.rows * grid.cols; i++) {
                const r = Math.floor(i / grid.cols), c = i % grid.cols;
                grid.slots.push({
                    x: sideMargin + grid.padding + c * (grid.slotSize + grid.padding),
                    y: grid.y + r * (grid.slotSize + grid.padding),
                    dice: null, isLocked: false, isBeingDragged: false, attackCooldown: 0
                });
            }
        }
        function getDiceSpecialValue(diceId) {
            if (!diceId) return 0;
            const dice = ALL_DICES.find(d => d.id === diceId);
            if (!dice || !dice.special) return 0;

            const lv = (userData.diceLevels && userData.diceLevels[diceId]) ? userData.diceLevels[diceId] : 1;

            // åŠ ä¸Š || 0 ç¢ºä¿å¦‚æœè³‡æ–™è¡¨æ²’å¯« value æˆ– growï¼Œä¸æœƒè®Šæˆ NaN
            const base = dice.special.value || 0;
            const grow = dice.special.grow || 0;

            return base + (lv - 1) * grow;
        }
        function transformJoker(jokerDice, targetDice) {
            const ratio = getDiceSpecialValue('joker') / 100; // æ‹¿åˆ° 0.8, 0.82...

            jokerDice.name = targetDice.name;
            jokerDice.baseColor = targetDice.baseColor;

            // ç¹¼æ‰¿æ”»æ“ŠåŠ› (å—æ¯”ä¾‹å½±éŸ¿)
            jokerDice.atk = targetDice.atk * ratio;

            // å¦‚æœè¤‡è£½çš„æ˜¯æˆé•·éª°å­ï¼Œæ™‚é–“è¦è®Šé•· (æ•ˆç‡é™ä½)
            if (targetDice.id === 'growth') {
                const targetTime = getDiceSpecialValue('growth');
                jokerDice.timer = targetTime / ratio; // ä¾‹å¦‚ 60 / 0.8 = 75ç§’
            }
        }
        function handleGameOver(isVictory) {
            let earnedTickets = 0;

            // 1. æ›´æ–°æœ€é«˜å±¤æ•¸ç´€éŒ„ (ç›®å‰çš„æ³¢æ•¸é€²åº¦)
            if (battleState.wave > (userData.maxWave || 0)) {
                userData.maxWave = battleState.wave;
            }

            // 2. è™•ç†å‹è² èˆ‡çå‹µé‚è¼¯
            if (isVictory) {
                // --- æˆåŠŸé€šé—œ ---
                // çå‹µæ”¹ç‚ºï¼šç•¶å‰é—œå¡ * 2 (ä¾‹å¦‚ç¬¬ 3 é—œé€šé—œçµ¦ 6 å¼µ)
                earnedTickets = (userData.unlockLevel || 1) * 2;

                // è§£é–ä¸‹ä¸€é—œ
                userData.unlockLevel = (userData.unlockLevel || 1) + 1;

                // é‡ç½®æœ€é«˜å±¤æ•¸ (å› ç‚ºæŒ‘æˆ°æ–°é—œå¡äº†)
                userData.maxWave = 0;
            } else {
                // --- å¤±æ•— ---
                // å¤±æ•—çå‹µå¯ä»¥ä¿ç•™åŸæœ¬çš„ã€Œæ¯ 5 å±¤çµ¦ 1 å¼µã€ï¼Œæˆ–æ˜¯ä½ ä¹Ÿå¯ä»¥æ”¹æˆ 0
                earnedTickets = Math.floor(battleState.wave / 10);
            }

            // 3. ç´¯åŠ é‡‘å¹£/åˆ¸ ä¸¦ å­˜æª”
            userData.tickets = (userData.tickets || 0) + earnedTickets;
            localStorage.setItem('dice_game_data', JSON.stringify(userData));

            // 4. å¼·åˆ¶æ›´æ–° HTML ä¸Šçš„æ–‡å­— (è§£æ±ºä½ æåˆ°çš„é¡¯ç¤ºæ²’è®Šçš„å•é¡Œ)
            // é€™è£¡æˆ‘å€‘åŒæ™‚æ›´æ–°ä½ é‚£å…©å€‹ id (header å’Œ overlay)
            const currentLv = userData.unlockLevel || 1;
            if (document.getElementById('currentLevelText')) {
                document.getElementById('currentLevelText').innerText = currentLv;
            }
            // å‡è¨­ä½ å¾Œä¾†æ”¹äº† ID å€åˆ†
            if (document.getElementById('headerLevelText')) {
                document.getElementById('headerLevelText').innerText = currentLv;
            }

            // 5. é¡¯ç¤ºçµç®—ç•«é¢
            showResultModal(isVictory, currentLv, battleState.wave, earnedTickets);
        }
        function showResultModal(isVictory, level, wave, tickets) {
            const modal = document.getElementById('resultModal');
            const title = document.getElementById('resTitle');

            if (isVictory) {
                title.innerText = "ğŸ‰ å®Œç¾é€šé—œ";
                title.style.color = "#facc15"; // é‡‘è‰²
            } else {
                title.innerText = "ğŸ’€ æˆ°æ•—";
                title.style.color = "#ef4444"; // ç´…è‰²
            }

            // é¡¯ç¤ºæ ¼å¼ï¼šç¬¬ 1 é—œ - 20 å±¤
            document.getElementById('resWave').innerText = `ç¬¬ ${level} é—œ - ${wave} å±¤`;
            document.getElementById('resTickets').innerText = tickets;
            modal.style.display = 'flex';
        }
        function initPath(canvas) {
            // 1. å–å¾—éª°å­é•·æ–¹å½¢çš„å››å€‹é‚Šç•Œ
            const gridTop = grid.y;
            const gridBottom = grid.y + (grid.rows * (grid.slotSize + grid.padding));

            // 2. è¨­å®šæ€ªç‰©èˆ‡éª°å­æ ¼çš„ã€Œé–“è·ã€(Gap)
            // å¦‚æœ Gap è¨­ç‚º 0ï¼Œæ€ªç‰©å°±æœƒç›´æ¥å£“åœ¨éª°å­é‚Šç·šä¸Šèµ°
            const gap = 35;

            // 3. è¨­å®šå·¦å³é‚Šç•Œ (åƒè€ƒä¹‹å‰ç¸®å°å¾Œçš„ grid å¯¬åº¦)
            const L = grid.slots[0].x - gap; // ä»¥æœ€å·¦é‚Šçš„éª°å­æ ¼åº§æ¨™å¾€å¤–æ¨
            const R = grid.slots[grid.cols - 1].x + grid.slotSize + gap; // ä»¥æœ€å³é‚Šå¾€å¤–æ¨

            // 4. å®šç¾©è·¯å¾‘ï¼Œè®“å®ƒè®Šæˆä¸€å€‹ã€Œè²¼åˆéª°å­å€ã€çš„é•·æ–¹å½¢
            const T = gridTop - gap;
            const B = gridBottom + gap;

            path = [
                { x: L, y: T }, // å·¦ä¸Š
                { x: R, y: T }, // å³ä¸Š
                { x: R, y: B }, // å³ä¸‹
                { x: L, y: B }, // å·¦ä¸‹
                { x: L, y: T + 5 } // çµ‚é» (ç•¥å¾®åç§»é¿å…é‡ç–Š)
            ];
        }

        function summonDice() {
            if (battleState.sp < battleState.summonCost) return;
            const emptySlots = grid.slots.filter(s => s.dice === null);
            if (emptySlots.length === 0) return;

            battleState.sp -= battleState.summonCost;
            battleState.summonCost += 10;

            const targetSlot = emptySlots[Math.floor(Math.random() * emptySlots.length)];
            const diceId = userData.deck[Math.floor(Math.random() * userData.deck.length)];
            const db = ALL_DICES.find(d => d.id === diceId);

            // ç¢ºä¿ slot ç‹€æ…‹ä¹¾æ·¨
            targetSlot.isLocked = false;
            targetSlot.isBeingDragged = false;
            targetSlot.attackCooldown = 0; // é‡ç½®è©²ä½ç½®çš„å†·å»

            // å®Œæ•´çš„éª°å­è³‡æ–™ç‰©ä»¶
            targetSlot.dice = {
                id: diceId,
                lv: 1,
                baseColor: db.baseColor, // å¿…é ˆæ–°å¢é€™è¡Œï¼
                color: db.baseColor,     // å…¼å®¹èˆŠé‚è¼¯
                pattern: db.pattern || diceId, // ç¢ºä¿æœ‰åœ–é¨°è³‡è¨Š
                qualityColor: QUALITIES[db.quality].color,
                growthTimer: 0,
                isPowered: false,
                spawnTime: Date.now() // è¨˜éŒ„å¬å–šæ™‚é–“ï¼Œè®“æ¯å€‹éª°å­æœ‰ç¨ç«‹çš„ç‹‚æš´å‘¨æœŸ
            };

            // å¦‚æœ slot ç‰©ä»¶æœ¬èº«æ²’æœ‰ x, y åƒç´ å€¼ï¼Œè¦åœ¨é€™è£¡è¨ˆç®—çµ¦ updateCombat ç”¨
            if (targetSlot.x === undefined) {
                targetSlot.x = targetSlot.col * grid.slotSize;
                targetSlot.y = targetSlot.row * grid.slotSize;
            }

            updateUI();
            if (typeof refreshSunState === 'function') refreshSunState();
        }

        function powerUpDice(id) {
            const lv = powerUpLevels[id] || 1;
            const cost = 100 * Math.pow(2, lv - 1);
            if (battleState.sp >= cost && lv < 5) {
                battleState.sp -= cost;
                powerUpLevels[id] = lv + 1;
                updateUI();
            }
        }

        function spawnEnemy() {
            // ç¢ºä¿å¾ userData æŠ“å–ï¼Œè‹¥ç‚º undefined å‰‡ä¿åº•ç‚º 1
            const level = Number(userData.unlockLevel) || 1;
            const wave = Number(battleState.wave) || 1;

            // åŸºç¤ HP è¨ˆç®—ï¼ŒåŠ å…¥ Math.max ç¢ºä¿ä¸æœƒæœ‰ 0 è¡€æ€ª
            const hp = Math.max(1,
                BALANCE.ENEMY_BASE_HP * Math.pow(BALANCE.ENEMY_LEVEL_GROWTH, level - 1) * Math.pow(BALANCE.ENEMY_WAVE_GROWTH, wave - 1)
            );

            enemies.push({
                x: path[0].x,
                y: path[0].y,
                pathIndex: 1,
                maxHp: hp,
                hp: hp,
                virtualHp: hp, // åŒæ­¥è™›æ“¬è¡€é‡
                speed: 1,
                rewardSp: 10 + Math.floor((battleState.wave - 1) / 5) * 10,
                isBoss: false
            });
        }

        function spawnBoss() {
            // å–å¾—ç•¶å‰é—œå¡ï¼Œè‹¥ç„¡å‰‡é è¨­ç‚º 1
            const level = userData.unlockLevel || 1;
            const wave = Number(battleState.wave) || 1;
            // éš¨æ©Ÿé¸å– Boss ç¨®é¡
            const typeKeys = Object.keys(BOSS_TYPES);
            const type = typeKeys[Math.floor(Math.random() * typeKeys.length)];

            // --- Boss HP å…¬å¼èª¿æ•´ ---
            // åŸºç¤ 2000 * (é—œå¡é›£åº¦åŠ æˆ 1.5å€) * (å±¤æ•¸åŠ æˆ)
            // é€™æ¨£ç¬¬ 2 é—œçš„ç¬¬ 10 æ³¢ Boss æœƒæ¯”ç¬¬ 1 é—œçš„ç¬¬ 20 æ³¢æ›´æœ‰æŒ‘æˆ°æ€§
            const hp = BALANCE.BOSS_BASE_HP * Math.pow(BALANCE.BOSS_LEVEL_GROWTH, level - 1) * Math.pow(BALANCE.BOSS_WAVE_GROWTH, (wave / 10));
            enemies.push({
                x: path[0].x,
                y: path[0].y,
                pathIndex: 1,
                maxHp: hp,
                hp: hp,
                virtualHp: hp,
                speed: 1, // éš¨é—œå¡ç¨å¾®æå‡ç§»é€Ÿï¼Œå¢åŠ é›£åº¦
                rewardSp: 300 + (level * 10), // è¶Šå¾Œé¢çš„ Boss çµ¦è¶Šå¤š SP
                isBoss: true,
                bossType: type,
                skillTimer: 0,
                size: 55, // Boss å¤§ä¸€é»æ¯”è¼ƒæœ‰éœ¸æ°£
                color: BOSS_TYPES[type].color
            });
        }

        function updateCombat() {
            if (typeof isSunActivated === 'undefined') window.isSunActivated = false;

            // --- æª¢æŸ¥è–åŸŸå…‰ç’° (å…¨å±€åŠ é€Ÿ) ---
            let sanctuaryBoost = 0;
            grid.slots.forEach(slot => {
                if (slot.dice && slot.dice.id === 'sanctuary' && !slot.isLocked) {
                    const pLv = userData.diceLevels['sanctuary'] || 1;
                    const db = ALL_DICES.find(d => d.id === 'sanctuary');
                    const boostPercent = (db.special.value + (pLv - 1) * db.special.grow) / 100;
                    sanctuaryBoost = Math.max(sanctuaryBoost, boostPercent); // å–æœ€é«˜å€¼ï¼Œä¸ç–ŠåŠ 
                }
            });

            grid.slots.forEach(slot => {
                if (slot.dice && slot.dice.id && !slot.isBeingDragged && slot.isLocked !== true) {
                    const db = ALL_DICES.find(d => d.id === slot.dice.id);
                    if (!db) return;
                    // åœ¨ updateCombat å‡½æ•¸å…§ï¼Œgrid.slots.forEach å¾ªç’°ä¸­
                    if (slot.dice.id === 'mighty_wind') {
                        // ä½¿ç”¨éª°å­è‡ªå·±çš„å¬å–šæ™‚é–“ä¾†è¨ˆç®—ç¨ç«‹çš„ç‹‚æš´å‘¨æœŸ
                        const spawnTime = slot.dice.spawnTime || Date.now();
                        const elapsed = Date.now() - spawnTime;
                        const cycle = elapsed % 8000; // æ¯å€‹éª°å­æœ‰è‡ªå·±çš„ 8 ç§’å¾ªç’°
                        const specValue = getDiceSpecialValue('mighty_wind'); // å–å¾—ç‹‚æš´ç§’æ•¸
                        const burstTime = specValue * 1000;
                        if (cycle < burstTime) {
                            slot.dice.burstSpeed = 0.1; // æ¥µé€Ÿæ”»æ“Šé€Ÿåº¦ (0.1ç§’)
                            slot.dice.isBurst = true;
                            // è¨ˆç®—å‘¼å¸å‹•ç•«æ•¸å€¼ï¼šåˆ©ç”¨ sine æ³¢ç”¢ç”Ÿ -0.05 ~ 0.05 çš„ç¸®æ”¾åç§»é‡
                            slot.dice.animScale = Math.sin(Date.now() / 100) * 0.05;
                        } else {
                            slot.dice.burstSpeed = null;
                            slot.dice.isBurst = false;
                            slot.dice.animScale = 0;
                        }
                    }
                    if (slot.dice.id === 'mine') {
                        slot.mineTimer = (slot.mineTimer || 0) + 1;
                        const pLv = userData.diceLevels['mine'] || 1;
                        // è¨ˆç®—ç”¢éŒ¢é€Ÿåº¦ (spd) -> è½‰å›å¹€æ•¸ (* 60)
                        let spd = Math.max(60, (db.stats.speed + (pLv - 1) * db.grow.speed) * 60);

                        if (slot.mineTimer >= spd) {
                            const spAmount = getDiceSpecialValue('mine') * slot.dice.lv;
                            battleState.sp += spAmount;

                            // å¢åŠ ä¸€å€‹é‡‘å¹£è·³å‡ºçš„è¦–è¦ºå›é¥‹
                            if (damagePopups.length < 15) {
                                damagePopups.push({
                                    x: slot.x + grid.slotSize / 2,
                                    y: slot.y,
                                    val: `+${spAmount} SP`,
                                    life: 40,
                                    color: "#fbbf24"
                                });
                            }
                            slot.mineTimer = 0;
                            if (typeof updateUI === 'function') updateUI();
                        }
                        return; // ç¤¦å±±éª°å­ä¸åŸ·è¡Œä¸‹æ–¹çš„å°‹æ•µæ”»æ“Šé‚è¼¯
                    }
                    // --- A. æˆé•·éª°å­é‚è¼¯ (ä¿æŒåŸæ¨£) ---
                    if (slot.dice.id === 'growth') {
                        if (!slot.dice.growthTimer) slot.dice.growthTimer = 0;
                        slot.dice.growthTimer++;
                        const targetSeconds = getDiceSpecialValue('growth');
                        if (slot.dice.growthTimer >= targetSeconds * 60) {
                            if (slot.dice.lv < 7) {
                                const newId = userData.deck[Math.floor(Math.random() * userData.deck.length)];
                                const newDb = ALL_DICES.find(d => d.id === newId);
                                slot.dice = {
                                    id: newId,
                                    lv: slot.dice.lv + 1,
                                    baseColor: newDb.baseColor,
                                    color: newDb.baseColor,
                                    qualityColor: QUALITIES[newDb.quality].color,
                                    growthTimer: 0,
                                    attackCooldown: 0,
                                    spawnTime: Date.now() // æˆé•·é€²åŒ–å¾Œé‡è¨­æ™‚é–“
                                };
                                if (typeof updateUI === 'function') updateUI();
                                if (typeof refreshSunState === 'function') refreshSunState();
                            }
                        }
                    }

                    // --- B. æ”»é€Ÿèˆ‡æ”»æ“Š ---
                    const pLv = userData.diceLevels[slot.dice.id] || 1;
                    let spd = Math.max(10, (db.stats.speed + (pLv - 1) * db.grow.speed) * 60);

                    // å¼·é¢¨ç‹‚æš´æ¨¡å¼è¦†è“‹æ”»é€Ÿ
                    if (slot.dice.id === 'mighty_wind' && slot.dice.burstSpeed) {
                        spd = slot.dice.burstSpeed * 60;
                    }

                    // è–åŸŸåŠ é€Ÿ
                    if (sanctuaryBoost > 0 && slot.dice.id !== 'sanctuary') {
                        spd *= (1 - sanctuaryBoost);
                    }

                    if (slot.dice.id === 'sun' && isSunActivated) spd /= 1.5;
                    if (spd < 5) spd = 5;

                    slot.attackCooldown = (slot.attackCooldown || 0) + 1;

                    if (slot.attackCooldown >= spd) {
                        // --- æ ¸å¿ƒä¿®æ”¹ï¼šç²¾ç¢ºé–å®šæœ€å‰æ€ªç‰© ---
                        const target = enemies
                            .filter(e => e.hp > 0 && (e.virtualHp !== undefined ? e.virtualHp : e.hp) > 0)
                            .sort((a, b) => {
                                // 1. å…ˆæ¯”è·¯å¾‘é€²åº¦ (å“ªä¸€å€‹ç¶“éçš„è·¯å¾‘é»å¤š)
                                if (b.pathIndex !== a.pathIndex) {
                                    return b.pathIndex - a.pathIndex;
                                }
                                // 2. å¦‚æœè·¯å¾‘é»ä¸€æ¨£ï¼Œæ¯”è·é›¢ä¸‹ä¸€å€‹é»çš„è·é›¢ (è¶Šå°ä»£è¡¨è¶Šå‰é¢)
                                // æˆ‘å€‘ç°¡å–®ç”¨ç•¶å‰åº§æ¨™èˆ‡ path[pathIndex] çš„è·é›¢ä¾†æ¯”
                                const nextPoint = path[a.pathIndex];
                                if (nextPoint) {
                                    const distA = Math.hypot(a.x - nextPoint.x, a.y - nextPoint.y);
                                    const distB = Math.hypot(b.x - nextPoint.x, b.y - nextPoint.y);
                                    return distA - distB;
                                }
                                return 0;
                            })[0];

                        if (target) {
                            const powerUpLv = powerUpLevels[slot.dice.id] || 1;
                            let dmg = (db.stats.atk + (pLv - 1) * db.grow.atk) * slot.dice.lv * (1 + (powerUpLv - 1) * 0.4);
                            if (slot.dice.id === 'gamble') {
                                const gambleDb = ALL_DICES.find(d => d.id === 'gamble');
                                const pLv = userData.diceLevels['gamble'] || 1;
                                // æœ€å¤§å€ç‡å¾ 400% èµ·è·³
                                const maxMultiplier = (gambleDb.special.value + (pLv - 1) * gambleDb.special.grow) / 100;
                                // éš¨æ©Ÿå¾ 0.1 (10%) åˆ° maxMultiplier ä¹‹é–“æŠ½å–
                                const randomMultiplier = 0.1 + Math.random() * (maxMultiplier - 0.1);
                                dmg *= randomMultiplier;
                            }
                            // é½’è¼ªåŠ æˆé‚è¼¯ä¿æŒåŸæ¨£
                            if (slot.dice.id === 'gear') {
                                const idx = grid.slots.indexOf(slot);
                                const col = idx % grid.cols;
                                const row = Math.floor(idx / grid.cols);
                                let neighbors = 0;
                                grid.slots.forEach((s, sIdx) => {
                                    if (s.dice && s.dice.id === 'gear' && s !== slot) {
                                        let sCol = sIdx % grid.cols;
                                        let sRow = Math.floor(sIdx / grid.cols);
                                        if (Math.abs(sCol - col) + Math.abs(sRow - row) === 1) neighbors++;
                                    }
                                });
                                dmg *= (1 + neighbors * 0.5);
                            }

                            // --- å½—æ˜Ÿå……èƒ½æ©Ÿåˆ¶ ---
                            let isCometCharged = false;
                            if (slot.dice.id === 'comet') {
                                slot.dice.chargeCount = (slot.dice.chargeCount || 0) + 1;
                                if (slot.dice.chargeCount >= 5) {
                                    const cometDb = ALL_DICES.find(d => d.id === 'comet');
                                    const cometBoost = (cometDb.special.value + (pLv - 1) * cometDb.special.grow) / 100;
                                    dmg *= cometBoost; // 500% = Ã—5
                                    isCometCharged = true;
                                    slot.dice.chargeCount = 0;
                                }
                            }

                            slot.dice.tempSlotIdx = grid.slots.indexOf(slot);
                            slot.dice.tempIsCometCharged = isCometCharged; // å‚³éçµ¦ executeAttack
                            executeAttack(
                                slot.dice,
                                target,
                                dmg,
                                slot.x + grid.slotSize / 2,
                                slot.y + grid.slotSize / 2,
                                isSunActivated
                            );
                            slot.attackCooldown = 0;
                        }
                    }
                }
            });

            // å­å½ˆç§»å‹•é‚è¼¯ (ä¿æŒåŸæ¨£)
            for (let i = projectiles.length - 1; i >= 0; i--) {
                let p = projectiles[i];
                if (!enemies.includes(p.target) || p.target.hp <= 0) {
                    projectiles.splice(i, 1);
                    continue;
                }
                let dx = p.target.x - p.x;
                let dy = p.target.y - p.y;
                let dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < 15) {
                    applyHitEffect(p);
                    projectiles.splice(i, 1);
                } else {
                    p.x += (dx / dist) * (p.speed || 10);
                    p.y += (dy / dist) * (p.speed || 10);
                }
            }
        }
        // ç‰¹æ®Šéª°å­æ•ˆæœ
        // ã€ç™¼å°„ç«¯ã€‘è™•ç†ï¼šè™›æ“¬è¡€é‡ã€å¤ªé™½ AOEã€ç”¢ç”Ÿå­å½ˆ
        // --- ä¿®æ”¹å¾Œçš„ executeAttack ---
        function executeAttack(dice, target, damage, startX, startY, isSunActivated) {
            if (!target || target.hp <= 0) return;
            if (target.virtualHp === undefined) target.virtualHp = target.hp;

            // --- A. Galaxy (éŠ€æ²³)ï¼šæ©Ÿç‡é»‘æ´ ---
            if (dice.id === 'galaxy') {
                const spec = getDiceSpecialValue('galaxy');
                // è§¸ç™¼æ©Ÿç‡ï¼šåŸºç¤ 15% + åå™¬æ¯”ä¾‹ (2%...)
                const triggerChance = 0.05 + (spec / 100);
                const isBlackHoleTriggered = Math.random() < triggerChance;

                if (isBlackHoleTriggered) {
                    const pullRange = 130;
                    // è¦–è¦ºï¼šé»‘æ´æ ¸å¿ƒèˆ‡å¼•åŠ›å ´
                    visualEffects.push({
                        type: 'explosion', x: target.x, y: target.y, radius: 30,
                        color: 'rgba(0, 0, 0, 0.8)', life: 15, maxLife: 15
                    });
                    visualEffects.push({
                        type: 'explosion', x: target.x, y: target.y, radius: pullRange,
                        color: 'rgba(99, 102, 241, 0.3)', life: 20, maxLife: 20
                    });

                    // é»‘æ´æ‹‰åŠ›é‚è¼¯
                    enemies.forEach(e => {
                        if (e.hp > 0) {
                            const dist = Math.hypot(target.x - e.x, target.y - e.y);
                            if (dist < pullRange && dist > 5) {
                                const dx = target.x - e.x, dy = target.y - e.y;
                                e.x += (dx / dist) * 4;
                                e.y += (dy / dist) * 4;
                            }
                        }
                    });
                    // åå™¬é¡å¤–å‚·å®³
                    damage += target.maxHp * (spec / 100);
                }

                target.hp -= damage;
                target.virtualHp = target.hp;
                if (damagePopups.length < 20) {
                    damagePopups.push({
                        x: target.x, y: target.y, val: Math.floor(damage),
                        life: 30, color: isBlackHoleTriggered ? "#6366f1" : "#818cf8"
                    });
                }
                return;
            }

            // --- B. Doom (æ¯€æ»…)ï¼šæ¯ 10 ä¸‹è§¸ç™¼ä¸€æ¬¡æ¨™è¨˜ ---
            if (dice.id === 'doom') {
                // ä½¿ç”¨éª°å­ç‰©ä»¶å…§çš„è¨ˆæ•¸å™¨
                dice.doomCounter = (dice.doomCounter || 0) + 1;

                if (dice.doomCounter >= 10 && !target.doomMark) {
                    const spec = getDiceSpecialValue('doom');
                    target.doomMark = {
                        damage: target.maxHp * (spec / 100),
                        timer: 10000,
                        startTime: Date.now()
                    };
                    visualEffects.push({
                        type: 'explosion', x: target.x, y: target.y, radius: 50,
                        color: 'rgba(124, 58, 237, 0.6)', life: 25, maxLife: 25
                    });
                    dice.doomCounter = 0; // é‡è¨­è¨ˆæ•¸
                }

                target.hp -= damage;
                target.virtualHp = target.hp;
                if (damagePopups.length < 20) {
                    damagePopups.push({ x: target.x, y: target.y, val: Math.floor(damage), life: 25, color: "#a78bfa" });
                }
                return;
            }

            // --- C. Sun (å¤ªé™½) ---
            if (dice.id === 'sun' && isSunActivated) {
                const tx = target.x, ty = target.y;
                visualEffects.push({
                    type: 'explosion', x: tx, y: ty, radius: 80,
                    color: 'rgba(251, 146, 60, 0.6)', life: 20, maxLife: 20
                });
                enemies.forEach(e => {
                    if (e.hp > 0 && Math.hypot(e.x - tx, e.y - ty) < 65) {
                        e.hp -= damage;
                        e.virtualHp = e.hp;
                        if (damagePopups.length < 20) {
                            damagePopups.push({ x: e.x, y: e.y, val: Math.floor(damage), life: 25, color: "#ffaa00" });
                        }
                    }
                });
                return;
            }

            // --- D. Laser (é›·å°„) ---
            if (dice.id === 'laser') {
                const spec = getDiceSpecialValue('laser');
                const diceUid = `slot_${dice.tempSlotIdx}`;
                if (target.lastLaserUid === diceUid) {
                    target.laserStack = Math.min((target.laserStack || 1) + 1, spec);
                } else {
                    target.laserStack = 1;
                    target.lastLaserUid = diceUid;
                }
                let finalDmg = damage * target.laserStack;
                visualEffects.push({
                    type: 'laser', start: { x: startX, y: startY }, end: { x: target.x, y: target.y },
                    color: '#ec4899', life: 8, maxLife: 8
                });
                target.hp -= finalDmg;
                target.virtualHp = target.hp;
                if (damagePopups.length < 20) {
                    damagePopups.push({ x: target.x, y: target.y, val: Math.floor(finalDmg), life: 25, color: "#f472b6" });
                }
                return;
            }

            // --- E. Comet (å½—æ˜Ÿ) ---
            if (dice.id === 'comet' && dice.tempIsCometCharged) {
                visualEffects.push({
                    type: 'explosion', x: target.x, y: target.y, radius: 80,
                    color: 'rgba(59, 130, 246, 0.8)', life: 25, maxLife: 25
                });
                target.hp -= damage;
                target.virtualHp = target.hp;
                if (damagePopups.length < 20) {
                    damagePopups.push({ x: target.x, y: target.y, val: Math.floor(damage), life: 40, color: "#60a5fa" });
                }
                return;
            }

            // --- F. Chain (é€£é–) ---
            if (dice.id === 'chain') {
                const chainDb = ALL_DICES.find(d => d.id === 'chain');
                const pLv = userData.diceLevels['chain'] || 1;
                const boostPercent = (chainDb.special.value + (pLv - 1) * chainDb.special.grow) / 100;
                let currentTarget = target, currentDamage = damage;
                const bouncedTargets = [target];
                for (let i = 0; i < 3; i++) {
                    if (!currentTarget) break;
                    currentTarget.hp -= currentDamage;
                    currentTarget.virtualHp = Math.min(currentTarget.virtualHp, currentTarget.hp);
                    if (damagePopups.length < 20) {
                        damagePopups.push({ x: currentTarget.x, y: currentTarget.y, val: Math.floor(currentDamage), life: 25, color: "#fbbf24" });
                    }
                    if (i > 0) {
                        visualEffects.push({
                            type: 'lightning', start: { x: bouncedTargets[i - 1].x, y: bouncedTargets[i - 1].y },
                            end: { x: currentTarget.x, y: currentTarget.y }, life: 10, maxLife: 10
                        });
                    }
                    const next = enemies.find(e => e.hp > 0 && !bouncedTargets.includes(e) && Math.hypot(e.x - currentTarget.x, e.y - currentTarget.y) < 150);
                    if (!next) break;
                    bouncedTargets.push(next);
                    currentTarget = next;
                    currentDamage *= (1 + boostPercent);
                }
                return;
            }

            // --- G. æ™®é€šå­å½ˆ ---
            target.virtualHp -= damage;
            projectiles.push({
                x: startX, y: startY, target: target, damage: damage,
                diceId: dice.id, diceUid: `slot_${dice.tempSlotIdx}`,
                color: dice.color || "#ffffff", speed: 12
            });
        }     // ã€æ’æ“Šç«¯ã€‘è™•ç†ï¼šå–®é«”å‚·å®³ã€åŠŸèƒ½æ€§æ•ˆæœ (æ¸›é€Ÿã€ä¸­æ¯’ã€å‚³é€ã€é€£é–)
        // ã€æ’æ“Šç«¯ã€‘è™•ç†ï¼šå–®é«”å‚·å®³ã€åŠŸèƒ½æ€§æ•ˆæœ
        function applyHitEffect(p) {
            const target = p.target;
            if (!target || !enemies.includes(target) || (p.damage > 0 && target.hp <= 0)) return;

            // 1. åŸºç¤å‚·å®³è™•ç†
            if (p.damage > 0) {
                if (target.vulnerability) p.damage *= (1 + target.vulnerability / 100);
                target.hp -= p.damage;
                // å¼·åˆ¶åŒæ­¥è™›æ“¬è¡€é‡
                if (target.hp < target.virtualHp) target.virtualHp = target.hp;

                if (typeof AudioManager !== 'undefined' && AudioManager.playHit) AudioManager.playHit();
                if (damagePopups.length < 20) {
                    damagePopups.push({
                        x: target.x, y: target.y,
                        val: Math.floor(p.damage),
                        life: 30,
                        color: target.vulnerability ? "#f87171" : "#ffffff"
                    });
                }
            }

            // 2. åŸ·è¡Œå­å½ˆé¡çš„åŠŸèƒ½æ€§æ•ˆæœ
            const spec = getDiceSpecialValue(p.diceId);
            switch (p.diceId) {
                case 'crack': // æ˜“å‚·
                    target.vulnerability = Math.max(target.vulnerability || 0, spec);
                    break;
                case 'ice': // ç·©é€Ÿ (æ°¸ä¹…ä¸”ä¸ç–ŠåŠ ï¼Œå–æœ€é«˜å€¼)
                    // spec æ˜¯ç•¶å‰éª°å­çš„ç·©é€Ÿç™¾åˆ†æ¯” (ä¾‹å¦‚ 20 ä»£è¡¨ 20%)
                    const currentIcePower = spec;

                    // åªæœ‰ç•¶ã€Œæ–°æ•ˆæœã€æ¯”ã€ŒèˆŠæ•ˆæœã€å¼·æ™‚æ‰æ›´æ–°
                    if (!target.iceEffect || currentIcePower > target.iceEffect) {
                        // è¨˜éŒ„æœ€é«˜ç·©é€Ÿæ¯”ä¾‹
                        target.iceEffect = currentIcePower;

                        // é‡æ–°è¨ˆç®—é€Ÿåº¦ï¼šå§‹çµ‚ä»¥åŸºç¤é€Ÿåº¦ 1 ç‚ºæº–
                        // é€™æ¨£å°±ä¸æœƒç™¼ç”Ÿã€Œè¶Šæ‰“è¶Šæ…¢ç›´åˆ°è®Šæˆ 0ã€çš„ç–ŠåŠ å•é¡Œ
                        const monsterBaseSpeed = 1;
                        target.speed = Math.max(0.2, monsterBaseSpeed * (1 - target.iceEffect / 100));
                    }
                    // ç§»é™¤åŸæœ¬çš„ iceTimer å’Œé‚„åŸé‚è¼¯ï¼Œå› ç‚ºç¾åœ¨æ˜¯æ°¸ä¹…
                    break;
                case 'lock': // ç¦éŒ®
                    if (Math.random() < 0.2) {
                        const originalSpeed = target.speed || 1;
                        target.speed = 0;
                        setTimeout(() => { if (target) target.speed = originalSpeed; }, spec * 1000);
                    }
                    break;
                case 'electric': // é›»æ“Šé€£é–
                    enemies.forEach(e => {
                        if (e !== target && e.hp > 0 && Math.hypot(e.x - target.x, e.y - target.y) < 100) {
                            let chainDmg = p.damage * 0.5;
                            e.hp -= chainDmg;
                            e.virtualHp = Math.min(e.virtualHp, e.hp);
                            visualEffects.push({
                                type: 'lightning', start: { x: target.x, y: target.y },
                                end: { x: e.x, y: e.y }, life: 10, maxLife: 10
                            });
                            if (damagePopups.length < 15) {
                                damagePopups.push({ x: e.x, y: e.y, val: Math.floor(chainDmg), life: 20, color: "#fde047" });
                            }
                        }
                    });
                    break;
                case 'poison': // ä¸­æ¯’
                    target.poisonStacks = (target.poisonStacks || 0) + 1;
                    break;
                case 'teleport': // å‚³é€
                    const teleportChance = spec / 100;
                    if (Math.random() < teleportChance) {
                        if (target.isBoss) {
                            const os = target.speed;
                            target.speed = 0;
                            setTimeout(() => { if (target) target.speed = os; }, 1000);
                        } else {
                            target.x = path[0].x;
                            target.y = path[0].y;
                            target.pathIndex = 1;
                        }
                        visualEffects.push({
                            type: 'explosion', x: target.x, y: target.y, radius: 40,
                            color: '#8b5cf6', life: 15, maxLife: 15
                        });
                    }
                    break;
            }

            // 3. æ­»äº¡åˆ¤å®š
            if (target.hp <= 0) {
                const idx = enemies.indexOf(target);
                if (idx > -1) {
                    battleState.sp += target.rewardSp || 10;
                    enemies.splice(idx, 1);
                    if (typeof updateUI === 'function') updateUI();
                }
            }
        }
        function updateEnemies() {
            // æ¡ç”¨å€’åºè¿´åœˆæ˜¯æ­£ç¢ºçš„ï¼Œå› ç‚ºå…§éƒ¨æœ‰ splice æ“ä½œ
            for (let i = enemies.length - 1; i >= 0; i--) {
                let e = enemies[i];

                // --- 0. é˜²å‘†ï¼šæ¸…é™¤ç„¡æ•ˆåº§æ¨™çš„æ€ªç‰© (é˜²æ­¢å¡æ³¢æ¬¡) ---
                if (Number.isNaN(e.x) || Number.isNaN(e.y)) {
                    enemies.splice(i, 1);
                    continue;
                }

                // --- 1. è™•ç†ä¸­æ¯’æŒçºŒå‚·å®³ ---
                if (e.poisonStacks > 0) {
                    const poisonDmgPerFrame = (e.poisonStacks * 2) / 60;
                    e.hp -= poisonDmgPerFrame;

                    if (frameCount % 60 === 0) {
                        damagePopups.push({
                            x: e.x, y: e.y - 15,
                            val: Math.floor(e.poisonStacks * 2),
                            color: "#a855f7", life: 30
                        });
                    }
                }

                // --- 2. Boss æŠ€èƒ½èˆ‡æ™ƒå‹•é‚è¼¯ ---
                if (e.isBoss && e.hp > 0) {
                    if (!e.skillTimer) e.skillTimer = 0;
                    e.skillTimer++;

                    const bossConfig = BOSS_TYPES[e.bossType];
                    if (bossConfig && e.skillTimer >= bossConfig.skillInterval) {
                        e.shakeTimer = 20;
                        bossConfig.onSkill(e);
                        e.skillTimer = 0;
                        updateUI();
                        if (typeof refreshSunState === 'function') refreshSunState();
                    }
                }
                if (e.shakeTimer > 0) e.shakeTimer--;

                // --- 2.5. æ¯€æ»…æ¨™è¨˜ (Doom) ---
                if (e.doomMark) {
                    const elapsed = Date.now() - e.doomMark.startTime;
                    if (elapsed >= e.doomMark.timer) {
                        e.hp -= e.doomMark.damage;
                        if (damagePopups.length < 10) {
                            damagePopups.push({
                                x: e.x, y: e.y, val: Math.floor(e.doomMark.damage),
                                life: 40, color: "#7c3aed"
                            });
                        }
                        visualEffects.push({
                            type: 'explosion', x: e.x, y: e.y, radius: 100,
                            color: 'rgba(124, 58, 237, 0.9)', life: 30, maxLife: 30
                        });
                        delete e.doomMark;
                    }
                }

                // --- 3. æ ¸å¿ƒæª¢æŸ¥ï¼šå¦‚æœåœ¨æ­¤åˆ»å·²ç¶“æ²’è¡€äº† (ä¸­æ¯’æˆ–æ¯€æ»…è‡´æ­») ---
                if (e.hp <= 0) {
                    battleState.sp += e.rewardSp || 10;
                    enemies.splice(i, 1);
                    updateUI();
                    continue; // é€™éš»æ€ªæ­»äº†ï¼Œè·³éå¾Œé¢çš„ç§»å‹•é‚è¼¯
                }

                // --- 4. ç§»å‹•é‚è¼¯ ---
                let target = path[e.pathIndex];
                if (!target) { // é˜²å‘†ï¼šå¦‚æœ pathIndex æº¢å‡º
                    enemies.splice(i, 1);
                    continue;
                }

                let dx = target.x - e.x, dy = target.y - e.y, dist = Math.sqrt(dx * dx + dy * dy);

                if (dist <= e.speed || dist <= 0.1) {
                    e.pathIndex++;
                    // --- æŠµé”çµ‚é»çš„å¼·åŒ–è™•ç† ---
                    if (e.pathIndex >= path.length) {
                        // Boss æŠµé”çµ‚é» -> ç›´æ¥è¼¸æ‰
                        if (e.isBoss) {
                            battleState.hp = 0;
                        } else {
                            battleState.hp--;
                        }

                        // ã€å¹½éˆæ€ªä¿®å¾©é—œéµã€‘: æŠµé”çµ‚é»å¾Œï¼Œå¼·åˆ¶å°‡è³‡æ–™æ¸…ç©ºä¸¦ç«‹å³ç§»é™¤å¯¦é«”
                        e.hp = 0;
                        e.virtualHp = 0;
                        enemies.splice(i, 1); // ç¢ºä¿ e è¢«ç§»é™¤ï¼Œè®“ enemies.length æ­¸é›¶

                        updateUI();

                        if (battleState.hp <= 0) {
                            handleGameOver(false);
                            return; // éŠæˆ²çµæŸï¼Œç›´æ¥è·³å‡ºå‡½å¼
                        }
                        continue;
                    }
                } else if (dist > 0) {
                    e.x += (dx / dist) * e.speed;
                    e.y += (dy / dist) * e.speed;
                }

                // --- 5. è·¨æ³¢æ¬¡åˆ¤å®šä¿éšª ---
                // é›–ç„¶ updateWave æœƒç›£æ§ï¼Œä½†é€™è£¡æ”¾ä¸€å€‹ä¸»å‹•è§¸ç™¼é»èƒ½æ›´ç©©å®š
                if (enemies.length === 0) {
                    if (battleState.wave >= 20) {
                        handleGameOver(true);
                        return;
                    }
                }
            }
        }
        function updateWave() {
            if (!waveState.isWaiting) {
                waveState.timer++;

                // --- æ–°å¢ï¼šå‹•æ…‹è¨ˆç®—ç”Ÿæ€ªé€Ÿåº¦ ---
                // æ¯é 1 å±¤æ¸›å°‘ 1 å¹€é–“éš”ï¼Œæœ€å¿«ç¶­æŒåœ¨ 10 å¹€ç”Ÿä¸€éš» (å¯è‡ªè¡Œèª¿æ•´)
                let currentSpawnInterval = Math.max(10, 30 - Math.floor(battleState.wave) / 2);

                if (waveState.timer >= currentSpawnInterval) {
                    if (battleState.wave % 10 === 0 && waveState.spawnedCount === 0) {
                        spawnBoss();
                        waveState.spawnedCount = waveState.totalEnemiesPerWave;
                    }
                    else if (waveState.spawnedCount < waveState.totalEnemiesPerWave) {
                        spawnEnemy();
                        waveState.spawnedCount++;
                        waveState.timer = 0;
                    }
                    else if (enemies.length === 0) {
                        waveState.isWaiting = true;
                        waveState.timer = 0;
                    }
                }
            } else {
                waveState.timer++;
                // é€™è£¡ç¶­æŒ 60 å¹€ (ç´„ 1 ç§’) çš„éå ´ç­‰å¾…ï¼Œè®“ç©å®¶æœ‰æ™‚é–“å–˜å£æ°£åˆæˆéª°å­
                if (waveState.timer >= 120) {
                    if (battleState.wave >= 20) {
                        handleGameOver(true);
                        return;
                    }
                    battleState.wave++;
                    waveState.spawnedCount = 0;
                    waveState.totalEnemiesPerWave += 1;
                    waveState.isWaiting = false;
                    waveState.timer = 0;
                    updateUI();
                }
            }
        }

        // å°ˆé–€è™•ç†æ¯å¹€éƒ½è¦å³æ™‚è®Šå‹•çš„æ•¸å­—
        function updateLiveStats() {
            const spEl = document.getElementById('spText');
            const costEl = document.getElementById('summonCostText');
            const hpEl = document.getElementById('hpText');
            const waveEl = document.getElementById('waveText');

            if (spEl) spEl.innerText = Math.floor(battleState.sp);
            if (costEl) costEl.innerText = battleState.summonCost;
            if (hpEl) hpEl.innerText = battleState.hp;
            if (waveEl) waveEl.innerText = battleState.wave;

            // å³æ™‚æ›´æ–°å¼·åŒ–æŒ‰éˆ•çš„é‚Šæ¡†é¡è‰²ï¼ˆä¸é‡æ–°ç”Ÿæˆ HTMLï¼Œåªæ”¹ classï¼‰
            userData.deck.forEach(id => {
                const btn = document.querySelector(`button[onclick*="powerUpDice('${id}')"]`);
                if (!btn) return;

                const lv = powerUpLevels[id] || 1;
                const cost = 100 * Math.pow(2, lv - 1);
                const isMax = lv >= 5;

                // ç§»é™¤æ‰€æœ‰å¯èƒ½çš„é‚Šæ¡† class
                btn.classList.remove('border-blue-500', 'border-slate-700', 'border-yellow-500', 'shadow-[0_0_5px_rgba(234,179,8,0.3)]');

                // æ ¹æ“šç•¶å‰ç‹€æ…‹æ·»åŠ å°æ‡‰çš„ class
                if (isMax) {
                    btn.classList.add('border-yellow-500', 'shadow-[0_0_5px_rgba(234,179,8,0.3)]');
                } else if (battleState.sp >= cost) {
                    btn.classList.add('border-blue-500');
                } else {
                    btn.classList.add('border-slate-700');
                }
            });
        }

        // åªæœ‰åœ¨ã€Œå¼·åŒ–ç­‰ç´šæ”¹è®Šã€æˆ–ã€Œå¬å–šéª°å­ã€æ™‚æ‰å‘¼å«é€™å€‹
        function updateUI() {
            // å…ˆåŒæ­¥ä¸€æ¬¡æ•¸å­—
            updateLiveStats();

            const container = document.getElementById('powerUpButtons');
            if (!container) return;

            // 1. ç”¢ç”Ÿå¼·åŒ–æŒ‰éˆ•çš„ HTML
            container.innerHTML = userData.deck.map((id) => {
                const dice = ALL_DICES.find(d => d.id === id);
                const lv = powerUpLevels[id] || 1;
                const cost = 100 * Math.pow(2, lv - 1);
                const q = QUALITIES[dice.quality] || QUALITIES.common;

                // --- æ–°å¢åˆ¤æ–·é‚è¼¯ ---
                const isMax = lv >= 5;
                // æ»¿ç­‰é¡¯ç¤º MAXï¼Œå¦å‰‡é¡¯ç¤ºæ•¸å€¼ + SP
                const costDisplay = isMax ? "MAX" : `${cost >= 1000 ? (cost / 1000).toFixed(1) + 'k' : cost} SP`;
                // é¡è‰²èˆ‡é‚Šæ¡†å‹•æ…‹åˆ‡æ›
                const costColor = isMax ? "text-orange-500" : "text-slate-400";
                const borderColor = isMax ? "border-yellow-500 shadow-[0_0_5px_rgba(234,179,8,0.3)]" :
                    (battleState.sp >= cost ? 'border-blue-500' : 'border-slate-700');

                return `
        <button onclick="${isMax ? '' : `powerUpDice('${id}')`}" 
            class="flex-1 min-w-0 bg-slate-800 border ${borderColor} rounded-lg py-1.5 flex flex-col items-center ${isMax ? '' : 'active:scale-95'} transition-all">
            <div class="w-8 h-8 rounded bg-white relative mb-1 overflow-hidden" style="border: 1px solid ${q.color}">
                <canvas id="pwr-canvas-${id}" width="32" height="32" class="absolute inset-0 pointer-events-none"></canvas>
            </div>
            <div class="text-[9px] text-yellow-500 font-bold leading-none">Lv.${lv}</div>
            <div class="text-[8px] ${costColor} mt-1 font-bold tracking-tighter">${costDisplay}</div>
        </button>`;
            }).join('');

            // 2. ç¹ªè£½æŒ‰éˆ•ä¸Šçš„éª°å­åœ–æ¡ˆ (ç¶­æŒåŸæœ‰çš„ç•°æ­¥ç¹ªè£½é‚è¼¯)
            setTimeout(() => {
                userData.deck.forEach(id => {
                    const dice = ALL_DICES.find(d => d.id === id);
                    const canvas = document.getElementById(`pwr-canvas-${id}`);
                    if (canvas && dice) {
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        drawDiceFeature(ctx, 0, 0, canvas.width, dice.pattern || dice.id, dice.baseColor);
                        drawDiceStars(ctx, 0, 0, canvas.width, 1, dice.baseColor, dice.id);
                    }
                });
            }, 0);
        }
        let bgOffset = 0; // ç”¨æ–¼æ§åˆ¶ç¶²æ ¼ç§»å‹•çš„åç§»é‡

        function drawDynamicBackground(ctx, width, height) {
            // 1. ç¹ªè£½å‹•æ…‹ç¶²æ ¼
            bgOffset += 0.2; // æ§åˆ¶ç¶²æ ¼ç§»å‹•é€Ÿåº¦
            if (bgOffset > 40) bgOffset = 0;

            ctx.strokeStyle = 'rgba(56, 189, 248, 0.1)'; // æ·¡æ·¡çš„ç§‘æŠ€è—
            ctx.lineWidth = 1;
            const gridSize = 40;

            // å‚ç›´ç·š
            for (let x = (bgOffset % gridSize); x < width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }
            // æ°´å¹³ç·š
            for (let y = (bgOffset % gridSize); y < height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // 2. ç¹ªè£½å››å€‹è§’è½çš„è£é£¾æ€§å…‰æšˆ (ä¸éš¨ç¶²æ ¼ç§»å‹•)
            const time = Date.now() * 0.001;
            const pulse = Math.sin(time) * 10; // å‘¼å¸ç‡ˆæ•ˆæœ

            ctx.fillStyle = 'rgba(56, 189, 248, 0.05)';
            // å·¦ä¸Šè§’
            ctx.beginPath();
            ctx.arc(0, 0, 150 + pulse, 0, Math.PI * 2);
            ctx.fill();
            // å³ä¸‹è§’
            ctx.beginPath();
            ctx.arc(width, height, 200 + pulse, 0, Math.PI * 2);
            ctx.fill();
        }
        function refreshSunState() {
            const totalSunCount = grid.slots.filter(s => s.dice && s.dice.id === 'sun').length;
            isSunActivated = [1, 4, 7].includes(totalSunCount);
        }
        function startRenderLoop() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');

            let lastFrameTime = 0;
            let accumulatedTime = 0;
            let deltaTime = 0;
            const TARGET_FPS = 60;
            const TARGET_FRAME_TIME = 1000 / TARGET_FPS;

            function frame(currentTime) {
                if (!battleState.isStarted) return;
                const modal = document.getElementById('resultModal');
                if (modal && modal.style.display === 'flex') return;

                if (!lastFrameTime) lastFrameTime = currentTime;
                deltaTime = currentTime - lastFrameTime;
                lastFrameTime = currentTime;

                accumulatedTime += deltaTime;
                if (accumulatedTime > 200) accumulatedTime = 200;

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                while (accumulatedTime >= TARGET_FRAME_TIME) {
                    frameCount = (frameCount || 0) + 1;

                    // --- é‚è¼¯æ›´æ–° ---
                    updateEnemies();
                    updateWave();
                    updateCombat(); // å…§éƒ¨æœƒè¨ˆç®— dice.isBurst èˆ‡ dice.animScale
                    updateLiveStats();

                    accumulatedTime -= TARGET_FRAME_TIME;
                }

                // --- èƒŒæ™¯å±¤ ---
                drawDynamicBackground(ctx, canvas.width, canvas.height);
                drawEnhancedGridBase(ctx, grid);
                drawEnhancedPath(ctx, path);

                // --- å­å½ˆå±¤ ---
                projectiles.forEach(p => {
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                });

                // --- ç‰¹æ•ˆå±¤ ---
                drawVisualEffects(ctx);

                // --- æ•µäººå±¤ (å« Boss æ™ƒå‹•) ---
                enemies.forEach(e => {
                    const s = e.isBoss ? e.size : 20;
                    let renderX = e.x;
                    let renderY = e.y;

                    if (e.shakeTimer > 0) {
                        renderX += (Math.random() * 16 - 8);
                        renderY += (Math.random() * 16 - 8);
                    }

                    // --- è¡åˆºè¦–è¦ºæ•ˆæœ (SNAKE Boss æŠ€èƒ½) ---
                    if (e.isSprinting) {
                        ctx.save();
                        // ç¹ªè£½æ®˜å½±æ‹–å°¾
                        for (let trail = 3; trail > 0; trail--) {
                            ctx.globalAlpha = 0.15 * trail;
                            ctx.fillStyle = '#22c55e';
                            const trailOffset = trail * 8;
                            if (e.isBoss) {
                                ctx.beginPath();
                                ctx.arc(renderX - trailOffset * 0.5, renderY, s / 2, 0, Math.PI * 2);
                                ctx.fill();
                            } else {
                                ctx.fillRect(e.x - s / 2 - trailOffset, e.y - s / 2, s, s);
                            }
                        }
                        ctx.restore();

                        // ç¶ è‰²ç™¼å…‰æ•ˆæœ
                        ctx.save();
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = '#22c55e';
                    }

                    if (e.isBoss && e.bossType && BOSS_TYPES[e.bossType]) {
                        ctx.save();
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = e.color || BOSS_TYPES[e.bossType].color;
                        const bossImg = BOSS_TYPES[e.bossType].img;
                        if (bossImg && bossImg.complete && bossImg.naturalWidth !== 0) {
                            ctx.drawImage(bossImg, renderX - s / 2, renderY - s / 2, s, s);
                        } else {
                            ctx.fillStyle = e.color || "#ef4444";
                            ctx.beginPath();
                            ctx.arc(renderX, renderY, s / 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.restore();
                    } else {
                        ctx.fillStyle = e.isSprinting ? "#22c55e" : "#ef4444";
                        ctx.fillRect(e.x - s / 2, e.y - s / 2, s, s);
                    }

                    // çµæŸè¡åˆºç™¼å…‰
                    if (e.isSprinting) {
                        ctx.restore();
                    }

                    // è¡€æ¢èˆ‡ç‹€æ…‹åœ–ç¤º
                    const barX = e.isBoss ? renderX : e.x;
                    const barY = e.isBoss ? renderY : e.y;
                    ctx.fillStyle = "rgba(0,0,0,0.5)";
                    ctx.fillRect(barX - 15, barY - (s / 2 + 8), 30, 3);
                    ctx.fillStyle = e.isBoss ? "#f1c40f" : "#22c55e";
                    ctx.fillRect(barX - 15, barY - (s / 2 + 8), (e.hp / e.maxHp) * 30, 3);

                    let iconOffset = 0;
                    if (e.iceTimer > 0) { drawStatusIcon(ctx, barX - 10 + iconOffset, barY - s / 2 - 20, 'â„ï¸'); iconOffset += 15; }
                    if (e.speed === 0 && e.hp > 0) { drawStatusIcon(ctx, barX - 10 + iconOffset, barY - s / 2 - 20, 'ğŸ”’'); iconOffset += 15; }
                    if (e.poisonStacks > 0) { drawStatusIcon(ctx, barX - 10 + iconOffset, barY - s / 2 - 20, 'â˜ ï¸'); iconOffset += 15; }
                    if (e.vulnerability) { drawStatusIcon(ctx, barX - 10 + iconOffset, barY - s / 2 - 20, 'ğŸ’”'); }
                });

                // --- å‚·å®³å½ˆå‡ºå±¤ ---
                for (let i = damagePopups.length - 1; i >= 0; i--) {
                    let d = damagePopups[i];
                    ctx.save();
                    ctx.fillStyle = `rgba(255, 255, 255, ${d.life / 30})`;
                    ctx.font = "bold 14px Arial";
                    ctx.textAlign = "center";
                    ctx.fillText(d.val, d.x, d.y);
                    ctx.restore();
                    d.y -= 1; d.life--;
                    if (d.life <= 0) damagePopups.splice(i, 1);
                }

                // --- éª°å­å±¤ (æ•´åˆå¼·é¢¨è¦–è¦º) ---
                grid.slots.forEach(slot => {
                    if (slot.dice && !slot.isBeingDragged) {
                        // åº•å±¤ç‰¹æ•ˆ
                        if (slot.dice.id === 'sun' && isSunActivated) {
                            ctx.save();
                            ctx.setLineDash([5, 5]);
                            ctx.strokeStyle = "orange";
                            ctx.lineWidth = 3;
                            ctx.strokeRect(slot.x + 4, slot.y + 4, grid.slotSize - 8, grid.slotSize - 8);
                            ctx.restore();
                        }
                        if (slot.dice.id === 'gear' && slot.dice.isPowered) {
                            drawEffect(slot, "#00ccff");
                            drawGearConnections(ctx, slot);
                        }

                        // å¼·é¢¨è®Šè‰²é‚è¼¯
                        const overrideColor = (slot.dice.id === 'mighty_wind' && slot.dice.isBurst) ? "#ffffff" : null;

                        // å‘¼å«æ•´åˆå¾Œçš„ renderDice
                        renderDice(ctx, slot.x, slot.y, slot.dice, slot.isLocked, overrideColor);
                    }
                });

                // --- æ‹–æ‹½å±¤ ---
                if (drag.isDragging) {
                    renderDice(ctx, drag.currentX - grid.slotSize / 2, drag.currentY - grid.slotSize / 2, drag.dice, false);
                }

                requestAnimationFrame(frame);
            }
            requestAnimationFrame(frame);
        }

        // ---ç§»æ¤è‡ª dice_cooper.html çš„å‚³é€é–€ç¹ªè£½å‡½å¼---
        function drawPortal(ctx, x, y, color, angle, isStart) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);

            // å¤–åœˆå…‰ç’°
            const gradient = ctx.createRadialGradient(0, 0, 10, 0, 0, 30);
            gradient.addColorStop(0, color);
            gradient.addColorStop(1, 'rgba(0,0,0,0)');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, 30, 0, Math.PI * 2);
            ctx.fill();

            // æ—‹è½‰ç´‹è·¯
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            for (let i = 0; i < 4; i++) {
                ctx.rotate(Math.PI / 2);
                ctx.beginPath();
                ctx.moveTo(10, 0);
                ctx.quadraticCurveTo(20, 10, 25, 0);
                ctx.stroke();
            }

            // ä¸­å¿ƒé»‘æ´/äº®é»
            ctx.fillStyle = isStart ? '#000' : '#fff';
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // --- æ–°å¢ï¼šç¹ªè£½å„ç¨®ç¬æ™‚è¦–è¦ºç‰¹æ•ˆ ---
        function drawVisualEffects(ctx) {
            for (let i = visualEffects.length - 1; i >= 0; i--) {
                const fx = visualEffects[i];
                fx.life--;
                if (fx.life <= 0) {
                    visualEffects.splice(i, 1);
                    continue;
                }

                ctx.save();
                if (fx.type === 'lightning') {
                    // é–ƒé›»ï¼šç•«å¤šæ®µæŠ˜ç·š
                    ctx.strokeStyle = '#fde047'; // é»ƒè‰²
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 5;
                    ctx.shadowColor = '#fde047';
                    ctx.beginPath();
                    ctx.moveTo(fx.start.x, fx.start.y);

                    const steps = 5;
                    const dx = (fx.end.x - fx.start.x) / steps;
                    const dy = (fx.end.y - fx.start.y) / steps;

                    for (let j = 1; j < steps; j++) {
                        const offset = (Math.random() - 0.5) * 20; // åç§»é‡
                        ctx.lineTo(
                            fx.start.x + dx * j + (Math.random() - 0.5) * 10,
                            fx.start.y + dy * j + (Math.random() - 0.5) * 10
                        );
                    }
                    ctx.lineTo(fx.end.x, fx.end.y);
                    ctx.stroke();
                }
                else if (fx.type === 'explosion') {
                    // çˆ†ç‚¸ï¼šæ“´æ•£åœ“åœˆ
                    const progress = 1 - (fx.life / fx.maxLife); // 0 -> 1
                    ctx.beginPath();
                    ctx.arc(fx.x, fx.y, fx.radius * progress, 0, Math.PI * 2);
                    ctx.fillStyle = fx.color || 'orange';
                    ctx.globalAlpha = 1 - progress;
                    ctx.fill();

                    // è¡æ“Šæ³¢é‚Šæ¡†
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                else if (fx.type === 'laser') {
                    // é›·å°„ï¼šç›´ç·šå…‰æŸ
                    ctx.beginPath();
                    ctx.moveTo(fx.start.x, fx.start.y);
                    ctx.lineTo(fx.end.x, fx.end.y);
                    ctx.strokeStyle = fx.color || '#ff0000';
                    ctx.lineWidth = 3 + Math.sin(Date.now() / 50) * 1; // è„ˆè¡å¯¬åº¦
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = fx.color || '#ff0000';
                    ctx.lineCap = 'round';
                    ctx.stroke();

                    // æ“Šä¸­é»å…‰æšˆ
                    ctx.beginPath();
                    ctx.arc(fx.end.x, fx.end.y, 6, 0, Math.PI * 2);
                    ctx.fillStyle = '#fff';
                    ctx.fill();
                }
                ctx.restore();
            }
        }

        // --- æ–°å¢ï¼šç¹ªè£½ç‹€æ…‹å°åœ–ç¤º ---
        function drawStatusIcon(ctx, x, y, text) {
            ctx.save();
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#000';
            ctx.shadowBlur = 2;
            ctx.fillStyle = '#fff';
            ctx.fillText(text, x, y);
            ctx.restore();
        }

        // --- æ–°å¢ï¼šç¹ªè£½é½’è¼ªé€£ç·š ---
        function drawGearConnections(ctx, slot) {
            // åªç•«å‘å³å’Œå‘ä¸‹çš„é€£ç·šï¼Œé¿å…é‡è¤‡ç¹ªè£½
            const idx = grid.slots.indexOf(slot);
            if (idx === -1) return;

            const col = idx % grid.cols;
            const row = Math.floor(idx / grid.cols);

            // å³é‚Šé„°å±…
            if (col < grid.cols - 1) {
                const rightSlot = grid.slots[idx + 1];
                if (rightSlot.dice && rightSlot.dice.id === 'gear') {
                    drawGearLine(ctx, slot, rightSlot);
                }
            }
            // ä¸‹æ–¹é„°å±…
            if (row < grid.rows - 1) {
                const downSlot = grid.slots[idx + grid.cols];
                if (downSlot.dice && downSlot.dice.id === 'gear') {
                    drawGearLine(ctx, slot, downSlot);
                }
            }
        }

        function drawGearLine(ctx, a, b) {
            ctx.save();
            ctx.strokeStyle = '#94a3b8'; // éµç°è‰²
            ctx.lineWidth = 6;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(a.x + grid.slotSize / 2, a.y + grid.slotSize / 2);
            ctx.lineTo(b.x + grid.slotSize / 2, b.y + grid.slotSize / 2);
            ctx.stroke();

            // äº®èŠ¯
            ctx.strokeStyle = '#e2e8f0';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();
        }

        // A. ç¹ªè£½ç™¼å…‰è»Œé“èˆ‡èµ·çµ‚é»
        function drawEnhancedPath(ctx, path) {
            if (!path || path.length < 2) return;

            ctx.save();
            // 1. ç™¼å…‰åº•å±¤
            ctx.beginPath();
            ctx.strokeStyle = "rgba(59, 130, 246, 0.2)"; // æ·¡æ·¡è—å…‰
            ctx.lineWidth = 35;
            ctx.lineJoin = "round";
            ctx.lineCap = "round";
            ctx.moveTo(path[0].x, path[0].y);
            path.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.stroke();

            // 2. è»Œé“ä¸­å¿ƒç·š (ç§‘æŠ€æ„Ÿè™›ç·š)
            ctx.beginPath();
            ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 20]);
            ctx.moveTo(path[0].x, path[0].y);
            path.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.stroke();
            ctx.setLineDash([]);

            // 3. èµ·é»ï¼šå‚³é€é–€ (Portal) - ä½¿ç”¨æ–°æ¨£å¼
            const start = path[0];
            const angle = (Date.now() / 1000) % (Math.PI * 2);
            drawPortal(ctx, start.x, start.y, '#3b82f6', angle, true);


            // 4. çµ‚é»ï¼šæ ¸å¿ƒ (Core)
            const end = path[path.length - 1];
            const pulse = 0.5 + Math.abs(Math.sin(Date.now() / 400)) * 0.5;
            ctx.fillStyle = `rgba(239, 68, 68, ${pulse * 0.5})`;
            ctx.fillRect(end.x - 15, end.y - 15, 30, 30);
            ctx.strokeStyle = "#ef4444";
            ctx.lineWidth = 2;
            ctx.strokeRect(end.x - 15, end.y - 15, 30, 30);

            ctx.restore();
        }

        // B. ç¹ªè£½ 3x5 å€åŸŸçš„å‡¹æ§½èˆ‡å››è§’ L é‚Šæ¡†
        function drawEnhancedGridBase(ctx, grid) {
            const margin = 10;
            const left = grid.slots[0].x - margin;
            const top = grid.slots[0].y - margin;
            const right = grid.slots[grid.cols - 1].x + grid.slotSize + margin;
            const bottom = grid.slots[grid.slots.length - 1].y + grid.slotSize + margin;
            const LSize = 20;

            // 1. ç¹ªè£½å››è§’ L é‚Šæ¡†
            ctx.strokeStyle = "#3b82f6";
            ctx.lineWidth = 3;
            // å·¦ä¸Š
            ctx.beginPath(); ctx.moveTo(left, top + LSize); ctx.lineTo(left, top); ctx.lineTo(left + LSize, top); ctx.stroke();
            // å³ä¸Š
            ctx.beginPath(); ctx.moveTo(right - LSize, top); ctx.lineTo(right, top); ctx.lineTo(right, top + LSize); ctx.stroke();
            // å·¦ä¸‹
            ctx.beginPath(); ctx.moveTo(left, bottom - LSize); ctx.lineTo(left, bottom); ctx.lineTo(left + LSize, bottom); ctx.stroke();
            // å³ä¸‹
            ctx.beginPath(); ctx.moveTo(right - LSize, bottom); ctx.lineTo(right, bottom); ctx.lineTo(right, bottom - LSize); ctx.stroke();

            // 2. ç¹ªè£½æ ¼å­çš„å‡¹æ§½èƒŒæ™¯
            grid.slots.forEach(slot => {
                // æ·±è‰²èƒŒæ™¯
                ctx.fillStyle = "rgba(15, 23, 42, 0.8)";
                drawRoundedRect(ctx, slot.x + 2, slot.y + 2, grid.slotSize - 4, grid.slotSize - 4, 10);
                ctx.fill();

                // å…§é™°å½±
                ctx.strokeStyle = "rgba(0, 0, 0, 0.6)";
                ctx.lineWidth = 1;
                ctx.stroke();
            });
        }
        function drawDiceFeature(ctx, x, y, size, pattern, diceColor) {
            if (!pattern) return;

            const m = size / 2;
            ctx.save();
            ctx.translate(x, y);

            const r = parseInt(diceColor.slice(1, 3), 16);
            const g = parseInt(diceColor.slice(3, 5), 16);
            const b = parseInt(diceColor.slice(5, 7), 16);
            ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.8)`; // ç¨å¾®åŠ æ·±ä¸€é»é»ï¼Œæ›´æ˜é¡¯
            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.3)`;
            ctx.lineWidth = 4;
            ctx.lineCap = "round";
            ctx.lineJoin = "round";

            switch (pattern) {
                // --- Common ---
                case 'fire':
                    ctx.beginPath();
                    ctx.moveTo(m, size * 0.2); ctx.lineTo(size * 0.8, size * 0.8); ctx.lineTo(size * 0.2, size * 0.8);
                    ctx.closePath(); ctx.stroke(); ctx.fill();
                    break;
                case 'ice':
                    ctx.beginPath(); ctx.arc(m, m, size * 0.35, 0, Math.PI * 2);
                    ctx.moveTo(m, size * 0.1); ctx.lineTo(m, size * 0.9);
                    ctx.moveTo(size * 0.1, m); ctx.lineTo(size * 0.9, m);
                    ctx.stroke();
                    break;
                case 'wind':
                    ctx.beginPath();
                    for (let i = -1; i <= 1; i++) {
                        ctx.moveTo(size * 0.2, m + (i * 12)); ctx.lineTo(size * 0.8, m + (i * 12));
                    }
                    ctx.stroke();
                    break;
                case 'electric':
                    ctx.beginPath();
                    ctx.moveTo(m + 5, size * 0.15); ctx.lineTo(m - 10, m + 5);
                    ctx.lineTo(m + 10, m - 5); ctx.lineTo(m - 5, size * 0.85);
                    ctx.stroke();
                    break;
                case 'poison':
                    ctx.beginPath();
                    ctx.moveTo(m, size * 0.2); ctx.lineTo(size * 0.75, m);
                    ctx.lineTo(m, size * 0.8); ctx.lineTo(size * 0.25, m);
                    ctx.closePath(); ctx.stroke(); ctx.fill();
                    break;

                // --- Rare & Epic ---
                case 'switch': // æ›ä½ï¼šå·¦å³å¾ªç’°äº’æ›ç®­é ­
                    ctx.beginPath();
                    // å·¦ç®­é ­
                    ctx.moveTo(size * 0.3, size * 0.4);
                    ctx.lineTo(size * 0.7, size * 0.4);
                    ctx.lineTo(size * 0.6, size * 0.3);
                    // å³ç®­é ­
                    ctx.moveTo(size * 0.7, size * 0.6);
                    ctx.lineTo(size * 0.3, size * 0.6);
                    ctx.lineTo(size * 0.4, size * 0.7);
                    ctx.stroke();
                    // ä¸­å¿ƒè£é£¾é»
                    ctx.beginPath();
                    ctx.arc(m, m, 3, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'laser_beam': // é›·å°„ï¼šç§‘æŠ€æ„Ÿåå­—æº–æ˜Ÿ + è„ˆè¡å…‰ç’°
                    // 1. å¤–åœˆæ—‹è½‰å…‰ç’°
                    ctx.save();
                    ctx.translate(m, m);
                    ctx.rotate(Date.now() / 500);
                    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.4)`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.35, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();

                    // 2. ä¸­å¿ƒåå­—ç·š (æº–æ˜Ÿ)
                    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.8)`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(m - size * 0.2, m); ctx.lineTo(m + size * 0.2, m);
                    ctx.moveTo(m, m - size * 0.2); ctx.lineTo(m, m + size * 0.2);
                    ctx.stroke();

                    // 3. å››å€‹è§’è½å®šä½é»
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.6)`;
                    const corners = [
                        [size * 0.15, size * 0.15],
                        [size * 0.85, size * 0.15],
                        [size * 0.15, size * 0.85],
                        [size * 0.85, size * 0.85]
                    ];
                    corners.forEach(([cx, cy]) => {
                        ctx.beginPath();
                        ctx.arc(cx, cy, 2, 0, Math.PI * 2);
                        ctx.fill();
                    });

                    // 4. ä¸­å¿ƒç™¼å…‰é»
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.9)`;
                    ctx.beginPath();
                    ctx.arc(m, m, size * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'lock': // é–å®šï¼šæ–¹æ¡†ä¸­å¸¶ä¸€å€‹åœ“é»
                    ctx.strokeRect(size * 0.25, size * 0.25, size * 0.5, size * 0.5);
                    ctx.beginPath(); ctx.arc(m, m, 4, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'teleport': // å‚³é€ï¼šå…©å€‹æ¼©æ¸¦æ‹¬è™Ÿ
                    ctx.beginPath();
                    ctx.arc(size * 0.3, m, size * 0.3, -Math.PI / 2, Math.PI / 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(size * 0.7, m, size * 0.3, Math.PI / 2, -Math.PI / 2);
                    ctx.stroke();
                    break;
                case 'gear': // é½’è¼ªï¼šå¤–åœˆå…«å€‹é½’ï¼ˆç”¨è™›ç·šæ¨¡æ“¬ï¼‰
                    ctx.beginPath();
                    ctx.setLineDash([5, 5]);
                    ctx.arc(m, m, size * 0.35, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]); // æ¢å¾©å¯¦ç·š
                    ctx.beginPath(); ctx.arc(m, m, size * 0.15, 0, Math.PI * 2); ctx.stroke();
                    break;
                case 'gamble': // è³­åšï¼šä¸­å¤®éŒ¢å¹£ + éš¨æ©Ÿé–ƒçˆæ˜Ÿ
                    // 1. ä¸­å¤®å¤§åœ“ (éŒ¢å¹£)
                    ctx.beginPath();
                    ctx.arc(m, m, size * 0.25, 0, Math.PI * 2);
                    ctx.stroke();
                    // 2. éŒ¢å¹£å…§çš„ $ ç¬¦è™Ÿ
                    ctx.font = `bold ${size * 0.25}px Arial`;
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.5)`;
                    ctx.fillText("$", m, m);
                    // 3. å››å‘¨çš„å°é–ƒçˆæ˜Ÿ
                    const stars = [[0.2, 0.2], [0.8, 0.2], [0.2, 0.8], [0.8, 0.8]];
                    stars.forEach(([sx, sy], i) => {
                        // ç°¡å–®çš„åå­—é–ƒçˆï¼Œåˆ©ç”¨æ™‚é–“ç”¢ç”Ÿè¼ªæµé–ƒçˆæ„Ÿ
                        if ((Math.floor(Date.now() / 300) + i) % 4 === 0) {
                            ctx.beginPath();
                            ctx.moveTo(size * sx - 4, size * sy);
                            ctx.lineTo(size * sx + 4, size * sy);
                            ctx.moveTo(size * sx, size * sy - 4);
                            ctx.lineTo(size * sx, size * sy + 4);
                            ctx.stroke();
                        }
                    });
                    break;

                // --- Legend ---
                case 'nut': // ç‡Ÿé¤Šï¼šé›™é‡å‘ä¸Šç®­é ­ (è±¡å¾µç›´æ¥å‡æ˜Ÿ)
                    ctx.lineWidth = 3;
                    for (let i = 0; i < 2; i++) {
                        const offset = i * size * 0.2;
                        ctx.beginPath();
                        ctx.moveTo(m, size * 0.8 - offset);
                        ctx.lineTo(m, size * 0.4 - offset);
                        ctx.lineTo(m - size * 0.15, size * 0.55 - offset);
                        ctx.moveTo(m, size * 0.4 - offset);
                        ctx.lineTo(m + size * 0.15, size * 0.55 - offset);
                        ctx.stroke();
                    }
                    // åº•éƒ¨è‘‰å­ç‹€è£é£¾ (ç‡Ÿé¤Šæ„Ÿè¦º)
                    ctx.beginPath();
                    ctx.moveTo(size * 0.3, size * 0.8);
                    ctx.quadraticCurveTo(m, size * 0.9, size * 0.7, size * 0.8);
                    ctx.stroke();
                    break;
                case 'mighty_wind': // å¼·é¢¨ï¼šå¤šé‡æ°£æµç·šæ¢
                    ctx.beginPath();
                    for (let i = -1; i <= 1; i++) {
                        ctx.moveTo(size * 0.2, m + i * size * 0.15);
                        ctx.bezierCurveTo(m, m + i * size * 0.4, m, m - i * size * 0.4, size * 0.8, m + i * size * 0.15);
                    }
                    ctx.stroke();
                    break;

                // --- è–åŸŸ (Sanctuary) å…‰ç’°åœ“åœˆ ---
                case 'sanctuary':
                    // 1. å¤–åœˆå…‰ç’°
                    ctx.beginPath();
                    ctx.arc(m, m, size * 0.35, 0, Math.PI * 2);
                    ctx.stroke();
                    // 2. ä¸­åœˆå…‰ç’°
                    ctx.beginPath();
                    ctx.arc(m, m, size * 0.25, 0, Math.PI * 2);
                    ctx.stroke();
                    // 3. ä¸­å¿ƒåå­—
                    ctx.beginPath();
                    ctx.moveTo(m - size * 0.1, m); ctx.lineTo(m + size * 0.1, m);
                    ctx.moveTo(m, m - size * 0.1); ctx.lineTo(m, m + size * 0.1);
                    ctx.stroke();
                    // 4. å››å€‹å…‰é»
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.6)`;
                    [0, 90, 180, 270].forEach(angle => {
                        const rad = angle * Math.PI / 180;
                        const px = m + Math.cos(rad) * size * 0.3;
                        const py = m + Math.sin(rad) * size * 0.3;
                        ctx.beginPath();
                        ctx.arc(px, py, size * 0.04, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    break;

                // --- å½—æ˜Ÿ (Comet) å½—æ˜Ÿæ‹–å°¾ ---
                case 'comet':
                    // 1. å½—æ˜Ÿæœ¬é«”
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.8)`;
                    ctx.beginPath();
                    ctx.arc(size * 0.65, size * 0.35, size * 0.12, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    // 2. æ‹–å°¾ï¼ˆä¸‰æ¢æµå…‰ï¼‰
                    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.5)`;
                    for (let i = -1; i <= 1; i++) {
                        ctx.beginPath();
                        ctx.moveTo(size * 0.65, size * 0.35);
                        ctx.quadraticCurveTo(
                            size * 0.4, size * 0.5 + i * size * 0.1,
                            size * 0.15, size * 0.7 + i * size * 0.15
                        );
                        ctx.stroke();
                    }
                    // 3. å°¾éƒ¨æ˜Ÿé»
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.4)`;
                    [[0.3, 0.55], [0.2, 0.65], [0.15, 0.75]].forEach(([px, py]) => {
                        ctx.beginPath();
                        ctx.arc(size * px, size * py, size * 0.03, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    break;

                // --- é€£é– (Chain) é–ƒé›»éˆ ---
                case 'chain':
                    // ä¸‰å€‹ç›®æ¨™é»
                    const chainPoints = [
                        [size * 0.2, size * 0.25],
                        [size * 0.5, size * 0.65],
                        [size * 0.8, size * 0.35]
                    ];
                    // ç¹ªè£½é–ƒé›»é€£ç·š
                    ctx.lineWidth = 2.5;
                    for (let i = 0; i < chainPoints.length - 1; i++) {
                        const [x1, y1] = chainPoints[i];
                        const [x2, y2] = chainPoints[i + 1];
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        // é‹¸é½’æ•ˆæœ
                        const segments = 3;
                        for (let s = 1; s <= segments; s++) {
                            const t = s / segments;
                            const mx = x1 + (x2 - x1) * t;
                            const my = y1 + (y2 - y1) * t;
                            const offset = (s % 2 === 0 ? 1 : -1) * size * 0.08;
                            ctx.lineTo(mx + offset, my);
                        }
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                    // ç¹ªè£½ç›®æ¨™é»
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.7)`;
                    chainPoints.forEach(([px, py]) => {
                        ctx.beginPath();
                        ctx.arc(px, py, size * 0.06, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    break;

                // --- æ¯€æ»… (Doom) æœ«æ—¥æ™‚é˜ ---
                case 'doom':
                    // 1. æ™‚é˜å¤–åœˆ
                    ctx.beginPath();
                    ctx.arc(m, m, size * 0.35, 0, Math.PI * 2);
                    ctx.stroke();
                    // 2. 12é»åˆ»åº¦
                    [0, 90, 180, 270].forEach(angle => {
                        const rad = angle * Math.PI / 180 - Math.PI / 2;
                        const x1 = m + Math.cos(rad) * size * 0.3;
                        const y1 = m + Math.sin(rad) * size * 0.3;
                        const x2 = m + Math.cos(rad) * size * 0.35;
                        const y2 = m + Math.sin(rad) * size * 0.35;
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    });
                    // 3. æŒ‡é‡ï¼ˆæŒ‡å‘12é» - æ­»äº¡è±¡å¾µï¼‰
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.9)`;
                    ctx.beginPath();
                    ctx.moveTo(m, m);
                    ctx.lineTo(m, m - size * 0.25);
                    ctx.stroke();
                    // 4. ä¸­å¿ƒé»
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.8)`;
                    ctx.beginPath();
                    ctx.arc(m, m, size * 0.06, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'joker': // å°ä¸‘ï¼šå€’ä¸‰è§’å½¢åŠ ä¸Šä¸Šæ–¹å…©é»
                    ctx.beginPath();
                    ctx.moveTo(size * 0.2, size * 0.3); ctx.lineTo(size * 0.8, size * 0.3);
                    ctx.lineTo(m, size * 0.8); ctx.closePath(); ctx.stroke();
                    ctx.beginPath(); ctx.arc(size * 0.35, size * 0.2, 3, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(size * 0.65, size * 0.2, 3, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'growth': // æˆé•·ï¼šå‘ä¸Šçš„ç®­é ­
                    ctx.beginPath();
                    ctx.moveTo(m, size * 0.15); ctx.lineTo(m, size * 0.85);
                    ctx.moveTo(m, size * 0.15); ctx.lineTo(size * 0.3, size * 0.4);
                    ctx.moveTo(m, size * 0.15); ctx.lineTo(size * 0.7, size * 0.4);
                    ctx.stroke();
                    break;
                case 'sun': // å¤ªé™½ï¼šåœ“å½¢æ”¾å°„ç‹€ (å„ªåŒ–ç‰ˆï¼šç¸®å°å°„ç·šç¯„åœï¼Œé¿é–‹æ˜Ÿæ•¸é»é»)
                    // 1. ä¸­å¿ƒåœ“ç¸®å°ä¸€é»é»
                    ctx.beginPath();
                    ctx.arc(m, m, size * 0.15, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.fill();

                    // 2. å°„ç·šèª¿æ•´ï¼šç¸®çŸ­é•·åº¦ï¼Œä¸¦å°‡ç·šæ¢è®Šç´°ï¼Œé¿å…å¹²æ“¾
                    ctx.lineWidth = 2; // å°„ç·šç”¨ç´°ç·š
                    for (let i = 0; i < 8; i++) {
                        ctx.save();
                        ctx.translate(m, m);
                        // æ—‹è½‰ 22.5 åº¦ (Math.PI / 8)ï¼Œè®“å°„ç·šéŒ¯é–‹æ­£æ–¹å½¢çš„å››è§’èˆ‡æ­£ä¸­å¿ƒ
                        ctx.rotate((i * Math.PI / 4) + (Math.PI / 8));
                        ctx.beginPath();
                        // å°„ç·šå¾ä¸­å¿ƒ 0.22 å»¶ä¼¸åˆ° 0.32ï¼Œç¢ºä¿å®ƒç•™åœ¨éª°å­ä¸­é–“å€åŸŸï¼Œä¸ç¢°åˆ°é‚Šç·£çš„æ˜Ÿé»
                        ctx.moveTo(0, -size * 0.22);
                        ctx.lineTo(0, -size * 0.32);
                        ctx.stroke();
                        ctx.restore();
                    }
                    // æ¢å¾©åŸå§‹ç·šå¯¬ä¾›å¾ŒçºŒåœ–å½¢ä½¿ç”¨
                    ctx.lineWidth = 4;
                    break;

                // --- Mythic ---
                case 'galaxy': // éŠ€æ²³ï¼šæ—‹æ¸¦ç‹€ S å‹
                    ctx.beginPath();
                    ctx.moveTo(m, size * 0.1);
                    ctx.bezierCurveTo(size * 0.9, size * 0.1, size * 0.1, size * 0.9, m, size * 0.9);
                    ctx.stroke();
                    ctx.beginPath(); ctx.arc(m, m, size * 0.1, 0, Math.PI * 2); ctx.fill();
                    break;
                // --- æ˜“å‚· (Crack) å¤–è§€ï¼šç¢è£‚æ°´æ™¶æ•ˆæœ ---
                case 'crack':
                    // 1. ä¸­å¿ƒçˆ†è£‚é»
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.5)`;
                    ctx.beginPath();
                    ctx.arc(m, m, size * 0.12, 0, Math.PI * 2);
                    ctx.fill();

                    // 2. å¤šæ–¹å‘è£‚ç´‹æ“´æ•£
                    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.7)`;
                    ctx.lineWidth = 2.5;
                    const crackAngles = [0, 45, 90, 135, 180, 225, 270, 315];
                    crackAngles.forEach(angle => {
                        const rad = angle * Math.PI / 180;
                        const x1 = m + Math.cos(rad) * size * 0.12;
                        const y1 = m + Math.sin(rad) * size * 0.12;
                        const x2 = m + Math.cos(rad) * size * 0.42;
                        const y2 = m + Math.sin(rad) * size * 0.42;

                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    });

                    // 3. å¤–åœç¢ç‰‡é»ç¶´
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.4)`;
                    [0.1, 0.25, 0.75, 0.9].forEach(ratio => {
                        ctx.beginPath();
                        ctx.arc(size * ratio, size * 0.15, 1.5, 0, Math.PI * 2);
                        ctx.arc(size * ratio, size * 0.85, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    break;

                // --- ç¤¦å±± (Mine) å¤–è§€ï¼šä¸€å€‹ T å­—å‹çš„é¬é ­ ---
                case 'mine':
                    ctx.beginPath();
                    // é¬é ­çš„å¼§å½¢é‡‘å±¬éƒ¨åˆ†
                    ctx.moveTo(size * 0.25, size * 0.35);
                    ctx.quadraticCurveTo(m, size * 0.15, size * 0.75, size * 0.35);
                    ctx.stroke();
                    // é¬é ­çš„æœ¨æŸ„
                    ctx.beginPath();
                    ctx.moveTo(m, size * 0.25);
                    ctx.lineTo(m, size * 0.75);
                    ctx.stroke();
                    // è£é£¾ä¸€å€‹å°éŒ¢å¹£åœ“é»
                    ctx.beginPath();
                    ctx.arc(m + size * 0.15, size * 0.7, size * 0.08, 0, Math.PI * 2);
                    ctx.fill(); ctx.stroke();
                    break;
            }
            ctx.restore();
        }
        function drawDiceStars(ctx, x, y, size, stars, diceColor, diceId) {
            const db = ALL_DICES.find(d => d.id === diceId);
            const quality = db ? db.quality : 'common';

            // --- è™•ç† 7 æ˜Ÿå¤§æ˜Ÿæ˜Ÿçš„é¡è‰² ---
            if (stars >= 7) {
                ctx.save();

                let starColor = "#fbbf24"; // é è¨­é‡‘è‰²

                if (quality === 'mythic') {
                    // ç¥è©±ç´š 7 æ˜Ÿï¼šå¤§æ˜Ÿæ˜Ÿä¹Ÿè¦è™¹å½©é–ƒçˆï¼
                    const hue = (Date.now() / 10) % 360;
                    starColor = `hsl(${hue}, 80%, 60%)`;
                } else if (quality === 'epic') {
                    starColor = "#c084fc"; // å²è©© 7 æ˜Ÿå¯ä»¥ç”¨ç´«è‰²å¤§æ˜Ÿæ˜Ÿï¼Œæˆ–è€…ç¶­æŒé‡‘è‰²
                }

                ctx.fillStyle = starColor;
                ctx.font = `bold ${size * 0.4}px Arial`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";

                // å¢åŠ ä¸€å€‹ç™¼å…‰é™°å½±è®“ç¥è©±å¤§æ˜Ÿæ˜Ÿæ›´éœ¸æ°£
                if (quality === 'mythic') {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = starColor;
                }

                ctx.fillText("â˜…", x + size / 2, y + size / 2 + size * 0.05);
                ctx.restore();
                return;
            }

            // --- è™•ç† 1-6 æ˜Ÿé»é»çš„é¡è‰² ---
            let dotColor = diceColor || "#333";

            switch (quality) {
                case 'rare': dotColor = "#60a5fa"; break;
                case 'epic': dotColor = "#c084fc"; break;
                case 'legend': dotColor = "#fbbf24"; break;
                case 'mythic':
                    const hue = (Date.now() / 10) % 360;
                    dotColor = `hsl(${hue}, 80%, 60%)`;
                    break;
                default: dotColor = "#333"; break; // æ”¹ç‚ºæ·±ç°è‰²ï¼Œé¿å…åœ¨ç™½è‰²èƒŒæ™¯ä¸Šçœ‹ä¸è¦‹
            }

            ctx.fillStyle = dotColor;

            // --- ç¹ªè£½ 1-6 é¡†é»é»çš„é‚è¼¯ (ç¶­æŒä¸è®Š) ---
            const dotSize = size * 0.07;
            const p = size * 0.22;
            const m = size / 2;
            const l = p, r = size - p;
            const t = p, b = size - p;

            let dots = [];
            if (stars === 1) dots = [[m, m]];
            else if (stars === 2) dots = [[l, t], [r, b]];
            else if (stars === 3) dots = [[l, t], [m, m], [r, b]];
            else if (stars === 4) dots = [[l, t], [r, t], [l, b], [r, b]];
            else if (stars === 5) dots = [[l, t], [r, t], [m, m], [l, b], [r, b]];
            else if (stars === 6) dots = [[l, t], [r, t], [l, m], [r, m], [l, b], [r, b]];

            dots.forEach(dot => {
                ctx.beginPath();
                ctx.arc(x + dot[0], y + dot[1], dotSize, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // --- ç´”ç²¹è£é£¾ç‰ˆï¼šé«˜å“è³ªéœæ…‹é‚Šæ¡† (å¼·èª¿è¨­è¨ˆæ„Ÿèˆ‡éšç´šå·®ç•°) ---
        function drawQualityBorder(ctx, x, y, size, diceId) {
            if (!diceId || size < 1) return;

            // ç‚ºäº†æ•ˆèƒ½ï¼Œæˆ‘å€‘é€™è£¡ç°¡å–®è®€å–
            // å¯¦éš›å°ˆæ¡ˆä¸­å»ºè­°æŠŠ quality å±¬æ€§ç›´æ¥å‚³é€²ä¾†ï¼Œä¸ç”¨æ¯æ¬¡ find
            const db = ALL_DICES.find(d => d.id === diceId);
            if (!db) return;
            const quality = db.quality;
            if (quality !== 'legend' && quality !== 'mythic') return;

            // åŸºç¤åƒæ•¸
            const lw = Math.max(1.5, size * 0.05); // ç·šå¯¬

            // å…§å»ºç¹ªåœ–å·¥å…·ï¼šç•«åœ“è§’è·¯å¾‘ (ä¸strokeä¹Ÿä¸fillï¼Œåªå»ºç«‹è·¯å¾‘)
            function pathRound(cx, cy, w, h, r) {
                if (w < 2 * r) r = w / 2; if (h < 2 * r) r = h / 2;
                ctx.beginPath();
                ctx.moveTo(cx + r, cy);
                ctx.arcTo(cx + w, cy, cx + w, cy + h, r);
                ctx.arcTo(cx + w, cy + h, cx, cy + h, r);
                ctx.arcTo(cx, cy + h, cx, cy, r);
                ctx.arcTo(cx, cy, cx + w, cy, r);
                ctx.closePath();
            }

            ctx.save();
            ctx.translate(x, y);

            if (quality === 'legend') {
                // ==========================================
                // å‚³èªª (Legend)ï¼šé¾çˆªè£é£¾ (éœ¸æ°£ã€ç¥ç¸ã€è‡³é«˜ç„¡ä¸Š)
                // ==========================================

                // ç¥è©±æ¼¸å±¤ (æ·±ç´« -> é‡‘ -> ç´…) - æ›´é®®è‰·
                const grad = ctx.createLinearGradient(0, 0, size, size);
                grad.addColorStop(0, '#a855f7');   // äº®ç´«
                grad.addColorStop(0.5, '#fde047'); // æ˜äº®é‡‘è‰²
                grad.addColorStop(1, '#f87171');   // æ˜äº®ç´…è‰²

                // 1. é›™é‡å¤–æ¡† (å…§å¤–é›™å±¤) - æ›´ç²—
                ctx.strokeStyle = '#581c87'; // å¤–å±¤æ·±ç´«
                ctx.lineWidth = lw * 2;
                pathRound(1, 1, size - 2, size - 2, size * 0.15);
                ctx.stroke();

                ctx.strokeStyle = grad; // å…§å±¤æ¼¸å±¤
                ctx.lineWidth = lw * 1.2;
                pathRound(3, 3, size - 6, size - 6, size * 0.13);
                ctx.stroke();

                // 2. é¾çˆªè£é£¾ (å››å€‹è§’è½) - æ›´å¤§
                ctx.fillStyle = grad;
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2; // æ›´ç²—çš„é‚Šæ¡†

                const clawSize = size * 0.25; // å¾ 0.15 å¢åŠ åˆ° 0.25
                const clawOffset = size * 0.02; // å¾ 0.05 æ¸›å°‘åˆ° 0.02 (æ›´é è¿‘é‚Šç·£)

                // å·¦ä¸Šé¾çˆª
                ctx.beginPath();
                ctx.moveTo(clawOffset, clawOffset + clawSize * 0.8);
                ctx.quadraticCurveTo(clawOffset, clawOffset, clawOffset + clawSize * 0.8, clawOffset);
                ctx.lineTo(clawOffset + clawSize * 0.6, clawOffset + clawSize * 0.2);
                ctx.lineTo(clawOffset + clawSize * 0.2, clawOffset + clawSize * 0.6);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // å³ä¸Šé¾çˆª
                ctx.beginPath();
                ctx.moveTo(size - clawOffset - clawSize * 0.8, clawOffset);
                ctx.quadraticCurveTo(size - clawOffset, clawOffset, size - clawOffset, clawOffset + clawSize * 0.8);
                ctx.lineTo(size - clawOffset - clawSize * 0.2, clawOffset + clawSize * 0.6);
                ctx.lineTo(size - clawOffset - clawSize * 0.6, clawOffset + clawSize * 0.2);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // å³ä¸‹é¾çˆª
                ctx.beginPath();
                ctx.moveTo(size - clawOffset, size - clawOffset - clawSize * 0.8);
                ctx.quadraticCurveTo(size - clawOffset, size - clawOffset, size - clawOffset - clawSize * 0.8, size - clawOffset);
                ctx.lineTo(size - clawOffset - clawSize * 0.6, size - clawOffset - clawSize * 0.2);
                ctx.lineTo(size - clawOffset - clawSize * 0.2, size - clawOffset - clawSize * 0.6);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // å·¦ä¸‹é¾çˆª
                ctx.beginPath();
                ctx.moveTo(clawOffset + clawSize * 0.8, size - clawOffset);
                ctx.quadraticCurveTo(clawOffset, size - clawOffset, clawOffset, size - clawOffset - clawSize * 0.8);
                ctx.lineTo(clawOffset + clawSize * 0.2, size - clawOffset - clawSize * 0.6);
                ctx.lineTo(clawOffset + clawSize * 0.6, size - clawOffset - clawSize * 0.2);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

            } else if (quality === 'mythic') {
                // ==========================================
                // ç¥è©± (Mythic)ï¼šè™›ç©ºçŸ©é™£ (æ‡¸æµ®ã€ç§‘æŠ€ã€ç¥ç§˜)
                // ==========================================

                // å®šç¾©ç¥ç§˜æ¼¸å±¤ (ç´« -> é’ -> ç™½)
                const grad = ctx.createLinearGradient(0, 0, size, size);
                grad.addColorStop(0, '#7c3aed');   // ç´«è‰²
                grad.addColorStop(0.5, '#22d3ee'); // é’è‰²
                grad.addColorStop(1, '#e879f9');   // ç²‰ç´«

                // 1. æ–·è£‚å¼å¤–æ¡†
                ctx.strokeStyle = grad;
                ctx.lineWidth = lw * 0.8;
                ctx.lineCap = "round";
                const gap = size * 0.25;

                ctx.beginPath();
                ctx.moveTo(gap, 2); ctx.lineTo(size - gap, 2);
                ctx.moveTo(gap, size - 2); ctx.lineTo(size - gap, size - 2);
                ctx.moveTo(2, gap); ctx.lineTo(2, size - gap);
                ctx.moveTo(size - 2, gap); ctx.lineTo(size - 2, size - gap);
                ctx.stroke();

                // 2. è§’è½æ‡¸æµ®çŸ©é™£
                const cLen = size * 0.18;
                const offset = 3;

                ctx.strokeStyle = '#4c1d95';
                ctx.lineWidth = lw * 1.5;
                ctx.beginPath();
                ctx.moveTo(offset, offset + cLen); ctx.lineTo(offset, offset); ctx.lineTo(offset + cLen, offset);
                ctx.moveTo(size - offset, offset + cLen); ctx.lineTo(size - offset, offset); ctx.lineTo(size - offset - cLen, offset);
                ctx.moveTo(size - offset, size - offset - cLen); ctx.lineTo(size - offset, size - offset); ctx.lineTo(size - offset - cLen, size - offset);
                ctx.moveTo(offset, size - offset - cLen); ctx.lineTo(offset, size - offset); ctx.lineTo(offset + cLen, size - offset);
                ctx.stroke();

                ctx.strokeStyle = '#fff';
                ctx.lineWidth = lw * 0.6;
                ctx.stroke();

                // 3. èƒ½é‡ç¯€é»
                ctx.fillStyle = grad;
                const dotSize = size * 0.04;
                const dotOff = size * 0.08;

                ctx.beginPath();
                ctx.arc(dotOff, dotOff, dotSize, 0, Math.PI * 2);
                ctx.arc(size - dotOff, dotOff, dotSize, 0, Math.PI * 2);
                ctx.arc(size - dotOff, size - dotOff, dotSize, 0, Math.PI * 2);
                ctx.arc(dotOff, size - dotOff, dotSize, 0, Math.PI * 2);
                ctx.fill();

                // 4. å…§éƒ¨å¹¾ä½•è£é£¾
                ctx.strokeStyle = `rgba(255, 255, 255, 0.3)`;
                ctx.lineWidth = 1;
                pathRound(size * 0.15, size * 0.15, size * 0.7, size * 0.7, size * 0.05);
                ctx.stroke();
            }

            ctx.restore();
        }
        function renderDice(ctx, x, y, dice, isLocked, overrideColor = null) {
            if (!dice) return;
            const slotSize = grid.slotSize;
            const centerX = x + slotSize / 2;
            const centerY = y + slotSize / 2;

            // å„ªå…ˆé †åºï¼šè¦†è“‹è‰² > éª°å­ç›®å‰è‰² > åŸºç¤è‰²
            const finalColor = overrideColor || dice.color || dice.baseColor;

            // å¼·é¢¨ç‹‚æš´ç‹€æ…‹åˆ¤å®š
            const isBursting = (dice.id === 'mighty_wind' && dice.isBurst);

            ctx.save();

            // --- 1. ç‰¹æ•ˆèˆ‡ç¸®æ”¾è™•ç† ---
            if (isBursting) {
                // é«˜æ€§èƒ½å‘¼å¸ç¸®æ”¾
                const s = 1 + (dice.animScale || 0);
                ctx.translate(centerX, centerY);
                ctx.scale(s, s);
                ctx.translate(-centerX, -centerY);

                // é«˜æ€§èƒ½ç™¼å…‰ï¼šä½¿ç”¨å¾‘å‘æ¼¸å±¤æ›¿ä»£ ShadowBlur
                const grad = ctx.createRadialGradient(centerX, centerY, slotSize * 0.2, centerX, centerY, slotSize * 0.8);
                grad.addColorStop(0, 'rgba(255, 255, 255, 0.7)');   // ä¸­å¿ƒäº®ç™½
                grad.addColorStop(0.4, 'rgba(165, 243, 252, 0.4)'); // å¼·é¢¨æ·¡è—
                grad.addColorStop(1, 'rgba(165, 243, 252, 0)');     // é‚Šç·£é€æ˜
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(centerX, centerY, slotSize * 0.8, 0, Math.PI * 2);
                ctx.fill();
            }

            // --- 2. åŸºç¤å¤–æ¡†èˆ‡èƒŒæ™¯ ---
            const dbRef = ALL_DICES.find(d => d.id === dice.id);
            const q = QUALITIES[dbRef ? dbRef.quality : 'common'];

            // ç•«å¤–æ¡†
            ctx.beginPath();
            ctx.strokeStyle = q.color || '#fff';
            ctx.lineWidth = 3;
            drawRoundedRect(ctx, x + 4, y + 4, slotSize - 8, slotSize - 8, 8);
            ctx.stroke();

            // ç•«å¡«å……èƒŒæ™¯ (ç™½è‰²æˆ–æ·¡è—è‰²)
            ctx.beginPath();
            ctx.fillStyle = isBursting ? "#e0f2fe" : "#ffffff"; // ç‹‚æš´æ™‚æ·¡è—è‰²èƒŒæ™¯
            drawRoundedRect(ctx, x + 6, y + 6, slotSize - 12, slotSize - 12, 6);
            ctx.fill();

            // --- 3. å“è³ªç‰¹æ•ˆ (å‚³èªª/ç¥è©±) ---
            if (typeof drawQualityBorder === 'function') {
                drawQualityBorder(ctx, x, y, slotSize, dice.id);
            }

            // --- 4. ç¹ªè£½ç‰¹å¾µåœ–æ¡ˆèˆ‡æ˜Ÿç´š ---
            const drawX = x + 6;
            const drawY = y + 6;
            const drawSize = slotSize - 12;
            const dColor = dice.baseColor || dice.color || "#333";
            const pattern = (dbRef && dbRef.pattern) ? dbRef.pattern : dice.id;

            if (typeof drawDiceFeature === 'function') {
                drawDiceFeature(ctx, drawX, drawY, drawSize, pattern, finalColor); // ä½¿ç”¨ finalColor ç‹‚æš´æ™‚æ‰æœƒè®Šè‰²
            }

            if (typeof drawDiceStars === 'function') {
                drawDiceStars(ctx, drawX, drawY, drawSize, dice.lv, dColor, dice.id);
            }

            ctx.restore(); // æ¢å¾©ç¸®æ”¾ç‹€æ…‹

            // --- 5. é–å®šé®ç½© (ä¸éš¨ç¸®æ”¾è®Šå‹•) ---
            if (isLocked) {
                ctx.save();
                ctx.fillStyle = "rgba(15, 23, 42, 0.75)";
                ctx.beginPath();
                drawRoundedRect(ctx, x + 5, y + 5, slotSize - 10, slotSize - 10, 8);
                ctx.fill();

                ctx.beginPath();
                ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
                ctx.lineWidth = 2;
                const p = slotSize * 0.3;
                ctx.moveTo(x + p, y + p); ctx.lineTo(x + slotSize - p, y + slotSize - p);
                ctx.moveTo(x + slotSize - p, y + p); ctx.lineTo(x + p, y + slotSize - p);
                ctx.stroke();
                ctx.restore();
            }
        }
        function drawRoundedRect(ctx, x, y, w, h, r) {
            ctx.beginPath(); ctx.moveTo(x + r, y); ctx.lineTo(x + w - r, y); ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r); ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h); ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r); ctx.lineTo(x, y + r); ctx.quadraticCurveTo(x, y, x + r, y); ctx.closePath();
        }

        function setupTouchEvents(canvas) {
            const fingerPadding = 15; // æ‰‹æŒ‡å¯¬å®¹åº¦ï¼šå¢åŠ é»æ“Šåˆ¤å®šç¯„åœ

            canvas.addEventListener('touchstart', (e) => {
                const touch = e.touches[0], rect = canvas.getBoundingClientRect();

                // è¨ˆç®— Canvas åƒç´ èˆ‡ CSS é¡¯ç¤ºå¤§å°çš„æ¯”ä¾‹
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;

                // å–å¾—ä¿®æ­£å¾Œçš„ç•«å¸ƒåº§æ¨™
                const x = (touch.clientX - rect.left) * scaleX;
                const y = (touch.clientY - rect.top) * scaleY;

                grid.slots.forEach(slot => {
                    // é»æ“Šåˆ¤å®šï¼šåŠ å…¥ fingerPadding è®“åˆ¤å®šå€åŸŸå¾€å¤–æ“´å¼µ
                    if (slot.dice &&
                        x > slot.x - fingerPadding &&
                        x < slot.x + grid.slotSize + fingerPadding &&
                        y > slot.y - fingerPadding &&
                        y < slot.y + grid.slotSize + fingerPadding) {

                        drag.isDragging = true;
                        drag.fromSlot = slot;
                        drag.dice = { ...slot.dice }; // æ·ºæ‹·è²é¿å…ç›´æ¥ä¿®æ”¹åŸæ•¸æ“š
                        drag.currentX = x;
                        drag.currentY = y;
                        slot.isBeingDragged = true;
                    }
                });
            });

            canvas.addEventListener('touchmove', (e) => {
                if (!drag.isDragging) return;
                e.preventDefault(); // é˜»æ­¢æ‰‹æ©Ÿé é¢æ²å‹•

                const touch = e.touches[0], rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;

                // æ›´æ–°ç•¶å‰æ‹–æ‹½ä½ç½® (åŒæ¨£éœ€è¦æ¯”ä¾‹ä¿®æ­£)
                drag.currentX = (touch.clientX - rect.left) * scaleX;
                drag.currentY = (touch.clientY - rect.top) * scaleY;
            }, { passive: false });

            canvas.addEventListener('touchend', () => {
                if (!drag.isDragging) return;

                // å°‹æ‰¾ç›®æ¨™æ ¼å­ï¼šåŒæ¨£åŠ å…¥ fingerPadding è®“åˆæˆæ“ä½œæ›´è¼•é¬†
                let targetSlot = grid.slots.find(s =>
                    drag.currentX > s.x - fingerPadding &&
                    drag.currentX < s.x + grid.slotSize + fingerPadding &&
                    drag.currentY > s.y - fingerPadding &&
                    drag.currentY < s.y + grid.slotSize + fingerPadding
                );

                if (targetSlot && targetSlot !== drag.fromSlot && targetSlot.dice) {
                    const isSameStar = drag.dice.lv === targetSlot.dice.lv;

                    // --- A. æ›ä½éª°å­é‚è¼¯ (Switch) ---
                    if (drag.dice.id === 'switch' && isSameStar) {
                        // åŸ·è¡Œäº’æ›ï¼šå°‡åŸæœ¬æ ¼å­çš„éª°å­æ›åˆ°ç›®æ¨™ï¼Œç›®æ¨™çš„æ›å›ä¾†
                        const tempDice = { ...targetSlot.dice };
                        targetSlot.dice = { ...drag.fromSlot.dice };
                        drag.fromSlot.dice = tempDice;

                        // é‡è¨­æ‹–æ‹½ç‹€æ…‹
                        drag.isDragging = false;
                        drag.fromSlot.isBeingDragged = false;
                        if (typeof updateUI === 'function') updateUI();
                        if (typeof refreshSunState === 'function') refreshSunState();
                        return; // è·³å‡ºï¼Œä¸åŸ·è¡Œå¾Œé¢çš„åˆæˆé‚è¼¯
                    }

                    // --- B. ç‡Ÿé¤Šéª°å­é‚è¼¯ (Nut) ---
                    if (drag.dice.id === 'nut' && isSameStar && targetSlot.dice.lv < 7) {
                        // ç‡Ÿé¤Šéª°å­çš„æ ¸å¿ƒï¼šç›®æ¨™ä¸è®Šç¨®ï¼Œåªå‡æ˜Ÿ
                        const targetId = targetSlot.dice.id;
                        const targetDb = ALL_DICES.find(d => d.id === targetId);

                        // å–å¾—ç‡Ÿé¤Šéª°å­çš„ SP è¿”é‚„å€¼
                        const nutSpec = getDiceSpecialValue('nut');
                        battleState.sp += nutSpec; // çµ¦äºˆé¡å¤– SP è¿”é‚„

                        targetSlot.dice = {
                            id: targetId,
                            lv: targetSlot.dice.lv + 1,
                            color: targetDb.baseColor,
                            qualityColor: QUALITIES[targetDb.quality].color,
                            growthTimer: 0,
                            attackCooldown: 0,
                            spawnTime: Date.now()
                        };

                        drag.fromSlot.dice = null; // æ¶ˆè€—æ‰ç‡Ÿé¤Šéª°å­
                        drag.isDragging = false;
                        drag.fromSlot.isBeingDragged = false;
                        if (typeof updateUI === 'function') updateUI();
                        if (typeof refreshSunState === 'function') refreshSunState();
                        return;
                    }
                    // --- å°ä¸‘éª°å­è®Šèº«é‚è¼¯ ---
                    if (drag.dice.id === 'joker' && drag.dice.lv === targetSlot.dice.lv && targetSlot.dice.id !== 'joker') {
                        const targetId = targetSlot.dice.id;
                        const db = ALL_DICES.find(d => d.id === targetId);

                        drag.fromSlot.dice = {
                            id: targetId,
                            lv: drag.dice.lv,
                            color: db.baseColor,
                            qualityColor: QUALITIES[db.quality].color,
                            growthTimer: 0,
                            attackCooldown: 0,
                            spawnTime: Date.now() // è®Šèº«å¾Œé‡è¨­æ™‚é–“
                        };

                        drag.isDragging = false;
                        drag.fromSlot.isBeingDragged = false;
                        updateUI();
                        refreshSunState();
                        return;
                    }

                    // --- ä¸€èˆ¬åˆæˆé‚è¼¯ (åŒ…å«å°ä¸‘ç¢°å°ä¸‘) ---
                    if (targetSlot.dice.id === drag.dice.id && targetSlot.dice.lv === drag.dice.lv && targetSlot.dice.lv < 7) {
                        const newId = userData.deck[Math.floor(Math.random() * userData.deck.length)];
                        const db = ALL_DICES.find(d => d.id === newId);

                        targetSlot.dice = {
                            id: newId,
                            lv: drag.dice.lv + 1,
                            color: db.baseColor,
                            qualityColor: QUALITIES[db.quality].color,
                            growthTimer: 0,
                            attackCooldown: 0,
                            spawnTime: Date.now() // åˆæˆå¾Œé‡è¨­æ™‚é–“
                        };
                        drag.fromSlot.dice = null;
                        updateUI();
                        refreshSunState();
                    }
                }

                // çµ±ä¸€é‡ç½®ç‹€æ…‹
                drag.isDragging = false;
                if (drag.fromSlot) drag.fromSlot.isBeingDragged = false;
                updateUI();
                refreshSunState();
            });
        }
        function drawEffect(slot, color) {
            // 1. æœ€åŸºç¤çš„å®‰å…¨æª¢æŸ¥
            if (!slot || isNaN(slot.x)) return;

            // 2. ä¸è¦ä½¿ç”¨ save() å’Œ restore()ï¼Œé€™åœ¨æ‰‹æ©Ÿ Loop ä¸­éå¸¸é‡
            // 3. ç›´æ¥è¨­å®šå±¬æ€§ï¼Œç•«å®Œå¾Œæ‰‹å‹•æ”¹å›ä¾†
            ctx.globalAlpha = 0.4;
            ctx.strokeStyle = color;
            ctx.lineWidth = 4;

            // 4. åªç•«æœ€ç°¡å–®çš„çŸ©å½¢é‚Šæ¡† (strokeRect æ˜¯ Canvas ä¸­æ•ˆèƒ½æœ€é«˜çš„æŒ‡ä»¤ä¹‹ä¸€)
            ctx.strokeRect(
                slot.x + 2,
                slot.y + 2,
                grid.slotSize - 4,
                grid.slotSize - 4
            );

            // 5. æ‰‹å‹•é‡ç½®å…¨åŸŸå±¬æ€§ï¼Œé¿å…æ±™æŸ“å¾Œé¢çš„ç¹ªåœ–
            ctx.globalAlpha = 1.0;
            ctx.lineWidth = 1;
        }

    </script>
</body>

</html>