<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>隨機骰子 - 聯機合作模式</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://www.gstatic.com/firebasejs/9.16.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.16.0/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.16.0/firebase-firestore-compat.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            height: 100dvh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #0f172a;
            /* Slate-900 for desktop bg */
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        #game-wrapper {
            width: 100%;
            max-width: 500px;
            /* Mobile width constraint */
            height: 100%;
            max-height: 100dvh;
            display: flex;
            flex-direction: column;
            background-color: #020617;
            position: relative;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
            margin: 0 auto;
        }

        /* 太陽爆炸光圈 */
        .sun-explosion {
            position: absolute;
            border: 3px solid #fb923c;
            background: rgba(251, 146, 60, 0.3);
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            animation: sunExplode 0.4s ease-out forwards;
            z-index: 100;
            box-shadow: 0 0 15px orange;
        }

        @keyframes sunExplode {
            0% {
                width: 0px;
                height: 0px;
                opacity: 1;
            }

            100% {
                width: 130px;
                height: 130px;
                opacity: 0;
            }
        }

        #header-info {
            flex-shrink: 0;
            padding-top: max(12px, env(safe-area-inset-top));
            padding-left: 12px;
            padding-right: 12px;
            padding-bottom: 12px;
        }

        #footer-controls {
            flex-shrink: 0;
            padding: 12px;
            padding-bottom: max(20px, env(safe-area-inset-bottom, 20px));
            background: rgba(15, 23, 42, 0.95);
            border-top: 1px solid rgba(51, 65, 85, 0.5);
            z-index: 50;
            /* Ensure on top */
        }

        #canvas-container {
            position: relative;
            width: 100%;
            flex-grow: 1;
            overflow: hidden;
            background: #000;
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #1e1e24 0%, #000000 100%);
        }

        .pb-safe {
            padding-bottom: calc(0.75rem + env(safe-area-inset-bottom)) !important;
        }
    </style>
</head>

<body>

    <div id="game-wrapper">
        <div id="header-info" class="p-3 flex justify-between items-center bg-slate-900/80 border-b border-slate-800">
            <div class="flex items-center gap-4">
                <span class="text-red-500 font-bold">HP: <span id="hpText">3</span></span>
                <span class="text-blue-400 font-bold">SP: <span id="spText">100</span></span>
            </div>
            <div class="text-slate-400 font-bold text-xs">ROOM: <span id="room-id" class="text-emerald-500">----</span>
            </div>
            <div class="text-slate-400 font-bold text-sm">WAVE: <span id="waveText">1</span></div>
        </div>

        <div id="canvas-container">
            <canvas id="gameCanvas"></canvas>
        </div>

        <div id="footer-controls" class="pb-safe">
            <div class="flex flex-nowrap w-full gap-1 mb-4" id="powerUpButtons"></div>
            <button onclick="handleSummonClick()"
                class="w-full py-4 bg-blue-600 rounded-xl font-black text-xl shadow-lg active:scale-95 transition-all text-white">
                召喚骰子 (<span id="summonCostText">10</span> SP)
            </button>
        </div>
    </div>

    <script>
        // --- 1. 遊戲基礎資料 (整合 Dice Battle) ---
        const QUALITIES = {
            common: { name: '普通', color: '#9ca3af', chance: 0.50 },
            rare: { name: '稀有', color: '#3b82f6', chance: 0.30 },
            epic: { name: '史詩', color: '#a855f7', chance: 0.18 },
            legend: { name: '傳說', color: '#eab308', chance: 0.019 },
            mythic: { name: '神話', color: '#ff00ff', chance: 0.001 }
        };

        const ALL_DICES = [
            // --- Common (普通) ---
            {
                id: 'fire', name: '火', quality: 'common', baseColor: '#ef4444', pattern: 'fire',
                stats: { atk: 18, speed: 0.92 }, grow: { atk: 6, speed: -0.017 },
                special: { label: '濺射範圍', value: 1.0, unit: '格', grow: 0.1 }
            },
            {
                id: 'wind', name: '風', quality: 'common', baseColor: '#10b981', pattern: 'wind',
                stats: { atk: 8, speed: 0.58 }, grow: { atk: 2, speed: -0.025 },
                special: { label: '連擊機率', value: 10, unit: '%', grow: 3 }
            },
            {
                id: 'ice', name: '冰', quality: 'common', baseColor: '#3b82f6', pattern: 'ice',
                stats: { atk: 7, speed: 1.0 }, grow: { atk: 1, speed: -0.017 },
                special: { label: '緩速效果', value: 20, unit: '%', grow: 2 }
            },
            {
                id: 'electric', name: '電', quality: 'common', baseColor: '#f59e0b', pattern: 'electric',
                stats: { atk: 6, speed: 0.75 }, grow: { atk: 2, speed: -0.017 },
                special: { label: '連鎖目標', value: 3, unit: '體', grow: 1 }
            },
            {
                id: 'poison', name: '毒', quality: 'common', baseColor: '#008000', pattern: 'poison',
                stats: { atk: 4, speed: 0.83 }, grow: { atk: 2, speed: -0.017 },
                special: { label: '中毒傷害', value: 12, unit: 'pt', grow: 4 }
            },

            // --- Rare (稀有) ---
            {
                id: 'lock', name: '鎖定', quality: 'rare', baseColor: '#64748b', pattern: 'lock',
                stats: { atk: 12, speed: 0.92 }, grow: { atk: 4, speed: -0.017 },
                special: { label: '禁錮時長', value: 0.8, unit: '秒', grow: 0.2 }
            },
            {
                id: 'crack', name: '易傷', quality: 'rare', baseColor: '#f87171', pattern: 'crack',
                stats: { atk: 12, speed: 0.83 }, grow: { atk: 3, speed: -0.017 },
                special: { label: '額外受傷', value: 8, unit: '%', grow: 1 }
            },
            {
                id: 'mine', name: '礦山', quality: 'rare', baseColor: '#fbbf24', pattern: 'mine',
                stats: { atk: 0, speed: 15.0 }, grow: { atk: 0, speed: -0.5 },
                special: { label: '產出SP', value: 10, unit: 'pt', grow: 5 }
            },

            // --- Epic (史詩) ---
            {
                id: 'laser', name: '雷射', quality: 'epic', baseColor: '#ec4899', pattern: 'laser_beam',
                stats: { atk: 8, speed: 0.67 }, grow: { atk: 2, speed: 0 },
                special: { label: '增幅上限', value: 5, unit: '倍', grow: 1 }
                // 功能：持續攻擊同一個目標時，傷害會隨攻擊次數不斷爬升
            },
            {
                id: 'teleport', name: '傳送', quality: 'epic', baseColor: '#8b5cf6', pattern: 'teleport',
                stats: { atk: 10, speed: 1.08 }, grow: { atk: 3, speed: -0.017 },
                special: { label: '傳送回起點', value: 5, unit: '%', grow: 2 }
            },
            {
                id: 'gear', name: '齒輪', quality: 'epic', baseColor: '#475569', pattern: 'gear',
                stats: { atk: 15, speed: 0.83 }, grow: { atk: 8, speed: -0.017 },
                special: { label: '連結加成', value: 12, unit: '%', grow: 6 }
            },

            // --- Legend (傳說) ---
            {
                id: 'mighty_wind', name: '強風', quality: 'legend', baseColor: '#a5f3fc', pattern: 'mighty_wind',
                stats: { atk: 20, speed: 0.67 }, grow: { atk: 6, speed: -0.017 },
                special: { label: '狂暴時長', value: 2, unit: '秒', grow: 0.5 }
            },
            {
                id: 'joker', name: '小丑', quality: 'legend', baseColor: '#f87171', pattern: 'joker',
                stats: { atk: 5, speed: 0.83 }, grow: { atk: 1, speed: 0 },
                special: { label: '繼承比例', value: 80, unit: '%', grow: 2 }
            },
            {
                id: 'growth', name: '成長', quality: 'legend', baseColor: '#f472b6', pattern: 'growth',
                stats: { atk: 5, speed: 0.83 }, grow: { atk: 1, speed: -0.017 },
                special: { label: '成長時間', value: 40, unit: '秒', grow: -2 }
            },
            {
                id: 'sun', name: '太陽', quality: 'legend', baseColor: '#fbbf24', pattern: 'sun',
                stats: { atk: 35, speed: 0.92 }, grow: { atk: 15, speed: -0.008 },
                special: { label: '濺射傷害', value: 100, unit: '%', grow: 25 }
            },
            {
                id: 'sanctuary', name: '聖域', quality: 'legend', baseColor: '#fbbf24', pattern: 'sanctuary',
                stats: { atk: 15, speed: 1.0 }, grow: { atk: 6, speed: -0.017 },
                special: { label: '加速範圍', value: 30, unit: '%', grow: 5 }
            },
            {
                id: 'comet', name: '彗星', quality: 'legend', baseColor: '#3b82f6', pattern: 'comet',
                stats: { atk: 18, speed: 0.75 }, grow: { atk: 7, speed: -0.017 },
                special: { label: '充能倍率', value: 500, unit: '%', grow: 100 }
            },

            // --- Epic (史詩) 新增 ---
            {
                id: 'chain', name: '連鎖', quality: 'epic', baseColor: '#8b5cf6', pattern: 'chain',
                stats: { atk: 15, speed: 0.83 }, grow: { atk: 5, speed: -0.017 },
                special: { label: '彈射增傷', value: 50, unit: '%', grow: 10 }
            },

            // --- Mythic (神話) ---
            {
                id: 'doom', name: '毀滅', quality: 'mythic', baseColor: '#7c3aed', pattern: 'doom',
                stats: { atk: 45, speed: 0.83 }, grow: { atk: 20, speed: -0.017 },
                special: { label: '斬殺比例', value: 35, unit: '%', grow: 5 }
            },
            {
                id: 'galaxy', name: '銀河', quality: 'mythic', baseColor: '#6366f1', pattern: 'galaxy',
                stats: { atk: 60, speed: 0.83 }, grow: { atk: 30, speed: -0.017 },
                special: { label: '黑洞吞噬', value: 2, unit: '%', grow: 1 }
            }
        ];

        const BOSS_TYPES = {
            'CRUSHER': {
                name: '粉碎者', color: '#ff4444',
                img: (() => { const i = new Image(); i.src = 'dice-boss/lock.png'; return i; })(),
                skillInterval: 300,
                onSkill: (boss) => {
                    // 只鎖定對應玩家的骰子 (Host 視角: P1=mySlots, P2=partnerSlots)
                    const isMySlots = boss.owner === 'p1';
                    const targetSlots = isMySlots ? mySlots : partnerSlots;
                    const syncFn = isMySlots ? syncMyData : syncPartnerData;

                    const targets = targetSlots.filter(s => s.dice && !s.isLocked);
                    if (targets.length > 0) {
                        const target = targets[Math.floor(Math.random() * targets.length)];
                        target.isLocked = true;
                        setTimeout(() => { target.isLocked = false; syncFn(); }, 4000);
                        syncFn();
                    }
                }
            },
            'SNAKE': {
                name: '噴射者', color: '#22c55e',
                img: (() => { const i = new Image(); i.src = 'dice-boss/speed.png'; return i; })(),
                skillInterval: 240,
                onSkill: (boss) => {
                    // 只加速自己，不影響其他敵人
                    const originalSpeed = boss.speed;
                    boss.speed *= 2.5;
                    boss.isSprinting = true;

                    setTimeout(() => {
                        if (enemies.includes(boss)) {
                            boss.speed = originalSpeed;
                            boss.isSprinting = false;
                        }
                    }, 2500);
                }
            },
            'HACKER': {
                name: '混亂者', color: '#a855f7',
                img: (() => { const i = new Image(); i.src = 'dice-boss/hack.png'; return i; })(),
                skillInterval: 360,
                onSkill: (boss) => {
                    // 只影響對應玩家的骰子 (Host 視角)
                    const isMySlots = boss.owner === 'p1';
                    const targetSlots = isMySlots ? mySlots : partnerSlots;
                    const syncFn = isMySlots ? syncMyData : syncPartnerData;

                    const occupied = targetSlots.filter(s => s && s.dice);
                    if (occupied.length > 0) {
                        occupied.forEach(slot => {
                            const randomId = userData.deck[Math.floor(Math.random() * userData.deck.length)];
                            const template = ALL_DICES.find(d => d.id === randomId);
                            if (template && slot.dice) {
                                const currentLv = slot.dice.lv;
                                slot.dice = {
                                    id: template.id,
                                    lv: currentLv,
                                    baseColor: template.baseColor,
                                    color: template.baseColor,
                                    pattern: template.pattern || template.id,
                                    qualityColor: QUALITIES[template.quality].color,
                                    growthTimer: 0,
                                    attackCooldown: 0
                                };
                            }
                        });

                        const container = document.getElementById('canvas-container');
                        if (container) {
                            container.style.boxShadow = 'inset 0 0 50px #a855f7';
                            setTimeout(() => { if (container) container.style.boxShadow = ''; }, 500);
                        }
                        syncFn();
                    }
                }
            },
            'GRAVITY': {
                name: '重力者', color: '#1e293b',
                img: (() => { const i = new Image(); i.src = 'dice-boss/gravity.png'; return i; })(),
                skillInterval: 450,
                onSkill: (boss) => {
                    // 只影響對應玩家的骰子 (Host 視角)
                    const isMySlots = boss.owner === 'p1';
                    const targetSlots = isMySlots ? mySlots : partnerSlots;
                    const syncFn = isMySlots ? syncMyData : syncPartnerData;

                    const occupied = targetSlots.filter(s => s.dice);
                    if (occupied.length > 0) {
                        const target = occupied[Math.floor(Math.random() * occupied.length)];
                        target.dice.lv -= 1;

                        if (target.dice.lv <= 0) {
                            target.dice = null;
                            // 簡化視覺效果：在畫面中央附近顯示
                            visualEffects.push({
                                type: 'explosion',
                                x: canvas.width / 2 + (Math.random() - 0.5) * 100,
                                y: canvas.height / 2 + (Math.random() - 0.5) * 100,
                                radius: 40,
                                color: 'rgba(30, 41, 59, 0.5)',
                                life: 15, maxLife: 15
                            });
                        }
                        syncFn();
                    }
                }
            },
            'GLITCH': {
                name: '干擾者', color: '#3b82f6',
                img: (() => { const i = new Image(); i.src = 'dice-boss/glitch.png'; return i; })(),
                skillInterval: 400,
                onSkill: (boss) => {
                    // 只影響對應玩家的骰子 (Host 視角)
                    const isMySlots = boss.owner === 'p1';
                    const targetSlots = isMySlots ? mySlots : partnerSlots;
                    const syncFn = isMySlots ? syncMyData : syncPartnerData;

                    const occupiedSlots = targetSlots.filter(s => s && s.dice);
                    if (occupiedSlots.length < 2) return;

                    let allDiceData = occupiedSlots.map(s => JSON.parse(JSON.stringify(s.dice)));
                    for (let i = allDiceData.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [allDiceData[i], allDiceData[j]] = [allDiceData[j], allDiceData[i]];
                    }
                    occupiedSlots.forEach((slot, index) => {
                        slot.dice = allDiceData[index];
                    });

                    const container = document.getElementById('canvas-container');
                    if (container) {
                        container.style.filter = 'hue-rotate(90deg) contrast(1.5)';
                        setTimeout(() => { if (container) container.style.filter = ''; }, 400);
                    }
                    syncFn();
                }
            }
        };

        const BALANCE = {
            ENEMY_BASE_HP: 100, ENEMY_LEVEL_GROWTH: 1.25, ENEMY_WAVE_GROWTH: 1.20,
            BOSS_BASE_HP: 3000, BOSS_LEVEL_GROWTH: 1.6, BOSS_WAVE_GROWTH: 1.8
        };

        // --- 2. 初始化 ---
        const _k = ["AIzaSyDSRfVA", "uWCWCUd1NJop", "J6wHvsqsAM4UzJA"];

        const firebaseConfig = {
            apiKey: _k.join(''),
            authDomain: "game-80d68.firebaseapp.com",
            projectId: "game-80d68",
            databaseURL: "https://game-80d68-default-rtdb.asia-southeast1.firebasedatabase.app/",
            messagingSenderId: "636332967920",
            appId: "1:636332967920:web:29e5600daf4db0ab613f35",
            measurementId: "G-MJZ4PGEHSQ"
        };

        if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
        }
        const db = firebase.database();
        const fs = firebase.firestore();

        const urlParams = new URLSearchParams(window.location.search);
        const roomId = urlParams.get('roomId') || "COOP_TEST";
        const role = urlParams.get('role') || "host"; // 'host' (P1) or 'guest' (P2)
        document.getElementById('room-id').innerText = roomId + (role === 'host' ? " (房主)" : " (隊友)");

        const userData = JSON.parse(localStorage.getItem('dice_game_data')) || {
            deck: ['fire', 'wind', 'ice', 'electric', 'poison'],
            diceLevels: { 'fire': 1, 'wind': 1, 'ice': 1, 'electric': 1, 'poison': 1 },
            unlockLevel: 1
        };
        let hostDeckCache = [];
        let partnerDeckCache = [];
        // 從大廳 (dice.html) 同步的暱稱
        userData.nickname = localStorage.getItem('player_name') || "Player";

        const AudioManager = {
            ctx: new (window.AudioContext || window.webkitAudioContext)(),
            buffers: {},
            async init() {
                const sounds = { 'hit': 'dice-sound/hit.wav' };
                for (const [name, url] of Object.entries(sounds)) {
                    try {
                        const response = await fetch(url);
                        const b = await response.arrayBuffer();
                        this.buffers[name] = await this.ctx.decodeAudioData(b);
                    } catch (e) { console.error(e); }
                }
            },
            playHit() {
                if (!this.buffers['hit'] || this.ctx.state === 'suspended') {
                    if (this.ctx.state === 'suspended') this.ctx.resume();
                    return;
                }
                const s = this.ctx.createBufferSource(); s.buffer = this.buffers['hit'];
                const g = this.ctx.createGain(); g.gain.value = 0.05;
                s.connect(g); g.connect(this.ctx.destination); s.start(0);
            }
        };
        AudioManager.init();

        // --- 3. 遊戲狀態 ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let battleState = { hp: 3, sp: 100, wave: 1, summonCost: 10, isStarted: false };
        let powerUpLevels = {};
        userData.deck.forEach(id => powerUpLevels[id] = 1);

        // 雙方盤面 (Host: my=P1, partner=P2; Guest: my=P2, partner=P1)
        // 為了邏輯統一，我們使用 mySlots 以及 partnerSlots
        let mySlots = [];
        let partnerSlots = [];

        // 網格佈局 (3x5)
        let grid = { rows: 3, cols: 5, padding: 8, slotSize: 0 };
        let drag = { isDragging: false, fromSlot: null, currentX: 0, currentY: 0, dice: null };

        let enemies = []; // 共享敵人列表 (含 owner: 'p1'|'p2' 及 pathIndex)
        let projectiles = [];
        let damagePopups = [];
        let visualEffects = []; // 視覺特效列表
        let blackHoles = []; // 黑洞列表 (Galaxy 骰子)
        let frameCount = 0;
        let lastFrameTime = 0;
        let deltaTime = 0;
        const TARGET_FPS = 60;
        const TARGET_FRAME_TIME = 1000 / TARGET_FPS; // 16.67ms
        let waveState = { total: 10, spawned: 0, timer: 0, waiting: false };
        let paths = { p1: [], p2: [] };

        // 太陽骰子狀態
        let isSunActivated = false;

        // 狀態緩存 (Guest 用來追蹤 SP 累積)
        let stateCache = { lastTotalSpP2: 0, totalSpP2: 0 };

        // --- 4. 初始化流程 ---
        function init() {
            resizeCanvas();
            // 監聽視窗變化，即時調整 Canvas 與路徑
            window.addEventListener('resize', () => {
                resizeCanvas();
                initPaths();
            });

            initGrid();
            initPaths();
            initUI();

            // 綁定操作事件
            setupTouchEvents();

            // Firebase 同步
            // Firebase 同步
            if (role === 'host') {
                resetRoomData();
            }
            startFirebaseSync();

            // 啟動迴圈
            battleState.isStarted = true;
            requestAnimationFrame(gameLoop);
        }

        function resetRoomData() {
            db.ref(`coop_rooms/${roomId}`).set({
                enemies: [],
                wave: 1,
                hp: 3,
                gameover: false,
                players: {
                    p1: { slots: [], sp: 100, powerUpLevels: powerUpLevels, name: userData.nickname || 'Host' },
                    p2: null // P2 重連後會自己更新
                }
            });
        }

        // 標準化邏輯解析度 (即使是兩隻手機，寬度也可能有微小差異導致座標錯位)
        const LOGICAL_WIDTH = 500;
        let scaleFactor = 1;

        function resizeCanvas() {
            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();

            // 強制內部邏輯寬度為 500，高度依比例縮放
            scaleFactor = LOGICAL_WIDTH / rect.width;

            canvas.width = LOGICAL_WIDTH;
            canvas.height = rect.height * scaleFactor;

            // 重新計算 Grid Size (響應式)
            if (grid.cols) {
                const sideMargin = canvas.width * 0.12;
                grid.slotSize = (canvas.width - (grid.cols + 1) * grid.padding - (sideMargin * 2)) / grid.cols;
            }
        }

        function initGrid() {
            // resizeCanvas 已經算好 slotSize，這裡只負責生格子
            if (mySlots.length === 0) {
                const createSlots = () => Array(15).fill(null).map((_, i) => ({
                    dice: null, isLocked: false, isBeingDragged: false, attackCooldown: 0,
                    index: i, col: i % 5, row: Math.floor(i / 5)
                }));
                mySlots = createSlots();
                partnerSlots = createSlots();
            }
        }



        // 路徑定義：從兩側出發，匯聚到中間
        // Index >= 4 為共享路徑 (中央直線)
        // 路徑定義：直角交會
        // Index >= 3 為共享路徑 (從交匯點往中央走)
        const MERGE_INDEX = 3; // 更新為 3: 直到抵達 index 2 (交匯點) 之後，開始往 3 走才算共享
        function initPaths() {
            const w = canvas.width;
            const h = canvas.height;
            const gap = 30;
            const midY = h / 2;

            // P1 (Host/Bottom) 路徑: 
            // 0: 右下 -> 1: 左下 -> 2: 左中(匯聚) -> 3: 中央點 -> 4: 終點
            paths.p1 = [
                { x: w - gap, y: h - gap },       // 0
                { x: gap, y: h - gap },           // 1
                { x: gap, y: midY },              // 2 (進入中央線)
                { x: w / 2, y: midY },            // 3 (中央點)
                { x: w + 50, y: midY }            // 4 (終點)
            ];

            // P2 (Guest/Top) 路徑:
            // 0: 右上 -> 1: 左上 -> 2: 左中(匯聚) -> 3: 中央點 -> 4: 終點
            paths.p2 = [
                { x: w - gap, y: gap },           // 0
                { x: gap, y: gap },               // 1
                { x: gap, y: midY },              // 2 (進入中央線)
                { x: w / 2, y: midY },            // 3
                { x: w + 50, y: midY }            // 4
            ];
        }

        // --- 5. Firebase 同步 ---
        function startFirebaseSync() {
            const roomRef = db.ref('coop_rooms/' + roomId);
            if (role === 'host') {
                roomRef.onDisconnect().remove();
            }
            roomRef.on('value', (snap) => {
                const data = snap.val();
                if (!data) return;
                if (data.players?.p1?.deck) hostDeckCache = data.players.p1.deck;
                if (data.players?.p2?.deck) partnerDeckCache = data.players.p2.deck;
                // 共同狀態
                if (data.wave) battleState.wave = data.wave;
                if (data.hp !== undefined) battleState.hp = data.hp;

                if (role === 'guest' && data.gameStats && data.gameStats.totalSpP2) {
                    const newTotal = data.gameStats.totalSpP2;
                    let diff = newTotal - (stateCache.lastTotalSpP2 || 0);

                    // 如果伺服器重置 (數值變小)，視為新局，不加卻也不扣
                    if (diff < 0) {
                        stateCache.lastTotalSpP2 = newTotal;
                        diff = 0;
                    }

                    if (diff > 0) {
                        battleState.sp += diff;
                        stateCache.lastTotalSpP2 = newTotal;
                        updateUILive();
                    }
                }

                // 監聽結束信號
                // 只要收到 gameover 為 true 就結束，不需檢查本地 HP (避免同步落差)
                if (data.gameover === true && battleState.isStarted) {
                    battleState.hp = 0; // 強制歸零
                    handleGameOver();
                }

                // 敵人同步 (Host 寫入，Guest 讀取)
                // 敵人同步 (Host 寫入，Guest 讀取)
                if (role === 'guest' && data.enemies) {
                    const remoteEnemies = data.enemies || [];

                    // 1. 標記所有現有敵人為"未更新"
                    const currentMap = new Map();
                    enemies.forEach(e => currentMap.set(e.id, e));

                    const newEnemies = [];

                    remoteEnemies.forEach(r => {
                        if (currentMap.has(r.id)) {
                            // 更新舊物件屬性 (保留 references)
                            const local = currentMap.get(r.id);
                            local.serverX = r.x;
                            local.serverY = r.y;
                            local.hp = r.hp;
                            local.pathIndex = r.pathIndex;
                            // 同步 Boss 與衝刺相關屬性
                            local.speed = r.speed;
                            local.isSprinting = r.isSprinting;
                            local.isBoss = r.isBoss;
                            local.bossType = r.bossType;
                            local.size = r.size;
                            local.color = r.color;
                            local.owner = r.owner;
                            newEnemies.push(local);
                        } else {
                            // 新增
                            r.serverX = r.x;
                            r.serverY = r.y;
                            newEnemies.push(r);
                        }
                    });

                    // 替換列表 (此時 newEnemies 包含更新後的舊物件 + 新物件)
                    // 這樣 projectiles 持有的 target 引用依然有效
                    enemies = newEnemies;
                }

                if (role === 'host') {
                    if (data.players?.p2) {
                        updateSlotsFromSync(partnerSlots, data.players.p2.slots);
                        // 同步夥伴等級
                        if (data.players.p2.powerUpLevels) {
                            partnerPowerUpLevels = data.players.p2.powerUpLevels;
                        }
                    }
                } else {
                    // Guest: 第一次連線成功時，把自己的名字寫入 P2 (如果尚未寫入)
                    if (!battleState.guestNameSynced && data.players?.p1) {
                        db.ref(`coop_rooms/${roomId}/players/p2/name`).set(userData.nickname || 'Guest');
                        battleState.guestNameSynced = true;
                    }

                    if (data.players?.p1) {
                        updateSlotsFromSync(partnerSlots, data.players.p1.slots);
                        if (data.players.p1.powerUpLevels) {
                            partnerPowerUpLevels = data.players.p1.powerUpLevels;
                        }
                    }

                    // Critical Fix: Guest 也需要監聽自己的資料 (p2)，因為 Host (Boss) 可能會修改它 (例如鎖定、降級)
                    if (data.players?.p2) {
                        updateSlotsFromSync(mySlots, data.players.p2.slots);
                    }
                }

                // 儲存雙方名字以供 Game Over 顯示
                if (data.players?.p1?.name) battleState.p1Name = data.players.p1.name;
                if (data.players?.p2?.name) battleState.p2Name = data.players.p2.name;

                updateUILive();
            });

            // 立即同步一次初始資料 (包含 Deck 與 Levels)
            syncMyData();
        }

        function updateSlotsFromSync(localSlots, remoteData) {
            if (!remoteData) return;
            remoteData.forEach((rSlot, i) => {
                const lSlot = localSlots[i];
                if (!lSlot.dice && rSlot.dice) {
                    // 新增骰子
                    lSlot.dice = rSlot.dice;
                } else if (lSlot.dice && !rSlot.dice) {
                    // 移除
                    lSlot.dice = null;
                } else if (lSlot.dice && rSlot.dice) {
                    // 更新
                    lSlot.dice.lv = rSlot.dice.lv;
                    lSlot.dice.id = rSlot.dice.id;
                    lSlot.dice.baseColor = rSlot.dice.baseColor;
                    lSlot.isLocked = rSlot.isLocked; // 同步鎖定狀態
                }
            });
        }

        function syncMyData() {
            const pKey = role === 'host' ? 'p1' : 'p2';
            // 只上傳必要資料以節省頻寬
            const simpleSlots = mySlots.map(s => ({
                dice: s.dice ? { id: s.dice.id, lv: s.dice.lv, baseColor: s.dice.baseColor } : null,
                isLocked: s.isLocked
            }));

            db.ref(`coop_rooms/${roomId}/players/${pKey}`).update({
                slots: simpleSlots,
                sp: battleState.sp,
                // 新增同步：讓對方知道我的牌組與等級
                deck: userData.deck,
                powerUpLevels: powerUpLevels
            });
        }

        // 當 Host 修改了 Partner 的資料時 (例如 Boss 技能影響 P2 骰子)
        function syncPartnerData() {
            if (role !== 'host') return; // 只有 Host 能同步 P2 資料

            const simpleSlots = partnerSlots.map(s => ({
                dice: s.dice ? { id: s.dice.id, lv: s.dice.lv, baseColor: s.dice.baseColor } : null,
                isLocked: s.isLocked
            }));

            db.ref(`coop_rooms/${roomId}/players/p2`).update({
                slots: simpleSlots
            });
        }

        // 夥伴的等級資訊
        let partnerPowerUpLevels = {};


        // --- 6. 遊戲迴圈 ---
        let accumulatedTime = 0;

        function gameLoop(currentTime) {
            if (!battleState.isStarted) return;

            // 計算 delta time
            if (lastFrameTime === 0) lastFrameTime = currentTime;
            deltaTime = currentTime - lastFrameTime;
            lastFrameTime = currentTime;

            // 累積時間用於固定更新頻率
            accumulatedTime += deltaTime;

            // 限制最大累積時間，防止長時間暫停後的爆發更新
            if (accumulatedTime > 200) accumulatedTime = 200;

            // 以固定時間步長更新邏輯 (60 FPS)
            while (accumulatedTime >= TARGET_FRAME_TIME) {
                frameCount++;

                // 1. 邏輯更新
                if (role === 'host') {
                    updateHostLogic(); // 生怪、移動、傷害結算
                    if (battleState.needsImmediateSync || frameCount % 6 === 0) {
                        db.ref(`coop_rooms/${roomId}`).update({
                            enemies: enemies,
                            wave: battleState.wave,
                            hp: battleState.hp,
                            gameover: battleState.hp <= 0,
                        });
                        battleState.needsImmediateSync = false; // 同步完重置
                    }
                } else {
                    updateGuestLogic(); // 預測移動
                }

                // 2. 戰鬥判定 (雙方都要跑，因為要發射子彈和特效)
                updateCombat();

                accumulatedTime -= TARGET_FRAME_TIME;
            }

            // 3. 渲染 (每幀都渲染，保持流暢)
            draw();

            requestAnimationFrame(gameLoop);
        }

        // Guest 邏輯: 本地預測移動 (避免卡頓)
        function updateGuestLogic() {
            enemies.forEach(e => {
                if (e.hp <= 0) return;

                const path = e.owner === 'p1' ? paths.p1 : paths.p2;
                // 防呆
                if (!path || e.pathIndex >= path.length) return;

                const target = path[e.pathIndex];
                if (target) {
                    let dx = target.x - e.x;
                    let dy = target.y - e.y;
                    let dist = Math.hypot(dx, dy);

                    // 簡單移動
                    // 注意：e.speed 也是 sync 過來的，如果有 buff 會自動同步
                    if (dist < e.speed) {
                        e.pathIndex++;
                        // 不做移除或扣血，只負責移動
                        // 如果超出路徑，就停在終點等待 Host 移除
                    } else {
                        e.x += (dx / dist) * e.speed;
                        e.y += (dy / dist) * e.speed;
                    }
                }
                if (e.serverX !== undefined) {
                    const driftX = e.serverX - e.x;
                    const driftY = e.serverY - e.y;
                    // 每次更新只拉回 10% 的誤差，這樣肉眼看不出閃爍
                    e.x += driftX * 0.1;
                    e.y += driftY * 0.1;
                }
            });
        }

        // --- Host 邏輯: 生怪與移動 ---
        function updateHostLogic() {
            // Wave 管理
            if (!waveState.waiting) {
                waveState.timer++;
                let spawnRate = Math.max(15, 40 - battleState.wave);
                // Boss 關卡只生成一次 (因為一次 spawnBoss 會生成兩隻)
                const isBossWave = battleState.wave % 10 === 0;
                const waveLimit = isBossWave ? 1 : waveState.total;

                if (waveState.timer >= spawnRate) {
                    if (waveState.spawned < waveLimit) {
                        if (isBossWave) spawnBoss();
                        else spawnEnemy();
                        waveState.spawned++;
                        waveState.timer = 0;
                    } else if (enemies.length === 0) {
                        waveState.waiting = true;
                        waveState.timer = 0;
                    }
                }
            } else {
                waveState.timer++;
                if (waveState.timer > 120) { // 休息 2 秒
                    battleState.wave++;
                    waveState.total += 2;
                    waveState.spawned = 0;
                    waveState.waiting = false;
                    waveState.timer = 0;
                }
            }

            // 黑洞邏輯
            for (let i = blackHoles.length - 1; i >= 0; i--) {
                const bh = blackHoles[i];
                bh.timer++;
                if (bh.timer > 120) { // 持續 2 秒
                    blackHoles.splice(i, 1);
                    continue;
                }

                // 吸附敌人
                enemies.forEach(e => {
                    // 判斷權限: 只能吸"能打的怪"
                    let canHit = false;
                    if (e.owner === bh.owner) canHit = true;
                    else if (e.pathIndex >= 3) canHit = true;

                    if (canHit) {
                        const dx = bh.x - e.x;
                        const dy = bh.y - e.y;
                        const dist = Math.hypot(dx, dy);
                        if (dist < 150 && dist > 10) {
                            e.x += dx * 0.05; // 吸力
                            e.y += dy * 0.05;
                            e.hp -= 0.5; // 黑洞傷害

                            // 黑洞傷害數字 (每 0.5 秒跳一次，深藍色)
                            if (frameCount % 30 === 0) {
                                damagePopups.push({
                                    x: e.x + (Math.random() * 20 - 10),
                                    y: e.y - 10,
                                    val: 15, // 0.5 * 30 frames = 15 total dmg approx
                                    color: '#6366f1', // Indigo
                                    life: 30
                                });
                            }
                        }
                    }
                });
            }

            // 敵人移動與效果
            for (let i = enemies.length - 1; i >= 0; i--) {
                let e = enemies[i];

                // 0. 防呆：清除無效座標的怪物
                if (Number.isNaN(e.x) || Number.isNaN(e.y)) {
                    enemies.splice(i, 1);
                    continue;
                }

                // 1. DOT 傷害 (毒)
                if (e.poisonStacks > 0 && role === 'host') {
                    e.hp -= (e.poisonStacks * 2) / 60;
                    // 每秒跳一次毒傷數字 (紫色)
                    if (frameCount % 60 === 0 && damagePopups.length < 20) {
                        damagePopups.push({
                            x: e.x, y: e.y - 10,
                            val: Math.floor(e.poisonStacks * 2),
                            color: '#a855f7', // Purple
                            life: 40
                        });
                    }
                }

                // 1.5 毀滅標記處理
                if (e.doomMark && role === 'host') {
                    const elapsed = Date.now() - e.doomMark.startTime;
                    if (elapsed >= e.doomMark.timer) {
                        e.hp -= e.doomMark.damage;
                        if (damagePopups.length < 20) {
                            damagePopups.push({
                                x: e.x, y: e.y,
                                val: Math.floor(e.doomMark.damage),
                                life: 40,
                                color: '#7c3aed'
                            });
                        }
                        visualEffects.push({
                            type: 'explosion',
                            x: e.x, y: e.y,
                            radius: 100,
                            color: 'rgba(124, 58, 237, 0.9)',
                            life: 30, maxLife: 30
                        });
                        delete e.doomMark;
                    }
                }

                // 狀態恢復
                if (e.iceTimer > 0) {
                    e.iceTimer--;
                    if (e.iceTimer <= 0) e.speed = 1.5; // 恢復速度 (須考慮 Boss 加成?)
                }
                if (e.lockTimer > 0) {
                    e.lockTimer--;
                    e.speed = 0;
                } else if (e.iceTimer <= 0 && !e.lockTimer) {
                    // 這裡簡單恢復，如果有多重 buff 系統可能要改
                    e.speed = 1.5;
                }

                // 2. Boss 技能
                if (e.isBoss) {
                    e.skillTimer = (e.skillTimer || 0) + 1;
                    if (e.skillTimer >= BOSS_TYPES[e.bossType].skillInterval) {
                        BOSS_TYPES[e.bossType].onSkill(e);
                        e.skillTimer = 0;
                    }
                }

                // 3. 移動
                const path = e.owner === 'p1' ? paths.p1 : paths.p2;
                const target = path[e.pathIndex];

                if (target) {
                    let dx = target.x - e.x;
                    let dy = target.y - e.y;
                    let dist = Math.hypot(dx, dy);

                    if (dist < e.speed) {
                        e.pathIndex++;
                        // 修正位置避免瞬移
                        if (e.pathIndex < path.length) {
                            // 還沒到終點
                        } else {
                            // 到終點
                            if (e.isBoss) {
                                battleState.hp = 0;
                            } else {
                                battleState.hp--;
                            }
                            if (battleState.hp <= 0) {
                                handleGameOver();
                            }
                            enemies.splice(i, 1);
                            continue;
                        }
                    } else {
                        e.x += (dx / dist) * e.speed;
                        e.y += (dy / dist) * e.speed;
                    }
                }
                // 修改後的 updateHostLogic 區段 (約在 650 行)
                if (e.hp <= 0) {
                    enemies.splice(i, 1);
                    // 只要有怪物死亡，標記需要立即同步
                    battleState.needsImmediateSync = true;

                    // 這裡原本加 SP 的 if (target.owner === 'p1') ... 全部刪除！
                }
            }
        }

        // 生成唯一 ID
        function generateId() {
            return Math.random().toString(36).substr(2, 9);
        }

        function spawnEnemy() {
            const wave = battleState.wave;
            const hp = Math.max(1,
                BALANCE.ENEMY_BASE_HP * Math.pow(BALANCE.ENEMY_WAVE_GROWTH, wave - 1)
            );

            // 同時在 P1 與 P2 路徑生成
            ['p1', 'p2'].forEach(owner => {
                const start = owner === 'p1' ? paths.p1[0] : paths.p2[0];
                enemies.push({
                    id: generateId(), // Add ID
                    x: start.x, y: start.y,
                    owner: owner,
                    pathIndex: 1, // 往第 1 個點走
                    maxHp: hp, hp: hp, virtualHp: hp,
                    speed: 1.5,
                    poisonStacks: 0,
                    rewardSp: 10 + Math.floor((wave - 1) / 5) * 5,
                    isBoss: false
                });
            });
        }

        function spawnBoss() {
            const wave = battleState.wave;
            // 使用波數作為確定性種子，確保 Host 和 Guest 生成相同的 Boss 類型
            const bossKeys = Object.keys(BOSS_TYPES);
            const typeIndex = wave % bossKeys.length; // 依照波數循環選擇
            const typeKey = bossKeys[typeIndex];
            const type = BOSS_TYPES[typeKey];
            const hp = BALANCE.BOSS_BASE_HP * Math.pow(BALANCE.BOSS_WAVE_GROWTH, wave / 10);

            ['p1', 'p2'].forEach(owner => {
                const start = owner === 'p1' ? paths.p1[0] : paths.p2[0];
                enemies.push({
                    id: generateId(),
                    x: start.x, y: start.y,
                    owner: owner,
                    pathIndex: 1,
                    maxHp: hp, hp: hp, virtualHp: hp,
                    speed: 1.0,
                    isBoss: true, bossType: typeKey,
                    color: type.color, size: 55, skillTimer: 0,
                    rewardSp: (10 + Math.floor((wave - 1) / 5) * 5) * 20
                });
            });
        }

        // --- 7. 戰鬥核心 (Client Side Visual + Host Side Logic) ---
        function updateCombat() {
            // 我方攻擊
            processSlotsCombat(mySlots, role === 'host' ? 'p1' : 'p2');

            // 隊友攻擊 (只做視覺特效，傷害設為 0 或忽略) - 為了簡化，這裡 Client 端只運算自己的攻擊
            // Host 端因為擁有完整數據，其實可以運算所有人的攻擊，但為了效能，
            // 這裡採用：Host 算 P1 + P2 的真實傷害，Guest 算 P2 的視覺 + P1 視覺？
            // 最佳解：雙方都各自算自己的攻擊並扣減 enemy.virtualHp，
            // Host 最終確認 enemy.hp。Guest 看到的 hp 是 sync 過來的。

            // 修正策略：
            // Host: 執行 mySlots (P1) 攻擊 -> 扣 HP。執行 partnerSlots (P2) 攻擊 -> 扣 HP。
            // Guest: 執行 mySlots (P2) 攻擊 -> 發射子彈 (不扣真實 HP，等待 Host 同步)。

            if (role === 'host') {
                processSlotsCombat(partnerSlots, 'p2');
            } else {
                // Guest 改為也要運算 P1 (Partner) 的視覺效果
                processSlotsCombat(partnerSlots, 'p1');
            }

            // 子彈移動
            for (let i = projectiles.length - 1; i >= 0; i--) {
                let p = projectiles[i];
                if (!enemies.includes(p.target) || p.target.hp <= 0) {
                    projectiles.splice(i, 1); continue;
                }
                let dx = p.target.x - p.x, dy = p.target.y - p.y;
                let dist = Math.hypot(dx, dy);
                if (dist < p.speed) {
                    // 擊中
                    projectiles.splice(i, 1);
                    AudioManager.playHit();

                    // 視覺跳字
                    if (damagePopups.length < 20) {
                        damagePopups.push({ x: p.target.x, y: p.target.y, val: Math.floor(p.damage), life: 30, color: '#fff' });
                    }

                    // 實際扣血 (僅 Host)
                    if (role === 'host') {
                        applyDamageLogic(p.target, p.damage, p.diceId, p.attackerRole, p);
                    }
                } else {
                    p.x += (dx / dist) * p.speed;
                    p.y += (dy / dist) * p.speed;
                }
            }
        }

        // 處理一組插槽對敵人的攻擊
        function processSlotsCombat(slots, slotOwner) { // slotOwner: 'p1' or 'p2'
            // 計算太陽個數
            const sunCount = slots.filter(s => s.dice && s.dice.id === 'sun').length;
            const isSun = [1, 4, 7].includes(sunCount); // 簡化版太陽規則

            // --- 計算聖域加速 ---
            const sanctuaryCount = slots.filter(s => s.dice && s.dice.id === 'sanctuary').length;
            let sanctuaryBoost = 0;
            if (sanctuaryCount > 0) {
                const sanctuarySpec = getDiceSpecialValue('sanctuary', slotOwner);
                sanctuaryBoost = (sanctuarySpec / 100) * sanctuaryCount; // 每個聖域疊加
            }

            // --- 強風狂暴模式檢測 ---
            slots.forEach(slot => {
                if (slot.dice && slot.dice.id === 'mighty_wind') {
                    // 檢查是否該進入狂暴
                    if (!slot.dice.burstTimer) slot.dice.burstTimer = 0;
                    slot.dice.burstTimer++;

                    const burstDuration = getDiceSpecialValue('mighty_wind', slotOwner) * 60; // 秒轉幀
                    const burstCycle = 600; // 10秒週期

                    if (slot.dice.burstTimer >= burstCycle) {
                        slot.dice.burstTimer = 0;
                    }

                    // 前 N 秒狂暴
                    if (slot.dice.burstTimer < burstDuration) {
                        slot.dice.burstSpeed = 0.1; // 狂暴時 0.1 秒攻速
                    } else {
                        slot.dice.burstSpeed = null;
                    }
                }
            });

            slots.forEach(slot => {
                if (!slot.dice || slot.isBeingDragged || slot.isLocked) return;

                const db = ALL_DICES.find(d => d.id === slot.dice.id);
                if (!db) return; // Safety check

                const pLv = (slotOwner === 'p1' && role === 'host') || (slotOwner === 'p2' && role === 'guest')
                    ? (powerUpLevels[slot.dice.id] || 1)
                    : (partnerPowerUpLevels[slot.dice.id] || 1);

                // --- 成長骰子邏輯 ---
                if (slot.dice.id === 'growth') {
                    if (!slot.dice.growthTimer) slot.dice.growthTimer = 0;
                    slot.dice.growthTimer++;
                    const targetSeconds = getDiceSpecialValue('growth', slotOwner);
                    if (slot.dice.growthTimer >= targetSeconds * 60) {
                        if (slot.dice.lv < 7) {
                            // 隨機變成牌組中的骰子，星數+1
                            const newId = userData.deck[Math.floor(Math.random() * userData.deck.length)];
                            const newDb = ALL_DICES.find(d => d.id === newId);
                            slot.dice = {
                                id: newId,
                                lv: slot.dice.lv + 1,
                                baseColor: newDb.baseColor,
                                pattern: newDb.pattern || newId,
                                growthTimer: 0,
                                attackCooldown: 0
                            };
                            syncMyData(); // 同步進化後的骰子
                        }
                    }
                }

                // --- 小丑骰子邏輯 ---
                if (slot.dice.id === 'joker') {
                    // 檢查相鄰格子，複製其中一個非小丑骰子
                    const idx = slots.indexOf(slot);
                    if (idx !== -1) {
                        const col = idx % 5;
                        const row = Math.floor(idx / 5);
                        const neighbors = [];

                        // 檢查上下左右
                        [[0, -1], [0, 1], [-1, 0], [1, 0]].forEach(([dc, dr]) => {
                            const nCol = col + dc;
                            const nRow = row + dr;
                            if (nCol >= 0 && nCol < 5 && nRow >= 0 && nRow < 3) {
                                const nIdx = nRow * 5 + nCol;
                                const nSlot = slots[nIdx];
                                if (nSlot && nSlot.dice && nSlot.dice.id !== 'joker') {
                                    neighbors.push(nSlot.dice);
                                }
                            }
                        });

                        if (neighbors.length > 0) {
                            // 隨機選一個相鄰骰子
                            const copyTarget = neighbors[Math.floor(Math.random() * neighbors.length)];
                            const jokerSpec = getDiceSpecialValue('joker', slotOwner);
                            const inheritRatio = jokerSpec / 100;

                            // 複製骰子，但星數繼承比例
                            const inheritedLv = Math.max(1, Math.floor(copyTarget.lv * inheritRatio));
                            slot.dice = {
                                id: copyTarget.id,
                                lv: inheritedLv,
                                baseColor: copyTarget.baseColor,
                                pattern: copyTarget.pattern || copyTarget.id,
                                attackCooldown: 0
                            };
                            syncMyData(); // 同步變身後的骰子
                        }
                    }
                    return; // Joker 變身後本回合不攻擊
                }

                // --- 礦山骰子特殊處理 (產 SP) ---
                if (slot.dice.id === 'mine') {
                    let spd = Math.max(60, (db.stats.speed + (pLv - 1) * db.grow.speed) * 60);
                    slot.attackCooldown = (slot.attackCooldown || 0) + 1;
                    if (slot.attackCooldown >= spd) {
                        slot.attackCooldown = 0;
                        const spGain = getDiceSpecialValue('mine', slotOwner);

                        // 只有自己的 mine 才加自己的 SP
                        if ((slotOwner === 'p1' && role === 'host') || (slotOwner === 'p2' && role === 'guest')) {
                            battleState.sp += spGain;
                            updateUILive();
                        }
                    }
                    return; // Mine 不攻擊，直接返回
                }

                // 攻速計算 (轉換秒數為幀數)
                let spd = Math.max(10, (db.stats.speed + (pLv - 1) * db.grow.speed) * 60);

                // 強風狂暴模式覆蓋攻速
                if (slot.dice.id === 'mighty_wind' && slot.dice.burstSpeed) {
                    spd = slot.dice.burstSpeed * 60;
                }

                // 聖域加速 (對其他骰子生效)
                if (sanctuaryBoost > 0 && slot.dice.id !== 'sanctuary') {
                    spd *= (1 - sanctuaryBoost);
                }

                if (slot.dice.id === 'sun' && isSun) spd /= 1.5;
                if (spd < 5) spd = 5;

                slot.attackCooldown = (slot.attackCooldown || 0) + 1;
                if (slot.attackCooldown >= spd) {
                    // 尋找目標
                    const target = findTarget(slot, slotOwner);
                    if (target) {
                        slot.attackCooldown = 0;
                        let dmg = getDiceDamage(slot.dice, slotOwner, slot, slots);

                        // --- 彗星充能機制 ---
                        let isCometCharged = false;
                        if (slot.dice.id === 'comet') {
                            slot.dice.chargeCount = (slot.dice.chargeCount || 0) + 1;
                            if (slot.dice.chargeCount >= 5) {
                                const cometBoost = getDiceSpecialValue('comet', slotOwner) / 100;
                                dmg *= cometBoost; // 500% = ×5
                                isCometCharged = true;
                                slot.dice.chargeCount = 0;
                            }
                        }

                        // --- 連鎖骰子特殊處理 (彈射) ---
                        if (slot.dice.id === 'chain' && role === 'host') {
                            const chainSpec = getDiceSpecialValue('chain', slotOwner);
                            const boostPercent = chainSpec / 100;

                            let currentTarget = target;
                            let currentDamage = dmg;
                            const bouncedTargets = [target];

                            for (let i = 0; i < 3; i++) { // 包含主目標共三跳
                                if (!currentTarget) break;

                                // 即時扣血
                                currentTarget.hp -= currentDamage;

                                // 視覺特效：閃電線
                                if (i > 0) {
                                    visualEffects.push({
                                        type: 'lightning',
                                        start: { x: bouncedTargets[i - 1].x, y: bouncedTargets[i - 1].y },
                                        end: { x: currentTarget.x, y: currentTarget.y },
                                        life: 10, maxLife: 10
                                    });
                                }

                                // 傷害數字
                                if (damagePopups.length < 20) {
                                    damagePopups.push({
                                        x: currentTarget.x, y: currentTarget.y - 10,
                                        val: Math.floor(currentDamage),
                                        color: '#8b5cf6',
                                        life: 25
                                    });
                                }

                                // 尋找下一跳目標
                                const validEnemies = enemies.filter(e => {
                                    if (e.hp <= 0 || bouncedTargets.includes(e)) return false;
                                    // 權限檢查
                                    if (e.owner === slotOwner) return true;
                                    return e.pathIndex >= 3;
                                });

                                const next = validEnemies
                                    .sort((a, b) => Math.hypot(a.x - currentTarget.x, a.y - currentTarget.y) - Math.hypot(b.x - currentTarget.x, b.y - currentTarget.y))[0];

                                if (!next) break;
                                bouncedTargets.push(next);
                                currentTarget = next;
                                currentDamage *= (1 + boostPercent); // 每次彈射增傷
                            }
                            return; // Chain 處理完畢，跳過一般子彈邏輯
                        }

                        // 太陽特殊攻擊
                        if (slot.dice.id === 'sun' && isSun) {
                            createSunExplosion(target, dmg, slotOwner);
                        } else {
                            // 發射子彈
                            // 修正：無論 Host 或 Guest，只要有攻擊都應該產生子彈 (Guest 只做視覺，Host 做視覺+邏輯)
                            createProjectile(
                                { x: getSlotPixelX(slot, slotOwner), y: getSlotPixelY(slot, slotOwner) },
                                target,
                                slot.dice,
                                slotOwner,
                                dmg,
                                isCometCharged
                            );
                        }
                    }
                }
            });
        }

        function createProjectile(start, target, dice, owner, damage, isCometCharged) {
            const dmg = damage || getDiceDamage(dice, owner); // 使用傳入的傷害或計算
            projectiles.push({
                x: start.x, y: start.y,
                target: target,
                speed: 12,
                damage: dmg,
                color: dice.baseColor,
                life: 1, // alive
                diceId: dice.id, // 用於判斷特效
                attackerRole: owner, // 標記是誰發射的
                isCometCharged: isCometCharged || false // 彗星充能標記
            });
        }



        // --- 核心：索敵邏輯 (含區域限制) ---
        function findTarget(slot, attackerRole) {
            // 1. 篩選有效敵人
            // 規則：如果 enemy.pathIndex < 2，只能被 enemy.owner === attackerRole 的人打
            //       如果不在此限 (走到中間了)，雙方皆可打 (index >= 2)

            const validEnemies = enemies.filter(e => {
                if (e.hp <= 0) return false;
                // 如果是我自己的怪，一定可以打
                if (e.owner === attackerRole) return true;

                // 如果是隊友的怪，必須等到達交匯點 (Index >= 3)
                // pathIndex 代表"正在前往的點"。
                // 剛生成時往 1 走。
                // 到達 1 後往 2 走 (垂直段)。
                // 到達 2 後 (交匯點) 往 3 走 (水平共享段)。此時 pathIndex = 3。
                return e.pathIndex >= 3;
            });

            if (validEnemies.length === 0) return null;

            // 2. 排序 (走最遠的優先)
            validEnemies.sort((a, b) => {
                // pathIndex 越大越近終點
                if (b.pathIndex !== a.pathIndex) return b.pathIndex - a.pathIndex;

                // pathIndex 相同，比較距離下一個節點的距離 (越小越近，即越前面)
                const pathA = a.owner === 'p1' ? paths.p1 : paths.p2;
                const pathB = b.owner === 'p1' ? paths.p1 : paths.p2;

                // 防呆：避免 index 超出
                const nextNodeA = pathA[a.pathIndex] || { x: a.x, y: a.y }; // 其實 a.pathIndex 是目標點
                const nextNodeB = pathB[b.pathIndex] || { x: b.x, y: b.y };

                const distA = Math.hypot(nextNodeA.x - a.x, nextNodeA.y - a.y);
                const distB = Math.hypot(nextNodeB.x - b.x, nextNodeB.y - b.y);

                return distA - distB; // 距離越小排越前面
            });

            return validEnemies[0];
        }

        function createSunExplosion(target, dmg, attackerRole) {
            // 視覺
            const div = document.createElement('div');
            div.className = 'sun-explosion';
            // 需轉換為螢幕座標?? canvas 是絕對定位，可以直接用
            // 不過如果是 Guest 且 Canvas 被旋轉了... 這裡會有點麻煩
            // 簡單起見：只在 Canvas 內畫，不要用 DOM。或者 DOM 座標要換算。
            // 這裡先略過 DOM 特效，改用 Canvas 畫爆炸圈

            if (role === 'host') {
                // 造成 AOE 傷害
                enemies.forEach(e => {
                    // 檢查區域限制
                    let canHit = false;
                    if (e.owner === attackerRole) canHit = true;
                    else if (e.pathIndex >= 3) canHit = true;

                    if (canHit && Math.hypot(e.x - target.x, e.y - target.y) < 70) {
                        applyDamageLogic(e, dmg, 'sun', attackerRole);
                    }
                });
            }
        }

        function applyDamageLogic(target, dmg, type, attackerRole, projectile) {
            // 0. 應用易傷加成
            if (target.crackMark && target.crackMark > 0) {
                dmg *= (1 + target.crackMark);
            }

            // 1. 應用傷害
            target.hp -= dmg;

            if (target.hp <= 0) {
                const myOwner = (role === 'host' ? 'p1' : 'p2');
                if (target.owner === myOwner) {
                    // 取得該怪物的成長 SP
                    battleState.sp += (target.rewardSp || 10);
                    updateUILive();
                }
            }

            // 3. 特殊效果處理
            switch (type) {
                case 'fire':
                    // 濺射傷害
                    const fireSpec = getDiceSpecialValue('fire', attackerRole);
                    const splashRange = fireSpec * 40; // 1格 = 40px
                    enemies.forEach(e => {
                        if (e === target) return;
                        // 權限檢查
                        if (e.owner !== attackerRole && e.pathIndex < 3) return;

                        if (Math.hypot(e.x - target.x, e.y - target.y) < splashRange) {
                            e.hp -= dmg * 0.5; // 濺射 50% 傷害
                            if (damagePopups.length < 20) {
                                damagePopups.push({
                                    x: e.x, y: e.y - 10,
                                    val: Math.floor(dmg * 0.5),
                                    color: '#ef4444',
                                    life: 25
                                });
                            }
                        }
                    });
                    break;

                case 'wind':
                    // 連擊機率
                    const windSpec = getDiceSpecialValue('wind', attackerRole);
                    if (Math.random() * 100 < windSpec) {
                        target.hp -= dmg; // 再打一次
                        if (damagePopups.length < 20) {
                            damagePopups.push({
                                x: target.x + 10, y: target.y - 15,
                                val: Math.floor(dmg),
                                color: '#10b981',
                                life: 25
                            });
                        }
                    }
                    break;

                case 'ice':
                    // 緩速
                    const iceSpec = getDiceSpecialValue('ice', attackerRole);
                    target.speed = Math.max(0.3, 1.5 * (1 - iceSpec / 100));
                    clearTimeout(target.iceTimer);
                    target.iceTimer = setTimeout(() => { target.speed = 1.5; }, 1000);
                    break;

                case 'electric':
                    // 連鎖 (已經在這裡處理)
                    let chainCount = 0;
                    enemies.forEach(e => {
                        if (chainCount >= 3) return;
                        if (e === target) return;
                        if (e.owner !== attackerRole && e.pathIndex < 3) return;

                        if (Math.hypot(e.x - target.x, e.y - target.y) < 150) {
                            let chainDmg = dmg * 0.5;
                            e.hp -= chainDmg;
                            chainCount++;
                            damagePopups.push({
                                x: e.x, y: e.y - 15,
                                val: Math.floor(chainDmg),
                                color: '#facc15',
                                life: 30
                            });
                        }
                    });
                    break;

                case 'poison':
                    target.poisonStacks = (target.poisonStacks || 0) + 1;
                    break;

                case 'lock':
                    const lockSpec = getDiceSpecialValue('lock', attackerRole);
                    if (Math.random() < 0.2) {
                        target.speed = 0;
                        setTimeout(() => { target.speed = 1.5; }, lockSpec * 1000);
                    }
                    break;

                case 'crack':
                    // 易傷標記 (累積，最多5層)
                    const crackSpec = getDiceSpecialValue('crack', attackerRole);
                    const crackValue = crackSpec / 100;
                    target.crackMark = Math.max((target.crackMark || 0), crackValue); // 取最高值，不累加

                    // 視覺提示
                    if (damagePopups.length < 20) {
                        damagePopups.push({
                            x: target.x, y: target.y - 20,
                            val: '易傷!',
                            color: '#f87171',
                            life: 20
                        });
                    }
                    break;

                case 'teleport':
                    const teleportSpec = getDiceSpecialValue('teleport', attackerRole);
                    if (Math.random() * 100 < teleportSpec) {
                        if (target.isBoss) {
                            // Boss 眩暈 1 秒
                            const originalSpeed = target.speed;
                            target.speed = 0;
                            setTimeout(() => { target.speed = originalSpeed; }, 1000);
                        } else {
                            // 小怪傳送回起點
                            const path = target.owner === 'p1' ? paths.p1 : paths.p2;
                            target.x = path[0].x;
                            target.y = path[0].y;
                            target.pathIndex = 1;
                        }
                    }
                    break;

                case 'laser':
                    // Laser 增幅 (在子彈擊中時處理)
                    if (projectile) {
                        const laserSpec = getDiceSpecialValue('laser', attackerRole);
                        if (target.lastHitId === projectile.diceUid) {
                            target.laserStack = Math.min((target.laserStack || 1) + 1, laserSpec);
                        } else {
                            target.laserStack = 1;
                            target.lastHitId = projectile.diceUid;
                        }
                    }
                    break;

                case 'comet':
                    // Comet 爆炸特效 (如果是充能狀態)
                    if (projectile && projectile.isCometCharged) {
                        visualEffects.push({
                            type: 'explosion',
                            x: target.x, y: target.y,
                            radius: 80,
                            color: 'rgba(59, 130, 246, 0.8)',
                            life: 25, maxLife: 25
                        });
                    }
                    break;

                case 'doom':
                    // 毀滅標記
                    const doomSpec = getDiceSpecialValue('doom', attackerRole);
                    target.doomMark = {
                        damage: target.maxHp * (doomSpec / 100),
                        timer: 15000,
                        startTime: Date.now()
                    };
                    visualEffects.push({
                        type: 'explosion',
                        x: target.x, y: target.y,
                        radius: 50,
                        color: 'rgba(124, 58, 237, 0.7)',
                        life: 20, maxLife: 20
                    });
                    break;

                case 'galaxy':
                    // 黑洞效果
                    if (Math.random() < 0.05) {
                        blackHoles.push({ x: target.x, y: target.y, timer: 0, owner: attackerRole });
                    }
                    break;
            }
        }

        function getDiceDamage(dice, roleOverride, slot, slots) {
            if (!dice) return 0;
            const ref = ALL_DICES.find(d => d.id === dice.id);
            if (!ref) return 10;

            // 判斷是誰的骰子來決定用哪份等級表
            let lv = 1;
            const owner = roleOverride || role;

            if ((owner === 'p1' && role === 'host') || (owner === 'p2' && role === 'guest')) {
                // 這是自己的骰子
                lv = powerUpLevels[dice.id] || 1;
            } else {
                // 這是夥伴的骰子
                lv = partnerPowerUpLevels[dice.id] || 1;
            }

            // 基礎攻擊 + (等級-1)*成長 + (星數-1)*10%
            let dmg = ref.stats.atk + (lv - 1) * (ref.grow?.atk || 0);
            dmg = dmg * (1 + (dice.lv - 1) * 0.1);

            // --- 齒輪加成邏輯 ---
            if (dice.id === 'gear' && slot && slots) {
                const idx = slots.indexOf(slot);
                if (idx !== -1) {
                    const col = idx % 5;
                    const row = Math.floor(idx / 5);
                    let neighbors = 0;

                    slots.forEach((s, sIdx) => {
                        if (s.dice && s.dice.id === 'gear' && s !== slot) {
                            const sCol = sIdx % 5;
                            const sRow = Math.floor(sIdx / 5);
                            // 檢查是否相鄰 (上下左右)
                            if (Math.abs(sCol - col) + Math.abs(sRow - row) === 1) {
                                neighbors++;
                            }
                        }
                    });

                    const gearSpec = getDiceSpecialValue('gear', owner);
                    dmg *= (1 + neighbors * (gearSpec / 100));
                }
            }

            return dmg;
        }

        // 獲取骰子特殊值 (考慮等級成長)
        function getDiceSpecialValue(diceId, owner) {
            const ref = ALL_DICES.find(d => d.id === diceId);
            if (!ref || !ref.special) return 0;

            // 判斷是誰的骰子來決定用哪份等級表
            let lv = 1;
            if ((owner === 'p1' && role === 'host') || (owner === 'p2' && role === 'guest')) {
                lv = powerUpLevels[diceId] || 1;
            } else {
                lv = partnerPowerUpLevels[diceId] || 1;
            }

            return ref.special.value + (lv - 1) * (ref.special.grow || 0);
        }

        // 獲取 Slot 的像素座標 (邏輯座標系)


        // --- 8. 渲染 ---


        // --- 視角轉換函式 ---
        function tx(x) {
            return x; // 不翻轉 X，保持左右一致，僅翻轉上下 (Mirror View)
        }
        function ty(y) {
            return role === 'guest' ? canvas.height - y : y;
        }

        // --- 繪圖主函式 ---
        function draw() {
            // 清空畫布
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 0. 畫背景路徑
            // 路徑點也需要轉換
            const drawTransformedPath = (path, color) => {
                if (!path || path.length === 0) return;
                ctx.beginPath();
                ctx.strokeStyle = color; // 路徑顏色
                ctx.lineWidth = 40;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                const start = { x: tx(path[0].x), y: ty(path[0].y) };
                ctx.moveTo(start.x, start.y);

                for (let i = 1; i < path.length; i++) {
                    const p = { x: tx(path[i].x), y: ty(path[i].y) };
                    ctx.lineTo(p.x, p.y);
                }
                ctx.stroke();

                // 內細線
                ctx.lineWidth = 4;
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.stroke();
            };

            // 使用低透明度顏色，讓怪物(實色)能被區分
            drawTransformedPath(paths.p1, 'rgba(59, 130, 246, 0.2)');
            drawTransformedPath(paths.p2, 'rgba(244, 114, 182, 0.2)');

            // 1.5 畫傳送門
            const angle = (Date.now() / 1000) % (Math.PI * 2);
            // P1 (Host)
            if (paths.p1.length) {
                drawPortal(ctx, tx(paths.p1[0].x), ty(paths.p1[0].y), '#3b82f6', angle, true);
                const end = paths.p1[paths.p1.length - 1];
                drawPortal(ctx, tx(end.x), ty(end.y), '#ef4444', -angle, false);
            }
            // P2 (Guest)
            if (paths.p2.length) {
                drawPortal(ctx, tx(paths.p2[0].x), ty(paths.p2[0].y), '#f472b6', angle, true);
            }

            // 2. 畫格子與骰子
            // 根據角色決定顯示位置
            // Host: my=p1(Bottom), partner=p2(Top)
            // Guest: my=p2(Top->Flip->Bottom), partner=p1(Bottom->Flip->Top)
            const myOwner = role === 'host' ? 'p1' : 'p2';
            const partnerOwner = role === 'host' ? 'p2' : 'p1';

            drawDiceGrid(mySlots, myOwner);
            drawDiceGrid(partnerSlots, partnerOwner);

            // 3. 畫敵人
            enemies.forEach(e => {
                if (e.hp <= 0) return;
                const drawX = tx(e.x);
                const drawY = ty(e.y);
                const size = e.isBoss ? e.size : 20; // 確保 size 有值
                const renderSize = size || 20;

                // --- 衝刺視覺效果 (SNAKE Boss 技能) ---
                if (e.isSprinting) {
                    ctx.save();
                    // 繪製殘影拖尾
                    for (let trail = 3; trail > 0; trail--) {
                        ctx.globalAlpha = 0.15 * trail;
                        ctx.fillStyle = '#22c55e';
                        const trailOffset = trail * 8;
                        if (e.isBoss) {
                            ctx.beginPath();
                            ctx.arc(drawX - trailOffset * 0.5, drawY, renderSize / 2, 0, Math.PI * 2);
                            ctx.fill();
                        } else {
                            ctx.fillRect(drawX - renderSize / 2 - trailOffset, drawY - renderSize / 2, renderSize, renderSize);
                        }
                    }
                    ctx.restore();

                    // 綠色發光效果
                    ctx.save();
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#22c55e';
                }

                const color = e.isBoss ? (BOSS_TYPES[e.bossType]?.color || '#f00') :
                    (e.isSprinting ? '#22c55e' : (e.owner === 'p1' ? '#3b82f6' : '#f472b6'));

                if (e.isBoss) {
                    const bossImg = BOSS_TYPES[e.bossType]?.img;
                    if (bossImg && bossImg.complete) {
                        ctx.save();
                        const scale = 1 + Math.sin(Date.now() / 200) * 0.05;
                        ctx.translate(drawX, drawY);
                        ctx.scale(scale, scale);
                        // Guest 視角是否需要旋轉 Boss 圖片? 
                        // 不用，圖片本身朝向無所謂，甚至我們希望它看起來是正的
                        ctx.drawImage(bossImg, -renderSize / 2, -renderSize / 2, renderSize, renderSize);
                        ctx.restore();
                    } else {
                        ctx.fillStyle = color;
                        ctx.beginPath(); ctx.arc(drawX, drawY, renderSize / 2, 0, Math.PI * 2); ctx.fill();
                    }
                } else {
                    ctx.fillStyle = color;
                    ctx.fillRect(drawX - renderSize / 2, drawY - renderSize / 2, renderSize, renderSize);
                }

                // 結束衝刺發光
                if (e.isSprinting) {
                    ctx.restore();
                }

                // 血條 (始終在上方)
                const percent = Math.max(0, e.hp / e.maxHp);
                ctx.fillStyle = '#333';
                ctx.fillRect(drawX - 12, drawY - renderSize / 2 - 8, 24, 4);
                ctx.fillStyle = '#22c55e';
                ctx.fillRect(drawX - 12, drawY - renderSize / 2 - 8, 24 * percent, 4);
            });

            // 4. 畫子彈
            projectiles.forEach(p => {
                ctx.fillStyle = p.color || '#fff';
                ctx.beginPath(); ctx.arc(tx(p.x), ty(p.y), 4, 0, Math.PI * 2); ctx.fill();
            });

            // 5. 畫傷害與特效
            damagePopups.forEach(d => {
                ctx.fillStyle = d.color;
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(d.val, tx(d.x), ty(d.y));
                d.y -= 0.5; d.life--;
            });
            damagePopups = damagePopups.filter(d => d.life > 0);

            // 6. 畫黑洞
            blackHoles.forEach(bh => {
                const bx = tx(bh.x);
                const by = ty(bh.y);
                ctx.save();
                ctx.translate(bx, by);
                const rot = (Date.now() / 1000) * 2;
                ctx.rotate(rot);
                ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI * 2);
                ctx.fillStyle = '#000'; ctx.fill();
                ctx.strokeStyle = '#6366f1'; ctx.lineWidth = 2; ctx.stroke();

                // 吸入動畫
                for (let i = 0; i < 4; i++) {
                    ctx.rotate(Math.PI / 2);
                    ctx.beginPath(); ctx.moveTo(30 + Math.sin(Date.now() / 200) * 10, 0); ctx.lineTo(10, 0);
                    ctx.strokeStyle = 'rgba(99, 102, 241, 0.5)'; ctx.stroke();
                }
                ctx.restore();
            });

            // 拖曳中
            if (drag.isDragging && drag.dice) {
                // drag.currentX/Y 已經是 Input 座標
                // 在 handleInputMove 中我们需要根據 Guest 調整嗎？
                // 我們統一：drag.currentX/Y 儲存的是「螢幕/Canvas 像素座標」 (未經 tx/ty 轉換)
                // 但因為我們 drawDiceGrid 裡面用了 tx/ty，格子位置變了
                // 所以 InputEvent 裡面也需要做對應的逆轉換來判定格子?
                // 這裡單純畫拖曳物，直接畫在滑鼠位置即可
                renderDice(ctx, drag.currentX - grid.slotSize / 2, drag.currentY - grid.slotSize / 2, drag.dice, false);
            }
        }

        function drawPath(path, color) {
            if (path.length < 2) return;
            ctx.save();
            ctx.beginPath();
            ctx.strokeStyle = color + '44'; // 淡色
            ctx.lineWidth = 30;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.moveTo(path[0].x, path[0].y);
            path.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.stroke();

            // 虛線
            ctx.strokeStyle = '#ffffff44';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 15]);
            ctx.stroke();
            ctx.restore();
        }

        function drawPortal(ctx, x, y, color, angle, isStart) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);

            // 外圈光環
            const gradient = ctx.createRadialGradient(0, 0, 10, 0, 0, 30);
            gradient.addColorStop(0, color);
            gradient.addColorStop(1, 'rgba(0,0,0,0)');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, 30, 0, Math.PI * 2);
            ctx.fill();

            // 旋轉紋路
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            for (let i = 0; i < 4; i++) {
                ctx.rotate(Math.PI / 2);
                ctx.beginPath();
                ctx.moveTo(10, 0);
                ctx.quadraticCurveTo(20, 10, 25, 0);
                ctx.stroke();
            }

            // 中心黑洞/亮點
            ctx.fillStyle = isStart ? '#000' : '#fff';
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0, Math.PI * 2);
            ctx.fill();

            // 標示文字 (START / END) - 不旋轉
            ctx.rotate(-angle - (role === 'guest' ? Math.PI : 0)); // 抵銷旋轉，並修正 Guest 視角
            // Guest 視角下 canvas 其實已經 rotate(PI) 了。
            // 這裡的 angle 是 portal 自己的動畫。
            // 我們希望文字永遠正向顯示?
            // Canvas has global rotate PI for guest.
            // Text drawn here will be upside down for Guest if we don't fix it?
            // No, the global rotate handles everything.
            // But if we want text to be readable "upright" relative to the player...
            // Guest sees P2 (Top) as Bottom.
            // Actually, let's keep it simple, just symbols.

            ctx.restore();
        }

        function drawDiceGrid(slots, owner) {
            const isP1 = owner === 'p1';
            // 計算區域 Offset (改為固定 Margin 定位)
            const gridHeight = grid.rows * (grid.slotSize + grid.padding);
            const bottomMargin = 120;
            const topMargin = 120;

            const startY = isP1 ?
                canvas.height - gridHeight - bottomMargin :
                topMargin;

            const sideMargin = canvas.width * 0.12;

            slots.forEach(slot => {
                const rawX = sideMargin + grid.padding + slot.col * (grid.slotSize + grid.padding);
                const rawY = startY + slot.row * (grid.slotSize + grid.padding);

                // 應用視角轉換
                const drawX = tx(rawX);
                const drawY = ty(rawY);

                // 底座
                ctx.fillStyle = '#1e293b';
                drawRoundedRect(ctx, drawX, drawY, grid.slotSize, grid.slotSize, 8);
                ctx.fill();

                if (slot.dice && !slot.isBeingDragged) {
                    renderDice(ctx, drawX, drawY, slot.dice, slot.isLocked);
                }
            });
        }

        // 畫圓角矩形
        function drawRoundedRect(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y); ctx.lineTo(x + w - r, y); ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r); ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h); ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r); ctx.lineTo(x, y + r); ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
        }

        // --- 9. 操作事件 ---
        function setupTouchEvents() {
            // 統一轉換座標
            const getPos = (e) => {
                const rect = canvas.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                // 轉換為邏輯座標 (500 width base)
                return {
                    x: (clientX - rect.left) * scaleFactor,
                    y: (clientY - rect.top) * scaleFactor
                };
            };

            canvas.addEventListener('mousedown', e => {
                const p = getPos(e);
                handleInputStart(p.x, p.y);
            });
            canvas.addEventListener('mousemove', e => {
                const p = getPos(e);
                handleInputMove(p.x, p.y);
            });
            window.addEventListener('mouseup', handleInputEnd);

            canvas.addEventListener('touchstart', e => {
                e.preventDefault(); // 防止滾動
                const p = getPos(e);
                handleInputStart(p.x, p.y);
            }, { passive: false });
            canvas.addEventListener('touchmove', e => {
                e.preventDefault();
                const p = getPos(e);
                handleInputMove(p.x, p.y);
            }, { passive: false });
            window.addEventListener('touchend', handleInputEnd);
        }

        function handleInputStart(x, y) {
            // 轉換座標 (若為 Guest，輸入座標要反轉去對應邏輯座標?)
            // 我們的 mySlots 在邏輯上永遠是 P1 (Host) 的那塊區域嗎？
            // 不，mySlots 的渲染位置由 drawDiceGrid 決定。
            // Host: mySlots 在下方。 Input(x,y) 直接對應。
            // Guest: mySlots 在下方 (視覺上)。Input(x,y) 是手指位置。
            // 但因為 draw 時做了 rotate，所以 Guest 看到的「下方」其實是 Canvas 座標的「上方」(0,0 附近) 還是「下方」？
            // 讓我們釐清：
            // Guest Rotate 180: 原點 (0,0) 變右下，(w,h) 變左上。
            // 所以 Guest 點擊畫面下方 (高 Y)，對應到 Canvas 座標應該是 低 Y (因為被轉了)。
            // Canvas 邏輯座標系中，P2 (Guest) 的區域被定義在上方 (Y 小)。
            // 輸入座標 x, y 是 Canvas 上的像素座標
            // 我們比對 Slot 的視覺位置 = tx(Slot.rawX), ty(Slot.rawY)
            // 現在 tx(x) = x，所以視覺 X = 邏輯 X
            // ty(y) = H - y (if guest)

            const clicked = mySlots.find(slot => {
                // 取得 Slot 的 Raw 座標 (邏輯座標)
                const sx = getSlotPixelX(slot, role === 'host' ? 'p1' : 'p2');
                const sy = getSlotPixelY(slot, role === 'host' ? 'p1' : 'p2');

                // 轉成視覺座標
                const visualX = tx(sx);
                const visualY = ty(sy);

                // 判定距離
                return Math.abs(x - visualX) < grid.slotSize / 2 + 5 && Math.abs(y - visualY) < grid.slotSize / 2 + 5;
            });

            if (clicked && clicked.dice && !clicked.isLocked) {
                drag.isDragging = true;
                drag.fromSlot = clicked;
                drag.dice = { ...clicked.dice };
                drag.currentX = x; // 視覺座標
                drag.currentY = y;
                clicked.isBeingDragged = true;
            }
        }

        function handleInputMove(x, y) {
            if (drag.isDragging) {
                drag.currentX = x;
                drag.currentY = y;
            }
        }

        function handleInputEnd() {
            if (!drag.isDragging) return;

            const lx = drag.currentX;
            const ly = drag.currentY;

            // 判定目標格 (由視覺座標比對)
            const target = mySlots.find(slot => {
                const sx = getSlotPixelX(slot, role === 'host' ? 'p1' : 'p2');
                const sy = getSlotPixelY(slot, role === 'host' ? 'p1' : 'p2');
                const visualX = tx(sx);
                const visualY = ty(sy);

                return Math.abs(lx - visualX) < grid.slotSize / 2 + 10 && Math.abs(ly - visualY) < grid.slotSize / 2 + 10;
            });

            if (target && target !== drag.fromSlot) {
                // 合成邏輯
                if (target.dice && target.dice.id === drag.dice.id && target.dice.lv === drag.dice.lv && target.dice.lv < 7) {
                    // 成功合成
                    const newId = userData.deck[Math.floor(Math.random() * userData.deck.length)];
                    const db = ALL_DICES.find(d => d.id === newId);
                    if (db) {
                        target.dice = {
                            id: newId, lv: drag.dice.lv + 1,
                            baseColor: db.baseColor
                        };
                        drag.fromSlot.dice = null;
                        syncMyData();
                    }
                } else if (!target.dice) {
                    // 移動
                    target.dice = drag.dice;
                    drag.fromSlot.dice = null;
                    syncMyData();
                }
            }

            drag.fromSlot.isBeingDragged = false;
            drag.isDragging = false;
            drag.fromSlot = null;
        }

        function handleSummonClick() {
            if (battleState.sp < battleState.summonCost) return;
            // 找空位
            const empties = mySlots.filter(s => !s.dice);
            if (empties.length === 0) return;

            battleState.sp -= battleState.summonCost;
            battleState.summonCost += 10;

            const target = empties[Math.floor(Math.random() * empties.length)];
            const diceId = userData.deck[Math.floor(Math.random() * userData.deck.length)];
            const db = ALL_DICES.find(d => d.id === diceId);
            if (!db) return;

            target.dice = {
                id: diceId, lv: 1, baseColor: db.baseColor, pattern: db.pattern || diceId
            };

            syncMyData();
            updateUILive();
        }

        function powerUpDice(id) {
            const lv = powerUpLevels[id] || 1;
            const cost = 100 * Math.pow(2, lv - 1);
            if (battleState.sp >= cost && lv < 5) {
                battleState.sp -= cost;
                powerUpLevels[id] = lv + 1;
                syncMyData(); // Powerup 雖然不影響盤面結構，但會影響傷害，這部分 Host 算傷害時需要知道對方等級嗎？
                // 目前 syncMyData 只傳 slots.
                // 為了簡化，合作模式中「強化」只影響「自己」的傷害計算。
                // Host 幫 Guest 算傷害時，不知道 Guest 的等級。
                // 這是一個 bug。 Host 必須知道 Guest 的 diceLevels。
                // 修正：syncMyData 應該也要傳 diceLevels (powerUpLevels)。
                updateUI(); // 重新繪製按鈕
            }
        }

        function updateUILive() {
            // 1. 同步純文字狀態
            document.getElementById('hpText').innerText = battleState.hp;
            document.getElementById('spText').innerText = Math.floor(battleState.sp);
            document.getElementById('waveText').innerText = battleState.wave;
            document.getElementById('summonCostText').innerText = battleState.summonCost;

            // 2. 局部更新按鈕狀態 (只改顏色，不重繪 DOM)
            // 只有在 SP 變動影響到「買得起/買不起」的狀態時，視覺才需要變
            const currentSp = battleState.sp;

            userData.deck.forEach(id => {
                const btn = document.getElementById(`btn-power-${id}`);
                const costEl = document.getElementById(`cost-power-${id}`);
                if (!btn) return;

                const lv = powerUpLevels[id] || 1;
                const cost = 100 * Math.pow(2, lv - 1);
                const isMax = lv >= 5;

                // 處理邊框顏色
                // 如果滿等 -> 金色
                // 如果買得起 -> 藍色
                // 否則 -> 灰色
                // 我們直接操作 classList 比較安全，但因為有 tailwind class 混雜，可以暴力替換 border-*

                // 清除舊的 border color class
                btn.classList.remove('border-yellow-500', 'border-blue-500', 'border-slate-700', 'shadow-[0_0_5px_rgba(234,179,8,0.3)]');

                if (isMax) {
                    btn.classList.add('border-yellow-500', 'shadow-[0_0_5px_rgba(234,179,8,0.3)]');
                } else if (currentSp >= cost) {
                    btn.classList.add('border-blue-500');
                } else {
                    btn.classList.add('border-slate-700');
                }
            });
        }

        function updateUI() {
            const container = document.getElementById('powerUpButtons');
            if (!container) return;

            // 產生強化按鈕 (完全移植 dice_battle 風格)
            container.innerHTML = userData.deck.map((id) => {
                const dice = ALL_DICES.find(d => d.id === id);
                const lv = powerUpLevels[id] || 1;
                const cost = 100 * Math.pow(2, lv - 1);
                const q = QUALITIES[dice.quality] || QUALITIES.common;
                const isMax = lv >= 5;
                const costDisplay = isMax ? "MAX" : `${cost >= 1000 ? (cost / 1000).toFixed(1) + 'k' : cost} SP`;
                const costColor = isMax ? "text-orange-500" : "text-slate-400";
                const borderColor = isMax ? "border-yellow-500 shadow-[0_0_5px_rgba(234,179,8,0.3)]" :
                    (battleState.sp >= cost ? 'border-blue-500' : 'border-slate-700');

                // 注意：這裡我們在按鈕內放一個 canvas 畫骰子圖
                return `
                <button id="btn-power-${id}" onclick="${isMax ? '' : `powerUpDice('${id}')`}" 
                    class="flex-1 min-w-[70px] bg-slate-800 border ${borderColor} rounded-lg py-1.5 flex flex-col items-center ${isMax ? '' : 'active:scale-95'} transition-all mx-1">
                    <div class="w-8 h-8 rounded bg-white relative mb-1 overflow-hidden" style="border: 1px solid ${q.color}">
                        <canvas id="pwr-canvas-${id}" width="32" height="32" class="absolute inset-0 pointer-events-none"></canvas>
                    </div>
                    <div class="text-[9px] text-yellow-500 font-bold leading-none">Lv.${lv}</div>
                    <div id="cost-power-${id}" class="text-[8px] ${costColor} mt-1 font-bold tracking-tighter">${costDisplay}</div>
                </button>`;
            }).join('');

            // 繪製按鈕上的小骰子
            setTimeout(() => {
                userData.deck.forEach(id => {
                    const dice = ALL_DICES.find(d => d.id === id);
                    const canvas = document.getElementById(`pwr-canvas-${id}`);
                    if (canvas && dice) {
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        // 使用新的 drawDiceFeature
                        drawDiceFeature(ctx, 0, 0, canvas.width, dice.pattern || dice.id, dice.baseColor);
                    }
                });
            }, 0);
        }

        function initUI() {
            updateUI();
        }

        // 啟動
        init();

        function handleGameOver() {
            battleState.isStarted = false;

            // 取得雙方姓名與當前波數
            const p1Name = battleState.p1Name || "Player 1";
            const p2Name = battleState.p2Name || "Player 2";
            const finalWave = battleState.wave;

            // --- 1. 更新本地最高波數 (僅用於 UI 顯示) ---
            if (finalWave > dice_data.maxWave) {
                dice_data.maxWave = finalWave;
                localStorage.setItem('dice_game_data', JSON.stringify(dice_data));
            }

            // --- 2. 房主 (Host) 負責上傳排行榜與同步狀態 ---
            if (role === 'host') {
                // 同步 RTDB 狀態，讓 Guest 也能觸發結束
                db.ref(`coop_rooms/${roomId}`).update({
                    gameover: true,
                    hp: 0,
                    wave: finalWave
                });

                // 寫入 Firestore 排行榜集合 (包含雙方姓名與出戰的 5 顆骰子)
                fs.collection('cooper_record').add({
                    p1Name: p1Name,
                    p2Name: p2Name,
                    p1Deck: role === 'host' ? dice_data.deck : (hostDeckCache || []),
                    p2Deck: role === 'host' ? (partnerDeckCache || []) : dice_data.deck,
                    wave: finalWave,
                    timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                    roomId: roomId
                }).then(() => {
                    console.log("全球排行榜紀錄已上傳");
                }).catch(err => {
                    console.error("排行榜上傳失敗", err);
                });
            }

            // --- 3. 顯示結算畫面 ---
            const p1Display = document.getElementById('p1-name-display');
            const p2Display = document.getElementById('p2-name-display');
            if (p1Display) p1Display.innerText = p1Name;
            if (p2Display) p2Display.innerText = p2Name;

            document.getElementById('final-wave').innerText = finalWave;
            document.getElementById('game-over-modal').classList.remove('hidden');
        }

        // --- 繪圖函式 (移植自 dice_battle) ---
        function renderDice(ctx, x, y, dice, isLocked) {
            if (!dice) return;
            // 確保 slotSize 存在
            const slotSize = grid.slotSize;
            const q = QUALITIES[ALL_DICES.find(d => d.id === dice.id)?.quality || 'common'];

            // 1. 畫外框 (品質顏色)
            ctx.beginPath();
            ctx.strokeStyle = q.color || '#fff';
            ctx.lineWidth = 3;
            drawRoundedRect(ctx, x + 4, y + 4, slotSize - 8, slotSize - 8, 8);
            ctx.stroke();

            // 2. 畫填充背景 (白色)
            ctx.beginPath();
            ctx.fillStyle = "#ffffff";
            drawRoundedRect(ctx, x + 6, y + 6, slotSize - 12, slotSize - 12, 6);
            ctx.fill();

            const dColor = dice.baseColor || "#333";
            const pattern = ALL_DICES.find(d => d.id === dice.id)?.pattern || dice.id;
            const drawX = x + 6;
            const drawY = y + 6;
            const drawSize = slotSize - 12;

            // 3. 畫特徵圖案
            drawDiceFeature(ctx, drawX, drawY, drawSize, pattern, dColor);

            // 4. 畫點數 (星級)
            drawDiceStars(ctx, drawX, drawY, drawSize, dice.lv, dColor);

            // 5. 鎖定遮罩
            if (isLocked) {
                ctx.save();
                ctx.beginPath();
                ctx.fillStyle = "rgba(15, 23, 42, 0.75)";
                drawRoundedRect(ctx, x + 5, y + 5, slotSize - 10, slotSize - 10, 8);
                ctx.fill();
                ctx.beginPath();
                ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
                ctx.lineWidth = 2;
                const p = slotSize * 0.3;
                ctx.moveTo(x + p, y + p); ctx.lineTo(x + slotSize - p, y + slotSize - p);
                ctx.moveTo(x + slotSize - p, y + p); ctx.lineTo(x + p, y + slotSize - p);
                ctx.stroke();
                ctx.restore();
            }
        }

        function drawDiceFeature(ctx, x, y, size, pattern, diceColor) {
            const m = size / 2;
            ctx.save();
            ctx.translate(x, y);

            const r = parseInt(diceColor.slice(1, 3), 16);
            const g = parseInt(diceColor.slice(3, 5), 16);
            const b = parseInt(diceColor.slice(5, 7), 16);
            ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.3)`;
            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.12)`;
            ctx.lineWidth = 4;
            ctx.lineCap = "round";
            ctx.lineJoin = "round";

            switch (pattern) {
                case 'fire':
                    ctx.beginPath();
                    ctx.moveTo(m, size * 0.2); ctx.lineTo(size * 0.8, size * 0.8); ctx.lineTo(size * 0.2, size * 0.8);
                    ctx.closePath(); ctx.stroke(); ctx.fill();
                    break;
                case 'ice':
                    ctx.beginPath(); ctx.arc(m, m, size * 0.35, 0, Math.PI * 2);
                    ctx.moveTo(m, size * 0.1); ctx.lineTo(m, size * 0.9);
                    ctx.moveTo(size * 0.1, m); ctx.lineTo(size * 0.9, m);
                    ctx.stroke();
                    break;
                case 'wind':
                    ctx.beginPath();
                    for (let i = -1; i <= 1; i++) {
                        ctx.moveTo(size * 0.2, m + (i * 12)); ctx.lineTo(size * 0.8, m + (i * 12));
                    }
                    ctx.stroke();
                    break;
                case 'electric':
                    ctx.beginPath();
                    ctx.moveTo(m + 5, size * 0.15); ctx.lineTo(m - 10, m + 5);
                    ctx.lineTo(m + 10, m - 5); ctx.lineTo(m - 5, size * 0.85);
                    ctx.stroke();
                    break;
                case 'poison':
                    ctx.beginPath();
                    ctx.moveTo(m, size * 0.2); ctx.lineTo(size * 0.75, m);
                    ctx.lineTo(m, size * 0.8); ctx.lineTo(size * 0.25, m);
                    ctx.closePath(); ctx.stroke(); ctx.fill();
                    break;
                case 'lock':
                    ctx.strokeRect(size * 0.25, size * 0.25, size * 0.5, size * 0.5);
                    ctx.beginPath(); ctx.arc(m, m, 4, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'teleport':
                    ctx.beginPath(); ctx.arc(size * 0.3, m, size * 0.3, -Math.PI / 2, Math.PI / 2); ctx.stroke();
                    ctx.beginPath(); ctx.arc(size * 0.7, m, size * 0.3, Math.PI / 2, -Math.PI / 2); ctx.stroke();
                    break;
                case 'gear':
                    ctx.beginPath(); ctx.setLineDash([5, 5]); ctx.arc(m, m, size * 0.35, 0, Math.PI * 2); ctx.stroke();
                    ctx.setLineDash([]); ctx.beginPath(); ctx.arc(m, m, size * 0.15, 0, Math.PI * 2); ctx.stroke();
                    break;
                case 'joker':
                    ctx.beginPath(); ctx.moveTo(size * 0.2, size * 0.3); ctx.lineTo(size * 0.8, size * 0.3); ctx.lineTo(m, size * 0.8); ctx.closePath(); ctx.stroke();
                    ctx.beginPath(); ctx.arc(size * 0.35, size * 0.2, 3, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(size * 0.65, size * 0.2, 3, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'growth':
                    ctx.beginPath(); ctx.moveTo(m, size * 0.15); ctx.lineTo(m, size * 0.85);
                    ctx.moveTo(m, size * 0.15); ctx.lineTo(size * 0.3, size * 0.4);
                    ctx.moveTo(m, size * 0.15); ctx.lineTo(size * 0.7, size * 0.4);
                    ctx.stroke();
                    break;
                case 'sun':
                    ctx.beginPath(); ctx.arc(m, m, size * 0.15, 0, Math.PI * 2); ctx.stroke(); ctx.fill();
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 8; i++) {
                        ctx.save(); ctx.translate(m, m); ctx.rotate((i * Math.PI / 4) + (Math.PI / 8));
                        ctx.beginPath(); ctx.moveTo(0, -size * 0.22); ctx.lineTo(0, -size * 0.32); ctx.stroke(); ctx.restore();
                    }
                    ctx.lineWidth = 4;
                    break;
                case 'galaxy':
                    ctx.beginPath(); ctx.moveTo(m, size * 0.1); ctx.bezierCurveTo(size * 0.9, size * 0.1, size * 0.1, size * 0.9, m, size * 0.9); ctx.stroke();
                    ctx.beginPath(); ctx.arc(m, m, size * 0.1, 0, Math.PI * 2); ctx.fill();
                    break;
            }
            ctx.restore();
        }

        function drawDiceStars(ctx, x, y, size, stars, diceColor) {
            if (stars >= 7) {
                ctx.save();
                ctx.fillStyle = "#fbbf24";
                ctx.font = `bold ${size * 0.7}px Arial`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText("★", x + size / 2, y + size / 2 + size * 0.05);
                ctx.restore();
                return;
            }

            ctx.fillStyle = diceColor || "#333";
            const dotSize = size * 0.07;
            const p = size * 0.22;
            const m = size / 2;
            const l = p, r = size - p;
            const t = p, b = size - p;

            let dots = [];
            if (stars === 1) dots = [[m, m]];
            else if (stars === 2) dots = [[l, t], [r, b]];
            else if (stars === 3) dots = [[l, t], [m, m], [r, b]];
            else if (stars === 4) dots = [[l, t], [r, t], [l, b], [r, b]];
            else if (stars === 5) dots = [[l, t], [r, t], [m, m], [l, b], [r, b]];
            else if (stars === 6) dots = [[l, t], [r, t], [l, m], [r, m], [l, b], [r, b]];

            dots.forEach(dot => {
                ctx.beginPath();
                ctx.arc(x + dot[0], y + dot[1], dotSize, 0, Math.PI * 2);
                ctx.fill();
            });
        }

    </script>
    <script>
        // --- 補強：座標計算函式 (修復 Guest 端子彈從中心發射與累積子彈導致的卡頓) ---
        // --- 補強：座標計算函式 (已修正為與 drawDiceGrid 邏輯一致的百分比定位) ---
        function getSlotPixelX(slot, owner) {
            const sideMargin = canvas.width * 0.12;
            const col = (slot && slot.col !== undefined) ? slot.col : 0;
            return sideMargin + grid.padding + col * (grid.slotSize + grid.padding) + grid.slotSize / 2;
        }

        function getSlotPixelY(slot, owner) {
            // 必須與 drawDiceGrid 的邏輯完全對齊 (固定 120px Margin)
            const row = (slot && slot.row !== undefined) ? slot.row : 0;
            const isP1 = owner === 'p1';

            const gridHeight = grid.rows * (grid.slotSize + grid.padding);
            const bottomMargin = 120;
            const topMargin = 120;

            // P1 (Bottom), P2 (Top)
            const startY = isP1 ?
                canvas.height - gridHeight - bottomMargin :
                topMargin;

            return startY + row * (grid.slotSize + grid.padding) + grid.slotSize / 2;
        }
        function leaveRoomAndCleanUp() {
            if (role === 'host') {
                // 房主離開時，徹底刪除 RTDB 房間節點
                db.ref(`coop_rooms/${roomId}`).remove().finally(() => {
                    location.href = 'dice.html';
                });
            } else {
                // 隊友離開時，把自己從 players/p2 移除即可
                db.ref(`coop_rooms/${roomId}/players/p2`).remove().finally(() => {
                    location.href = 'dice.html';
                });
            }
        }
    </script>
    <!-- Game Over Modal -->
    <div id="game-over-modal"
        class="fixed inset-0 bg-black/80 flex items-center justify-center z-[100] hidden backdrop-blur-sm">
        <div class="bg-slate-800 p-8 rounded-2xl border border-slate-600 text-center max-w-sm mx-4 shadow-2xl">
            <h2 class="text-3xl font-black text-white mb-2 tracking-wider">GAME OVER</h2>
            <div class="mb-6 space-y-2">
                <div class="flex justify-between text-blue-400 font-bold text-lg">
                    <span>P1: <span id="p1-name-display">Player 1</span></span>
                </div>
                <div class="flex justify-between text-pink-400 font-bold text-lg">
                    <span>P2: <span id="p2-name-display">Player 2</span></span>
                </div>
            </div>
            <p class="text-slate-400 mb-8 text-lg">共堅持了 <span id="final-wave"
                    class="text-yellow-400 font-bold text-3xl mx-1">0</span> 波</p>
            <button onclick="leaveRoomAndCleanUp()"
                class="w-full py-4 bg-gradient-to-r from-blue-600 to-indigo-600 rounded-xl font-bold text-white text-xl shadow-lg active:scale-95 transition-all hover:scale-105">
                返回大廳
            </button>
        </div>
    </div>
</body>

</html>