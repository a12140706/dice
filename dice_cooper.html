<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>隨機骰子 - 聯機合作模式</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://www.gstatic.com/firebasejs/9.16.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.16.0/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.16.0/firebase-firestore-compat.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            height: 100dvh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #0f172a;
            /* Slate-900 for desktop bg */
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        #game-wrapper {
            width: 100%;
            max-width: 500px;
            /* Mobile width constraint */
            height: 100%;
            max-height: 100dvh;
            display: flex;
            flex-direction: column;
            background-color: #020617;
            position: relative;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
            margin: 0 auto;
        }

        /* 太陽爆炸光圈 */
        .sun-explosion {
            position: absolute;
            border: 3px solid #fb923c;
            background: rgba(251, 146, 60, 0.3);
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            animation: sunExplode 0.4s ease-out forwards;
            z-index: 100;
            box-shadow: 0 0 15px orange;
        }

        @keyframes sunExplode {
            0% {
                width: 0px;
                height: 0px;
                opacity: 1;
            }

            100% {
                width: 130px;
                height: 130px;
                opacity: 0;
            }
        }

        #header-info {
            flex-shrink: 0;
            padding-top: max(12px, env(safe-area-inset-top));
            padding-left: 12px;
            padding-right: 12px;
            padding-bottom: 12px;
        }

        #footer-controls {
            flex-shrink: 0;
            padding: 12px;
            padding-bottom: max(20px, env(safe-area-inset-bottom, 20px));
            background: rgba(15, 23, 42, 0.95);
            border-top: 1px solid rgba(51, 65, 85, 0.5);
            z-index: 50;
            /* Ensure on top */
        }

        #canvas-container {
            position: relative;
            width: 100%;
            flex-grow: 1;
            overflow: hidden;
            background: #000;
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #1e1e24 0%, #000000 100%);
        }

        .pb-safe {
            padding-bottom: calc(0.75rem + env(safe-area-inset-bottom)) !important;
        }
    </style>
</head>

<body>

    <div id="game-wrapper">
        <div id="header-info" class="p-3 flex justify-between items-center bg-slate-900/80 border-b border-slate-800">
            <div class="flex items-center gap-4">
                <span class="text-red-500 font-bold">HP: <span id="hpText">3</span></span>
                <span class="text-blue-400 font-bold">SP: <span id="spText">100</span></span>
            </div>
            <div class="text-slate-400 font-bold text-xs">ROOM: <span id="room-id" class="text-emerald-500">----</span>
            </div>
            <div class="text-slate-400 font-bold text-sm">WAVE: <span id="waveText">1</span></div>
        </div>

        <div id="canvas-container">
            <canvas id="gameCanvas"></canvas>
        </div>

        <div id="footer-controls" class="pb-safe">
            <div class="flex flex-nowrap w-full gap-1 mb-4" id="powerUpButtons"></div>
            <button onclick="handleSummonClick()"
                class="w-full py-4 bg-blue-600 rounded-xl font-black text-xl shadow-lg active:scale-95 transition-all text-white">
                召喚骰子 (<span id="summonCostText">10</span> SP)
            </button>
        </div>
    </div>

    <script>
        // --- 1. 遊戲基礎資料 (整合 Dice Battle) ---
        const QUALITIES = {
            common: { name: '普通', color: '#ffffff', chance: 0.60 },
            rare: { name: '稀有', color: '#3b82f6', chance: 0.25 },
            epic: { name: '史詩', color: '#a855f7', chance: 0.10 },
            legend: { name: '傳說', color: '#eab308', chance: 0.04 },
            mythic: { name: '神話', color: '#ff00ff', chance: 0.01 }
        };

        const ALL_DICES = [
            // --- Common (普通) ---
            {
                id: 'fire', name: '火', quality: 'common', baseColor: '#ef4444', pattern: 'fire',
                stats: { atk: 18, speed: 55 }, grow: { atk: 6, speed: -1 },
                special: { label: '濺射範圍', value: 1.0, unit: '格', grow: 0.1 }
            },
            {
                id: 'wind', name: '風', quality: 'common', baseColor: '#10b981', pattern: 'wind',
                stats: { atk: 8, speed: 35 }, grow: { atk: 2, speed: -1.5 }, // 削弱基礎，讓出前期霸主位置
                special: { label: '連擊機率', value: 10, unit: '%', grow: 3 }
            },
            {
                id: 'ice', name: '冰', quality: 'common', baseColor: '#3b82f6', pattern: 'ice',
                stats: { atk: 7, speed: 60 }, grow: { atk: 1, speed: -1 },
                special: { label: '緩速效果', value: 20, unit: '%', grow: 2 }
            },
            {
                id: 'electric', name: '電', quality: 'common', baseColor: '#f59e0b', pattern: 'electric',
                stats: { atk: 6, speed: 45 }, grow: { atk: 2, speed: -1 },
                special: { label: '連鎖目標', value: 3, unit: '體', grow: 1 }
            },
            {
                id: 'poison', name: '毒', quality: 'common', baseColor: '#008000', pattern: 'poison',
                stats: { atk: 4, speed: 50 }, grow: { atk: 2, speed: -1 },
                special: { label: '中毒傷害', value: 12, unit: 'pt', grow: 4 }
            },

            // --- Rare (稀有) ---
            {
                id: 'lock', name: '鎖定', quality: 'rare', baseColor: '#64748b', pattern: 'lock',
                stats: { atk: 12, speed: 55 }, grow: { atk: 4, speed: -1 },
                special: { label: '禁錮時長', value: 0.8, unit: '秒', grow: 0.2 }
            },
            // --- 易傷骰子 (替代原本的破甲) ---
            {
                id: 'crack', name: '易傷', quality: 'rare', baseColor: '#f87171', pattern: 'crack',
                stats: { atk: 12, speed: 50 }, grow: { atk: 3, speed: -1 },
                special: { label: '額外受傷', value: 8, unit: '%', grow: 1 }
            },
            // --- 礦山骰子 (經濟型) ---
            {
                id: 'mine', name: '礦山', quality: 'rare', baseColor: '#fbbf24', pattern: 'mine',
                stats: { atk: 0, speed: 40 }, grow: { atk: 0, speed: -5 }, // 不攻擊，速度代表產錢間隔
                special: { label: '產出SP', value: 10, unit: 'pt', grow: 5 }
            },

            // --- Epic (史詩) ---
            {
                id: 'laser', name: '雷射', quality: 'epic', baseColor: '#ec4899', pattern: 'laser_beam',
                stats: { atk: 8, speed: 40 }, grow: { atk: 2, speed: 0 },
                special: { label: '增幅上限', value: 5, unit: '倍', grow: 1 }
                // 功能：持續攻擊同一個目標時，傷害會隨攻擊次數不斷爬升
            },
            {
                id: 'teleport', name: '傳送', quality: 'epic', baseColor: '#8b5cf6', pattern: 'teleport',
                stats: { atk: 10, speed: 65 }, grow: { atk: 3, speed: -1 },
                special: { label: '傳送回起點', value: 5, unit: '%', grow: 2 }
            },
            {
                id: 'gear', name: '齒輪', quality: 'epic', baseColor: '#475569', pattern: 'gear',
                stats: { atk: 15, speed: 50 }, grow: { atk: 8, speed: -1 },
                special: { label: '連結加成', value: 12, unit: '%', grow: 6 }
            },

            // --- Legend (傳說) ---
            {
                id: 'mighty_wind', name: '強風', quality: 'legend', baseColor: '#a5f3fc', pattern: 'mighty_wind',
                stats: { atk: 15, speed: 40 }, grow: { atk: 6, speed: -1 },
                special: { label: '狂暴時長', value: 2, unit: '秒', grow: 0.5 }
            },
            {
                id: 'joker', name: '小丑', quality: 'legend', baseColor: '#f87171', pattern: 'joker',
                stats: { atk: 5, speed: 50 }, grow: { atk: 1, speed: 0 },
                special: { label: '繼承比例', value: 80, unit: '%', grow: 2 } // 依照你的測試保留 80%
            },
            {
                id: 'growth', name: '成長', quality: 'legend', baseColor: '#f472b6', pattern: 'growth',
                stats: { atk: 5, speed: 50 }, grow: { atk: 1, speed: -1 },
                special: { label: '成長時間', value: 40, unit: '秒', grow: -2 } // 因應節奏調快，縮短至 40 秒
            },
            {
                id: 'sun', name: '太陽', quality: 'legend', baseColor: '#fbbf24', pattern: 'sun',
                stats: { atk: 35, speed: 55 }, grow: { atk: 15, speed: -0.5 },
                special: { label: '濺射傷害', value: 100, unit: '%', grow: 25 }
            },
            {
                id: 'sanctuary', name: '聖域', quality: 'legend', baseColor: '#fbbf24', pattern: 'sanctuary',
                stats: { atk: 15, speed: 60 }, grow: { atk: 6, speed: -1 },
                special: { label: '加速範圍', value: 30, unit: '%', grow: 5 }
            },
            {
                id: 'comet', name: '彗星', quality: 'legend', baseColor: '#3b82f6', pattern: 'comet',
                stats: { atk: 18, speed: 45 }, grow: { atk: 7, speed: -1 },
                special: { label: '充能倍率', value: 500, unit: '%', grow: 100 }
            },

            // --- Epic (史詩) 新增 ---
            {
                id: 'chain', name: '連鎖', quality: 'epic', baseColor: '#8b5cf6', pattern: 'chain',
                stats: { atk: 15, speed: 50 }, grow: { atk: 5, speed: -1 },
                special: { label: '彈射增傷', value: 50, unit: '%', grow: 10 }
            },

            // --- Mythic (神話) ---
            {
                id: 'doom', name: '毀滅', quality: 'mythic', baseColor: '#7c3aed', pattern: 'doom',
                stats: { atk: 45, speed: 50 }, grow: { atk: 20, speed: -1 },
                special: { label: '斬殺比例', value: 35, unit: '%', grow: 5 }
            },
            {
                id: 'galaxy', name: '銀河', quality: 'mythic', baseColor: '#6366f1', pattern: 'galaxy',
                stats: { atk: 60, speed: 50 }, grow: { atk: 30, speed: -1 },
                special: { label: '黑洞吞噬', value: 2, unit: '%', grow: 1 }
            }
        ];

        const BOSS_TYPES = {
            'CRUSHER': {
                name: '粉碎者', color: '#ff4444',
                img: (() => { const i = new Image(); i.src = 'dice-boss/lock.png'; return i; })(),
                skillInterval: 300,
                // 在 BOSS_TYPES 內的 'CRUSHER' 修改 onSkill
                onSkill: (boss) => {
                    // 限制：Host 只能運算技能，但透過事件通知
                    // 規則：Boss 是誰的，就鎖定誰的骰子
                    let targetPool = [];

                    // 根據 boss.owner 決定目標池
                    if (boss.owner === 'p1') {
                        targetPool = mySlots; // Host 自己的骰子
                    } else if (boss.owner === 'p2') {
                        targetPool = partnerSlots; // Host 眼中 隊友的骰子
                    }

                    // 找出該玩家沒被鎖定的骰子
                    const validTargets = targetPool.filter(s => s.dice && !s.isLocked);

                    if (validTargets.length > 0) {
                        const target = validTargets[Math.floor(Math.random() * validTargets.length)];

                        // 【流量優化】只寫入一個短暫的事件，而不是更新整個玩家狀態
                        // 寫入路徑：coop_rooms/{roomId}/bossEvent
                        db.ref(`coop_rooms/${roomId}/bossEvent`).set({
                            type: 'lock',
                            targetOwner: boss.owner, // 指定受害者
                            slotIndex: target.index, // 指定格子 ID
                            timestamp: Date.now() // 用於過濾舊事件
                        });
                    }
                }
            },
            'SNAKE': {
                name: '噴射者', color: '#22c55e',
                img: (() => { const i = new Image(); i.src = 'dice-boss/speed.png'; return i; })(),
                skillInterval: 240,
                onSkill: (boss) => {
                    // --- 修改這裡：只加速「屬於該 BOSS 擁有者」的怪物 ---

                    // 1. 篩選出同陣營的敵人 (Host 的怪 或 Guest 的怪)
                    const targetEnemies = enemies.filter(e => e.owner === boss.owner);

                    // 2. 執行加速
                    targetEnemies.forEach(e => e.speed *= 1.5);

                    // 3. 2秒後恢復 (Host 端執行即可，Guest 會自動跟隨座標變慢)
                    setTimeout(() => {
                        // 注意：這裡要重新篩選，因為 2 秒後可能有新怪，或者怪死掉了
                        // 但為了簡單與效能，我們直接對當下還活著的同陣營怪物減速
                        enemies.filter(e => e.owner === boss.owner).forEach(e => {
                            // 簡單防止速度變成 0 或過低，重置回基礎速度的邏輯比較安全
                            // 但這裡用除法還原是原版邏輯，維持原樣
                            e.speed /= 1.5;
                        });
                    }, 2000);
                }
            }
        };

        const BALANCE = {
            ENEMY_BASE_HP: 100, ENEMY_LEVEL_GROWTH: 1.25, ENEMY_WAVE_GROWTH: 1.20,
            BOSS_BASE_HP: 3000, BOSS_LEVEL_GROWTH: 1.6, BOSS_WAVE_GROWTH: 1.8
        };

        // --- 2. 初始化 ---
        const _k = ["AIzaSyDSRfVA", "uWCWCUd1NJop", "J6wHvsqsAM4UzJA"];

        const firebaseConfig = {
            apiKey: _k.join(''),
            authDomain: "game-80d68.firebaseapp.com",
            projectId: "game-80d68",
            databaseURL: "https://game-80d68-default-rtdb.asia-southeast1.firebasedatabase.app/",
            messagingSenderId: "636332967920",
            appId: "1:636332967920:web:29e5600daf4db0ab613f35",
            measurementId: "G-MJZ4PGEHSQ"
        };

        if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
        }
        const db = firebase.database();
        const fs = firebase.firestore();

        const urlParams = new URLSearchParams(window.location.search);
        const roomId = urlParams.get('roomId') || "COOP_TEST";
        const role = urlParams.get('role') || "host"; // 'host' (P1) or 'guest' (P2)
        document.getElementById('room-id').innerText = roomId + (role === 'host' ? " (房主)" : " (隊友)");

        const userData = JSON.parse(localStorage.getItem('dice_game_data')) || {
            deck: ['fire', 'wind', 'ice', 'electric', 'poison'],
            diceLevels: { 'fire': 1, 'wind': 1, 'ice': 1, 'electric': 1, 'poison': 1 },
            unlockLevel: 1
        };

        const AudioManager = {
            ctx: new (window.AudioContext || window.webkitAudioContext)(),
            buffers: {},
            async init() {
                const sounds = { 'hit': 'dice-sound/hit.wav' };
                for (const [name, url] of Object.entries(sounds)) {
                    try {
                        const response = await fetch(url);
                        const b = await response.arrayBuffer();
                        this.buffers[name] = await this.ctx.decodeAudioData(b);
                    } catch (e) { console.error(e); }
                }
            },
            playHit() {
                if (!this.buffers['hit'] || this.ctx.state === 'suspended') {
                    if (this.ctx.state === 'suspended') this.ctx.resume();
                    return;
                }
                const s = this.ctx.createBufferSource(); s.buffer = this.buffers['hit'];
                const g = this.ctx.createGain(); g.gain.value = 0.05;
                s.connect(g); g.connect(this.ctx.destination); s.start(0);
            }
        };
        AudioManager.init();

        // --- 3. 遊戲狀態 ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let battleState = { hp: 3, sp: 100, wave: 1, summonCost: 10, isStarted: false };
        let powerUpLevels = {};
        userData.deck.forEach(id => powerUpLevels[id] = 1);

        // 雙方盤面 (Host: my=P1, partner=P2; Guest: my=P2, partner=P1)
        // 為了邏輯統一，我們使用 mySlots 以及 partnerSlots
        let mySlots = [];
        let partnerSlots = [];

        // 網格佈局 (3x5)
        let grid = { rows: 3, cols: 5, padding: 8, slotSize: 0 };
        let drag = { isDragging: false, fromSlot: null, currentX: 0, currentY: 0, dice: null };

        let enemies = []; // 共享敵人列表 (含 owner: 'p1'|'p2' 及 pathIndex)
        let projectiles = [];
        let damagePopups = [];
        let frameCount = 0;
        let waveState = { total: 10, spawned: 0, timer: 0, waiting: false };
        let paths = { p1: [], p2: [] };

        // 太陽骰子狀態
        let isSunActivated = false;

        // --- 4. 初始化流程 ---
        function init() {
            resizeCanvas();
            // 監聽視窗變化，即時調整 Canvas 與路徑
            window.addEventListener('resize', () => {
                resizeCanvas();
                initPaths();
            });

            initGrid();
            initPaths();
            initUI();

            // 綁定操作事件
            setupTouchEvents();

            // Firebase 同步
            // Firebase 同步
            if (role === 'host') {
                resetRoomData();
            }
            startFirebaseSync();

            // 啟動迴圈
            battleState.isStarted = true;
            requestAnimationFrame(gameLoop);
            battleState.gameOverHandled = false;
        }

        function resetRoomData() {
            db.ref(`coop_rooms/${roomId}`).set({
                enemies: [],
                wave: 1,
                hp: 3,
                gameover: false,
                gameStats: { totalSp: 0, totalSpP2: 0 },
                players: {
                    p1: { slots: [], sp: 100, powerUpLevels: powerUpLevels },
                    p2: null // P2 重連後會自己更新
                }
            });
        }

        // 標準化邏輯解析度 (即使是兩隻手機，寬度也可能有微小差異導致座標錯位)
        const LOGICAL_WIDTH = 500;
        let scaleFactor = 1;

        function resizeCanvas() {
            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();

            // 強制內部邏輯寬度為 500，高度依比例縮放
            scaleFactor = LOGICAL_WIDTH / rect.width;

            canvas.width = LOGICAL_WIDTH;
            canvas.height = rect.height * scaleFactor;

            // 重新計算 Grid Size (響應式)
            if (grid.cols) {
                const sideMargin = canvas.width * 0.12;
                grid.slotSize = (canvas.width - (grid.cols + 1) * grid.padding - (sideMargin * 2)) / grid.cols;
            }
        }

        function initGrid() {
            // resizeCanvas 已經算好 slotSize，這裡只負責生格子
            if (mySlots.length === 0) {
                const createSlots = () => Array(15).fill(null).map((_, i) => ({
                    dice: null, isLocked: false, isBeingDragged: false, attackCooldown: 0,
                    index: i, col: i % 5, row: Math.floor(i / 5)
                }));
                mySlots = createSlots();
                partnerSlots = createSlots();
            }
        }



        // 路徑定義：從兩側出發，匯聚到中間
        // Index >= 4 為共享路徑 (中央直線)
        // 路徑定義：直角交會
        // Index >= 3 為共享路徑 (從交匯點往中央走)
        const MERGE_INDEX = 3; // 更新為 3: 直到抵達 index 2 (交匯點) 之後，開始往 3 走才算共享
        function initPaths() {
            const w = canvas.width;
            const h = canvas.height;
            const gap = 30;
            const midY = h / 2;

            // P1 (Host/Bottom) 路徑: 
            // 0: 右下 -> 1: 左下 -> 2: 左中(匯聚) -> 3: 中央點 -> 4: 終點
            paths.p1 = [
                { x: w - gap, y: h - gap },       // 0
                { x: gap, y: h - gap },           // 1
                { x: gap, y: midY },              // 2 (進入中央線)
                { x: w / 2, y: midY },            // 3 (中央點)
                { x: w + 50, y: midY }            // 4 (終點)
            ];

            // P2 (Guest/Top) 路徑:
            // 0: 右上 -> 1: 左上 -> 2: 左中(匯聚) -> 3: 中央點 -> 4: 終點
            paths.p2 = [
                { x: w - gap, y: gap },           // 0
                { x: gap, y: gap },               // 1
                { x: gap, y: midY },              // 2 (進入中央線)
                { x: w / 2, y: midY },            // 3
                { x: w + 50, y: midY }            // 4
            ];
        }

        // --- 5. Firebase 同步 ---
        function startFirebaseSync() {
            const roomRef = db.ref('coop_rooms/' + roomId);

            roomRef.on('value', (snap) => {
                const data = snap.val();
                if (!data) return;

                // --- A. 優先檢查遊戲結束 ---
                if (data.gameover === true) {
                    if (battleState.isStarted) {
                        battleState.hp = 0;
                        handleGameOver();
                    }
                    return;
                }

                // --- B. 共同狀態同步 (波數、血量) ---
                if (data.wave) battleState.wave = data.wave;
                if (data.hp !== undefined) battleState.hp = data.hp;

                // --- C. SP 邏輯處理 (原本的差值計算法) ---
                if (role === 'guest' && data.gameStats && data.gameStats.totalSpP2) {
                    const newTotal = data.gameStats.totalSpP2;
                    let diff = newTotal - (stateCache.lastTotalSpP2 || 0);

                    if (diff < 0) {
                        stateCache.lastTotalSpP2 = newTotal;
                        diff = 0;
                    }

                    if (diff > 0) {
                        battleState.sp += diff;
                        stateCache.lastTotalSpP2 = newTotal;
                        updateUILive();
                    }
                }

                // --- D. 角色特定同步 ---
                if (role === 'guest') {
                    // 1. 敵人同步 (包含補間動畫的座標承接)
                    if (data.enemies) {
                        const remoteEnemies = data.enemies || [];
                        remoteEnemies.forEach(newE => {
                            // 在現有的 enemies 中尋找同一個 ID 的怪
                            const oldE = enemies.find(o => o.id === newE.id);
                            if (oldE) {
                                // 【關鍵】承接舊的視覺座標 vX, vY，這樣 draw 的時候才不會瞬移
                                newE.vX = oldE.vX;
                                newE.vY = oldE.vY;
                            }
                        });
                        enemies = remoteEnemies;
                    }

                    // 2. 子彈同步 (由 Host 提供，Guest 直接接收)
                    //projectiles = data.projectiles || [];

                    // 3. 夥伴 (Host) 骰子與等級同步
                    if (data.players?.p1) {
                        updateSlotsFromSync(partnerSlots, data.players.p1.slots);
                        if (data.players.p1.powerUpLevels) {
                            partnerPowerUpLevels = data.players.p1.powerUpLevels;
                        }
                    }
                } else {
                    // Host 監聽 Guest 的數據
                    if (data.players?.p2) {
                        updateSlotsFromSync(partnerSlots, data.players.p2.slots);
                        // 同步夥伴等級
                        if (data.players.p2.powerUpLevels) {
                            partnerPowerUpLevels = data.players.p2.powerUpLevels;
                        }
                        // 同步 SP 用的 Cache
                        stateCache.totalSpP2 = data.gameStats?.totalSpP2 || 0;
                    }
                }

                updateUILive();
            });
            db.ref(`coop_rooms/${roomId}/bossEvent`).on('value', (snap) => {
                const event = snap.val();
                if (!event) return;

                // 防止重複處理舊事件 (超過 2 秒前的事件不理會)
                if (Date.now() - event.timestamp > 2000) return;

                // 判斷我是誰
                const me = role === 'host' ? 'p1' : 'p2';

                // 情況 1：受害者是我 (我鎖定我自己 -> 上傳狀態 -> 對方看到我被鎖)
                if (event.targetOwner === me) {
                    const slot = mySlots[event.slotIndex];
                    if (slot && slot.dice && !slot.isLocked) {
                        slot.isLocked = true;

                        // 鎖定 4 秒後解鎖
                        setTimeout(() => {
                            slot.isLocked = false;
                            syncMyData(); // 解鎖後同步
                        }, 4000);

                        syncMyData(); // 鎖定當下立刻同步，讓對方看到
                    }
                }

                // 情況 2：受害者是隊友 (我只做視覺更新，實際狀態等他的 syncMyData)
                // 這樣可以確保「兩方看到的都要一樣」，因為會有視覺回饋
                else {
                    const slot = partnerSlots[event.slotIndex];
                    if (slot && slot.dice) {
                        slot.isLocked = true; // 視覺上先鎖，等對方 Firebase 資料傳來會再次確認
                        // 這裡不設定 setTimeout 解鎖，因為會由對方的資料同步來解除
                    }
                }
            });

            // 立即同步一次初始資料 (Deck 與 Levels)
            syncMyData();
        }

        function updateSlotsFromSync(localSlots, remoteData) {
            if (!remoteData) return;
            remoteData.forEach((rSlot, i) => {
                const lSlot = localSlots[i];
                if (!lSlot.dice && rSlot.dice) {
                    // 新增骰子
                    lSlot.dice = rSlot.dice;
                } else if (lSlot.dice && !rSlot.dice) {
                    // 移除
                    lSlot.dice = null;
                } else if (lSlot.dice && rSlot.dice) {
                    // 更新
                    lSlot.dice.lv = rSlot.dice.lv;
                    lSlot.dice.id = rSlot.dice.id;
                    lSlot.dice.baseColor = rSlot.dice.baseColor;
                    lSlot.isLocked = rSlot.isLocked; // 同步鎖定狀態
                }
            });
        }

        function syncMyData() {
            const pKey = role === 'host' ? 'p1' : 'p2';
            // 只上傳必要資料以節省頻寬
            const simpleSlots = mySlots.map(s => ({
                dice: s.dice ? { id: s.dice.id, lv: s.dice.lv, baseColor: s.dice.baseColor } : null,
                isLocked: s.isLocked
            }));

            db.ref(`coop_rooms/${roomId}/players/${pKey}`).update({
                slots: simpleSlots,
                sp: battleState.sp,
                // 新增同步：讓對方知道我的牌組與等級
                deck: userData.deck,
                powerUpLevels: powerUpLevels
            });
        }

        // 夥伴的等級資訊
        let partnerPowerUpLevels = {};
        let lastSyncTime = 0;
        const SYNC_INTERVAL = 100;

        // --- 6. 遊戲迴圈 ---
        function gameLoop() {
            if (!battleState.isStarted) return;
            frameCount++;

            if (role === 'host') {
                updateHostLogic();
                updateCombat();

                // 【流量優化】每 15 幀 (約 0.25秒) 同步一次即可，不用太頻繁
                if (frameCount % 15 === 0) {
                    // 瘦身：只上傳必要欄位
                    const minifiedEnemies = enemies.map(e => ({
                        id: e.id,
                        x: Math.round(e.x), // 座標取整數，省字元
                        y: Math.round(e.y),
                        hp: Math.floor(e.hp),
                        maxHp: Math.floor(e.maxHp),
                        type: e.isBoss ? e.bossType : null, // Boss 才傳類型
                        isBoss: e.isBoss,
                        owner: e.owner,
                        // speed, pathIndex 等 Guest 可以自己推算或不需要
                    }));

                    db.ref(`coop_rooms/${roomId}`).update({
                        enemies: minifiedEnemies,
                        wave: battleState.wave,
                        hp: battleState.hp,
                        gameover: battleState.hp <= 0,
                        gameStats: { totalSpP2: stateCache.totalSpP2 || 0 }
                    });
                }
            } else {
                updateGuestLogic(); // 現在只負責平滑插值
                updateCombat();
            }

            draw();
            requestAnimationFrame(gameLoop);
        }
        // 專門給 Guest 用的子彈平滑移動 (純視覺)
        function updateProjectilesLocal() {
            projectiles.forEach(p => {
                // 根據子彈原本的速度向量移動
                // 如果你的子彈物件有 vx, vy，就直接加
                if (p.vx !== undefined && p.vy !== undefined) {
                    p.x += p.vx;
                    p.y += p.vy;
                } else {
                    // 如果沒有向量，則讓它向目標位置滑行 (簡單處理)
                    // 這部分取決於你原本 updateCombat 裡怎麼移動子彈的
                    // 建議保留原本 updateCombat 裡的子彈移動邏輯即可
                }
            });

            // 移除飛出邊界的子彈，避免 Guest 畫面堆積太多沒用的子彈
            projectiles = projectiles.filter(p =>
                p.x >= 0 && p.x <= canvas.width &&
                p.y >= 0 && p.y <= canvas.height
            );
        }
        // Guest 邏輯: 本地預測移動 (避免卡頓)
        // 修正：Guest 不計算邏輯移動，只做「視覺平滑跟隨」
        function updateGuestLogic() {
            enemies.forEach(e => {
                // 如果是剛生成的怪，還沒有視覺座標，直接初始化
                if (e.vX === undefined) {
                    e.vX = e.x;
                    e.vY = e.y;
                }

                // 核心算法：讓視覺座標 (vX, vY) 每次往 真實座標 (x, y) 靠近 15%
                // 這樣即使 Firebase 數據每 0.2 秒才來一次，怪物看起來也是滑順移動的
                const smoothFactor = 0.15;

                e.vX += (e.x - e.vX) * smoothFactor;
                e.vY += (e.y - e.vY) * smoothFactor;

                // 防瞬移機制：如果距離太遠（例如剛傳送），直接跳過去，避免飛越螢幕
                if (Math.hypot(e.x - e.vX, e.y - e.vY) > 100) {
                    e.vX = e.x;
                    e.vY = e.y;
                }
            });
        }

        // 黑洞列表
        let blackHoles = [];

        // --- Host 邏輯: 生怪與移動 ---
        // --- Host 邏輯: 生怪、移動、狀態更新與擊殺判定 ---
        function updateHostLogic() {
            // 1. Wave 管理 (生怪邏輯)
            if (!waveState.waiting) {
                waveState.timer++;
                let spawnRate = Math.max(15, 40 - battleState.wave);
                const isBossWave = battleState.wave % 10 === 0;
                const waveLimit = isBossWave ? 1 : waveState.total;

                if (waveState.timer >= spawnRate) {
                    if (waveState.spawned < waveLimit) {
                        if (isBossWave) spawnBoss();
                        else spawnEnemy();
                        waveState.spawned++;
                        waveState.timer = 0;
                    } else if (enemies.length === 0) {
                        waveState.waiting = true;
                        waveState.timer = 0;
                    }
                }
            } else {
                waveState.timer++;
                if (waveState.timer > 120) { // 休息 2 秒進下一波
                    battleState.wave++;
                    waveState.total += 2; // 每波多兩隻
                    waveState.spawned = 0;
                    waveState.waiting = false;
                    waveState.timer = 0;
                }
            }

            // 2. 黑洞邏輯 (Galaxy)
            for (let i = blackHoles.length - 1; i >= 0; i--) {
                const bh = blackHoles[i];
                bh.timer++;
                
                // 持續 2 秒 (120 frames)
                if (bh.timer > 120) { 
                    blackHoles.splice(i, 1);
                    continue;
                }

                // 吸附敵人
                enemies.forEach(e => {
                    // 權限判斷：只能吸 "屬於該黑洞主人的怪" 或 "公共區域的怪"
                    // 避免 P1 的黑洞把 P2 的怪吸過來卡住
                    let canHit = false;
                    if (e.owner === bh.owner) canHit = true;
                    else if (e.pathIndex >= 3) canHit = true; // 假設 pathIndex >= 3 是公共區

                    if (canHit) {
                        const dx = bh.x - e.x;
                        const dy = bh.y - e.y;
                        const dist = Math.hypot(dx, dy);
                        // 吸力範圍 150
                        if (dist < 150 && dist > 10) {
                            e.x += dx * 0.05; // 吸力強度
                            e.y += dy * 0.05;
                            
                            // 黑洞每幀造成微量傷害 (0.5 * 60 = 30 DPS)
                            // 這裡設定較低是因為黑洞主要功能是控場
                            e.hp -= 0.5; 

                            // 視覺：每 0.5 秒跳一次傷害數字
                            if (frameCount % 30 === 0) {
                                damagePopups.push({
                                    x: e.x + (Math.random() * 20 - 10),
                                    y: e.y - 10,
                                    val: 15, 
                                    color: '#6366f1', // Indigo
                                    life: 30
                                });
                            }
                        }
                    }
                });
            }

            // 3. 敵人狀態更新迴圈 (核心邏輯)
            for (let i = enemies.length - 1; i >= 0; i--) {
                let e = enemies[i];

                // --- 狀態效果：毒 (Poison) ---
                if (e.poisonStacks > 0) {
                    // 每秒傷害 = 層數 * 2
                    e.hp -= (e.poisonStacks * 2) / 60;
                    if (frameCount % 60 === 0) {
                        damagePopups.push({
                            x: e.x, y: e.y - 15,
                            val: Math.floor(e.poisonStacks * 2),
                            color: '#a855f7',
                            life: 40
                        });
                    }
                }

                // --- 狀態效果：毀滅 (Doom) ---
                if (e.doomMark) {
                    // 檢查是否過了持續時間 (15秒)
                    if (Date.now() - e.doomMark.startTime >= e.doomMark.duration) {
                        // 時間到：執行斬殺傷害
                        e.hp -= e.doomMark.damage;
                        
                        // 視覺特效：大爆炸與文字
                        damagePopups.push({ x: e.x, y: e.y, val: "DOOM", color: "#7c3aed", life: 60 });
                        visualEffects.push({ 
                            type: 'explosion', 
                            x: e.x, y: e.y, 
                            radius: 100, 
                            color: 'rgba(124, 58, 237, 0.9)', 
                            life: 30, maxLife: 30 
                        });
                        
                        // 移除標記，避免重複觸發
                        delete e.doomMark;
                    }
                }

                // --- 狀態恢復 (解凍、解鎖) ---
                // 優先權：鎖定 (Lock) > 冰凍 (Ice) > 正常
                if (e.lockTimer > 0) {
                    e.lockTimer--;
                    e.speed = 0; // 鎖定時完全靜止
                } else if (e.iceTimer > 0) {
                    e.iceTimer--;
                    // 冰凍時速度尚未恢復，維持被 ice 骰子設定的低速
                    // 這裡不需要特別設 e.speed，因為 applyDamageLogic 裡已經設了
                } else {
                    // 沒有任何異常狀態，恢復基礎速度
                    // 注意：如果有 Boss 加速 (Snake)，這裡可能會覆蓋掉
                    // 為了嚴謹，應該要有一個 baseSpeed，但為了簡化，我們先恢復為 1.5
                    // 如果場上有 Snake Boss 發動技能，onSkill 會再次覆蓋這個值
                    e.speed = 1.5; 
                }

                // --- Boss 技能觸發 ---
                if (e.isBoss) {
                    e.skillTimer = (e.skillTimer || 0) + 1;
                    if (e.skillTimer >= BOSS_TYPES[e.bossType].skillInterval) {
                        BOSS_TYPES[e.bossType].onSkill(e);
                        e.skillTimer = 0;
                    }
                }

                // --- 移動邏輯 ---
                const path = e.owner === 'p1' ? paths.p1 : paths.p2;
                const target = path[e.pathIndex];

                if (target) {
                    let dx = target.x - e.x;
                    let dy = target.y - e.y;
                    let dist = Math.hypot(dx, dy);

                    if (dist < e.speed) {
                        e.pathIndex++;
                        // 如果超出路徑長度，代表進入終點
                        if (e.pathIndex >= path.length) {
                            battleState.hp--;
                            // 檢查是否 Game Over
                            if (battleState.hp <= 0) {
                                handleGameOver();
                            }
                            // 移除敵人
                            enemies.splice(i, 1);
                            continue; // 進入下一次迴圈
                        }
                    } else {
                        // 正常移動
                        e.x += (dx / dist) * e.speed;
                        e.y += (dy / dist) * e.speed;
                    }
                }

                // --- 死亡判定與 SP 分配 ---
                if (e.hp <= 0) {
                    // 1. 根據是誰的怪，給誰 SP
                    if (e.owner === 'p1') {
                        battleState.sp += e.rewardSp;
                        stateCache.sp = battleState.sp; // 更新快取供 Firebase 上傳
                    } else {
                        // 如果是 P2 的怪，Host 不能直接改 P2 的 battleState.sp (那是 Guest 本地的)
                        // Host 必須把這筆錢記在 "公帳" (totalSpP2) 上
                        // Guest 端會監聽這個值，發現變多了就加自己的錢
                        stateCache.totalSpP2 = (stateCache.totalSpP2 || 0) + e.rewardSp;
                    }
                    
                    // 2. 移除敵人
                    enemies.splice(i, 1);
                }
            }
        }


        // 生成唯一 ID
        function generateId() {
            return Math.random().toString(36).substr(2, 9);
        }

        function spawnEnemy() {
            const level = userData.unlockLevel;
            const wave = battleState.wave;
            const hp = Math.max(10, BALANCE.ENEMY_BASE_HP * Math.pow(BALANCE.ENEMY_LEVEL_GROWTH, 0) * Math.pow(BALANCE.ENEMY_WAVE_GROWTH, wave - 1));

            // 同時在 P1 與 P2 路徑生成
            ['p1', 'p2'].forEach(owner => {
                const start = owner === 'p1' ? paths.p1[0] : paths.p2[0];
                enemies.push({
                    id: generateId(), // Add ID
                    x: start.x, y: start.y,
                    owner: owner,
                    pathIndex: 1, // 往第 1 個點走
                    maxHp: hp, hp: hp, virtualHp: hp,
                    speed: 1.5,
                    poisonStacks: 0,
                    isBoss: false
                });
            });
        }

        function spawnBoss() {
            const wave = battleState.wave;
            const typeKey = Object.keys(BOSS_TYPES)[Math.floor(Math.random() * Object.keys(BOSS_TYPES).length)];
            const type = BOSS_TYPES[typeKey];
            const hp = BALANCE.BOSS_BASE_HP * Math.pow(BALANCE.BOSS_WAVE_GROWTH, wave / 10);

            ['p1', 'p2'].forEach(owner => {
                const start = owner === 'p1' ? paths.p1[0] : paths.p2[0];
                enemies.push({
                    id: generateId(),
                    x: start.x, y: start.y,
                    owner: owner,
                    pathIndex: 1,
                    maxHp: hp, hp: hp, virtualHp: hp,
                    speed: 1.0,
                    isBoss: true, bossType: typeKey,
                    color: type.color, size: 55, skillTimer: 0
                });
            });
        }

        // --- 7. 戰鬥核心 (Client Side Visual + Host Side Logic) ---
        function updateCombat() {
            // 我方攻擊
            processSlotsCombat(mySlots, role === 'host' ? 'p1' : 'p2');

            if (role === 'host') {
                processSlotsCombat(partnerSlots, 'p2');
            }

            // 子彈移動（雙方各自計算，不同步）
            for (let i = projectiles.length - 1; i >= 0; i--) {
                let p = projectiles[i];
                if (!enemies.includes(p.target) || p.target.hp <= 0) {
                    projectiles.splice(i, 1);
                    continue;
                }
                let dx = p.target.x - p.x, dy = p.target.y - p.y;
                let dist = Math.hypot(dx, dy);
                if (dist < p.speed) {
                    projectiles.splice(i, 1);
                    AudioManager.playHit();

                    if (damagePopups.length < 20) {
                        damagePopups.push({
                            x: p.target.x,
                            y: p.target.y,
                            val: Math.floor(p.damage),
                            life: 30,
                            color: '#fff'
                        });
                    }

                    // 只有 Host 計算傷害
                    if (role === 'host') {
                        applyDamageLogic(p.target, p.damage, p.diceId, p.attackerRole);
                    }
                } else {
                    p.x += (dx / dist) * p.speed;
                    p.y += (dy / dist) * p.speed;
                }
            }
        }

        // 處理一組插槽對敵人的攻擊
        // 處理一組插槽對敵人的攻擊
        function processSlotsCombat(slots, slotOwner) { // slotOwner: 'p1' or 'p2'
            // 計算太陽個數
            const sunCount = slots.filter(s => s.dice && s.dice.id === 'sun').length;
            const isSun = [1, 4, 7].includes(sunCount); // 簡化版太陽規則

            slots.forEach(slot => {
                if (!slot.dice || slot.isBeingDragged || slot.isLocked) return;

                // 攻速計算
                const db = ALL_DICES.find(d => d.id === slot.dice.id);
                // 簡化：不計算等級成長，只算基礎
                let spd = db.stats.speed;
                if (slot.dice.id === 'sun' && isSun) spd /= 1.5;

                slot.attackCooldown = (slot.attackCooldown || 0) + 1;
                if (slot.attackCooldown >= spd) {
                    // 尋找目標
                    const target = findTarget(slot, slotOwner);
                    if (target) {
                        slot.attackCooldown = 0;
                        const dmg = getDiceDamage(slot.dice, slotOwner);

                        // 太陽特殊攻擊 (AOE)
                        if (slot.dice.id === 'sun' && isSun) {
                            createSunExplosion(target, dmg, slotOwner);
                        } else {
                            // 發射子彈 (一般攻擊)

                            // --- 修正後的邏輯 ---
                            // 無論我是 Host 還是 Guest，也無論這個骰子是誰的 (P1 或 P2)，
                            // 只要判定攻擊冷卻結束且有目標，就在本地畫面產生一顆「視覺子彈」。
                            // 這樣做不消耗網路流量，且能確保雙方畫面看起來一樣熱鬧。

                            createProjectile(
                                { x: getSlotPixelX(slot, slotOwner), y: getSlotPixelY(slot, slotOwner) },
                                target,
                                slot.dice,
                                slotOwner
                            );
                        }
                    }
                }
            });
        }

        function createProjectile(start, target, dice, owner) {
            const dmg = getDiceDamage(dice, owner);

            // 計算速度向量
            const dx = target.x - start.x;
            const dy = target.y - start.y;
            const dist = Math.hypot(dx, dy);
            const speed = 12;
            const vx = dist > 0 ? (dx / dist) * speed : 0;
            const vy = dist > 0 ? (dy / dist) * speed : 0;

            projectiles.push({
                x: start.x,
                y: start.y,
                vx: vx,  // 加入速度向量
                vy: vy,  // 加入速度向量
                target: target,
                speed: speed,
                damage: dmg,
                color: dice.baseColor,
                life: 1,
                diceId: dice.id,
                attackerRole: owner
            });
        }

        function getSlotPixelX(slot, owner) {
            // 計算插槽中心點
            const sideMargin = canvas.width * 0.12;
            const baseX = sideMargin + grid.padding + slot.col * (grid.slotSize + grid.padding) + grid.slotSize / 2;
            return baseX; // X 座標對於 P1 P2 是一樣的 (僅 Y 不同)
        }
        function getSlotPixelY(slot, owner) {
            // P1 (Host) 在下方，P2 (Guest) 在上方
            // 但注意，我們在 Render 時有對 Guest 做 rotate。
            // 這裡的邏輯座標應該是基於全局的。
            // P1 區域：Y = canvas.height - height/3 左右
            // P2 區域：Y = 0 + height/3 左右

            const totalH = grid.rows * (grid.slotSize + grid.padding);
            const p1Y = (canvas.height * 0.75) - (totalH / 2) + slot.row * (grid.slotSize + grid.padding) + grid.slotSize / 2;
            const p2Y = (canvas.height * 0.25) - (totalH / 2) + slot.row * (grid.slotSize + grid.padding) + grid.slotSize / 2;

            return owner === 'p1' ? p1Y : p2Y;
        }

        // --- 核心：索敵邏輯 (含區域限制) ---
        function findTarget(slot, attackerRole) {
            // 1. 篩選有效敵人
            // 規則：如果 enemy.pathIndex < 2，只能被 enemy.owner === attackerRole 的人打
            //       如果不在此限 (走到中間了)，雙方皆可打 (index >= 2)

            const validEnemies = enemies.filter(e => {
                if (e.hp <= 0) return false;
                // 如果是我自己的怪，一定可以打
                if (e.owner === attackerRole) return true;

                // 如果是隊友的怪，必須等到達交匯點 (Index >= 3)
                // pathIndex 代表"正在前往的點"。
                // 剛生成時往 1 走。
                // 到達 1 後往 2 走 (垂直段)。
                // 到達 2 後 (交匯點) 往 3 走 (水平共享段)。此時 pathIndex = 3。
                return e.pathIndex >= 3;
            });

            if (validEnemies.length === 0) return null;

            // 2. 排序 (走最遠的優先)
            validEnemies.sort((a, b) => {
                // pathIndex 越大越近終點
                if (b.pathIndex !== a.pathIndex) return b.pathIndex - a.pathIndex;

                // pathIndex 相同，比較距離下一個節點的距離 (越小越近，即越前面)
                const pathA = a.owner === 'p1' ? paths.p1 : paths.p2;
                const pathB = b.owner === 'p1' ? paths.p1 : paths.p2;

                // 防呆：避免 index 超出
                const nextNodeA = pathA[a.pathIndex] || { x: a.x, y: a.y }; // 其實 a.pathIndex 是目標點
                const nextNodeB = pathB[b.pathIndex] || { x: b.x, y: b.y };

                const distA = Math.hypot(nextNodeA.x - a.x, nextNodeA.y - a.y);
                const distB = Math.hypot(nextNodeB.x - b.x, nextNodeB.y - b.y);

                return distA - distB; // 距離越小排越前面
            });

            return validEnemies[0];
        }

        function createSunExplosion(target, dmg, attackerRole) {
            // 視覺
            const div = document.createElement('div');
            div.className = 'sun-explosion';
            // 需轉換為螢幕座標?? canvas 是絕對定位，可以直接用
            // 不過如果是 Guest 且 Canvas 被旋轉了... 這裡會有點麻煩
            // 簡單起見：只在 Canvas 內畫，不要用 DOM。或者 DOM 座標要換算。
            // 這裡先略過 DOM 特效，改用 Canvas 畫爆炸圈

            if (role === 'host') {
                // 造成 AOE 傷害
                enemies.forEach(e => {
                    // 檢查區域限制
                    let canHit = false;
                    if (e.owner === attackerRole) canHit = true;
                    else if (e.pathIndex >= 3) canHit = true;

                    if (canHit && Math.hypot(e.x - target.x, e.y - target.y) < 70) {
                        applyDamageLogic(e, dmg, 'sun', attackerRole);
                    }
                });
            }
        }

        // --- 完整版傷害邏輯 (與單人模式 1:1 一致) ---
        function applyDamageLogic(target, dmg, diceId, diceUid, attackerRole) {
            if (!target || target.hp <= 0) return;

            // 1. 易傷效果 (Crack) 計算
            if (target.vulnerability) {
                dmg *= (1 + target.vulnerability / 100);
            }

            // 2. 雷射 (Laser) 堆疊計算
            if (diceId === 'laser') {
                const spec = getDiceSpecialValue('laser'); // 增幅上限
                if (target.lastHitId === diceUid) {
                    target.laserStack = Math.min((target.laserStack || 1) + 1, spec);
                } else {
                    target.laserStack = 1;
                    target.lastHitId = diceUid;
                }
                dmg *= target.laserStack;
            }

            // 3. 扣血
            target.hp -= dmg;

            // 4. 擊殺判定與 SP 分配
            if (target.hp <= 0 && role === 'host') {
                if (target.owner === 'p1') {
                    battleState.sp += target.rewardSp || 10;
                    stateCache.sp = battleState.sp; 
                } else if (target.owner === 'p2') {
                    stateCache.totalSpP2 = (stateCache.totalSpP2 || 0) + (target.rewardSp || 10);
                }
                // 注意：這裡只處理直接傷害擊殺，狀態傷害擊殺在 updateHostLogic 處理
            }

            // 5. 顯示傷害數字
            if (damagePopups.length < 20) {
                const color = target.vulnerability ? "#f87171" : "#ffffff";
                damagePopups.push({ 
                    x: target.x, y: target.y, 
                    val: Math.floor(dmg), 
                    life: 30, 
                    color: color 
                });
            }

            // 6. 觸發骰子特殊效果
            const specVal = getDiceSpecialValue(diceId);

            switch (diceId) {
                case 'ice': // 冰：緩速
                    const slowFactor = (1 - specVal / 100);
                    target.speed = Math.max(0.3, 1.5 * slowFactor);
                    if (target.iceTimer) clearTimeout(target.iceTimer);
                    target.iceTimer = setTimeout(() => {
                        if (target && target.hp > 0) target.speed = 1.5;
                    }, 1000);
                    break;

                case 'lock': // 鎖定：機率暈眩
                    if (Math.random() < 0.2) {
                        target.speed = 0;
                        target.lockTimer = specVal * 60; // 轉為 frame (specVal是秒)
                    }
                    break;

                case 'crack': // 易傷
                    target.vulnerability = Math.max(target.vulnerability || 0, specVal);
                    break;

                case 'poison': // 毒
                    target.poisonStacks = (target.poisonStacks || 0) + 1;
                    break;

                case 'electric': // 電：連鎖
                    const chainRange = 150;
                    const chainMax = Math.floor(specVal); 
                    let chained = 0;
                    
                    enemies.forEach(e => {
                        if (chained >= chainMax) return;
                        if (e === target || e.hp <= 0) return;
                        
                        // 權限判斷：只能電自己的怪或公共怪
                        let canHit = false;
                        if (e.owner === attackerRole) canHit = true;
                        else if (e.pathIndex >= 3) canHit = true;
                        
                        if (!canHit) return;

                        if (Math.hypot(e.x - target.x, e.y - target.y) < chainRange) {
                            const chainDmg = dmg * 0.5;
                            e.hp -= chainDmg;
                            
                            // 視覺特效
                            visualEffects.push({
                                type: 'lightning',
                                start: { x: target.x, y: target.y },
                                end: { x: e.x, y: e.y },
                                life: 10, maxLife: 10
                            });
                            damagePopups.push({ 
                                x: e.x, y: e.y - 15, 
                                val: Math.floor(chainDmg), 
                                life: 20, color: "#fde047" 
                            });
                            chained++;
                        }
                    });
                    break;

                case 'teleport': // 傳送
                    if (Math.random() < (specVal / 100)) {
                        if (target.isBoss) {
                            // Boss 免疫傳送，改為暫停
                            const oldSpd = target.speed;
                            target.speed = 0;
                            setTimeout(() => { if(target) target.speed = oldSpd; }, 1000);
                        } else {
                            // 傳送回該怪物所屬路徑的起點
                            target.pathIndex = 1;
                            const path = target.owner === 'p1' ? paths.p1 : paths.p2;
                            target.x = path[0].x;
                            target.y = path[0].y;
                        }
                        visualEffects.push({ 
                            type: 'explosion', x: target.x, y: target.y, 
                            radius: 40, color: '#8b5cf6', life: 15, maxLife: 15 
                        });
                    }
                    break;

                case 'galaxy': // 銀河：黑洞
                    if (Math.random() < 0.05) { // 觸發機率可視需求調整
                         blackHoles.push({ 
                             x: target.x, y: target.y, 
                             timer: 0, 
                             owner: attackerRole,
                             force: specVal 
                         });
                    }
                    break;

                case 'doom': // 毀滅：斬殺標記
                    if (!target.doomMark) {
                        const doomDmg = target.maxHp * (specVal / 100);
                        target.doomMark = {
                            damage: doomDmg,
                            duration: 15000, // 15秒
                            startTime: Date.now()
                        };
                        visualEffects.push({
                            type: 'explosion', x: target.x, y: target.y,
                            radius: 50, color: '#7c3aed', life: 20, maxLife: 20
                        });
                    }
                    break;
            }
        }

        function getDiceDamage(dice, roleOverride) {
            if (!dice) return 0;
            const ref = ALL_DICES.find(d => d.id === dice.id);
            if (!ref) return 10;

            // 判斷是誰的骰子來決定用哪份等級表
            let lv = 1;
            // 如果調用時有指定 attackerRole，則根據 attackerRole 判斷
            // 但這裡 dice 物件本身沒有 owner 屬性 (是在 slots 裡管理的)
            // 所以我們需要上下文。
            // 修正：renderLoop 呼叫時 slot 物件沒有 owner 標記? 
            // 其實 drawDiceGrid 呼叫 renderDice 時也只傳 dice
            // 我們修改 updateCombat 把 owner 傳進來

            // 由於 `dice` 物件是 `{id, lv, baseColor}`，我們無法從 dice 本身知道是誰的
            // 所以 getDiceDamage 必須依賴外部傳入 `owner`

            // 暫時解決方案：如果 roleOverride 存在，用它。
            // 如果不存在，預設用自己的 (這可能不準確，但在 updateCombat 中我們會正確傳入)

            const owner = roleOverride || role;

            if ((owner === 'p1' && role === 'host') || (owner === 'p2' && role === 'guest')) {
                // 這是自己的骰子
                lv = powerUpLevels[dice.id] || 1;
            } else {
                // 這是夥伴的骰子
                lv = partnerPowerUpLevels[dice.id] || 1;
            }

            // 基礎攻擊 + (等級-1)*成長 + (星數-1)*10%
            let dmg = ref.stats.atk + (lv - 1) * (ref.grow?.atk || 0); // Added null check for grow.atk
            dmg = dmg * (1 + (dice.lv - 1) * 0.1);

            return dmg;
        }

        // --- 8. 渲染 ---


        // --- 視角轉換函式 ---
        function tx(x) {
            return x; // 不翻轉 X，保持左右一致，僅翻轉上下 (Mirror View)
        }
        function ty(y) {
            return role === 'guest' ? canvas.height - y : y;
        }

        // --- 繪圖主函式 ---
        function draw() {
            // 清空畫布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save(); // 【新增】保存目前座標狀態

            if (role === 'guest') {
                // 【新增】如果是 Guest，將畫布轉 180 度
                // 這會讓你原本寫的 tx(e.x), ty(e.y) 等座標自動在視覺上「上下顛倒」
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.rotate(Math.PI);
                ctx.translate(-canvas.width / 2, -canvas.height / 2);
            }
            // 0. 畫背景路徑
            // 路徑點也需要轉換
            const drawTransformedPath = (path, color) => {
                if (!path || path.length === 0) return;
                ctx.beginPath();
                ctx.strokeStyle = color; // 路徑顏色
                ctx.lineWidth = 40;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                const start = { x: tx(path[0].x), y: ty(path[0].y) };
                ctx.moveTo(start.x, start.y);

                for (let i = 1; i < path.length; i++) {
                    const p = { x: tx(path[i].x), y: ty(path[i].y) };
                    ctx.lineTo(p.x, p.y);
                }
                ctx.stroke();

                // 內細線
                ctx.lineWidth = 4;
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.stroke();
            };

            // 使用低透明度顏色，讓怪物(實色)能被區分
            drawTransformedPath(paths.p1, 'rgba(59, 130, 246, 0.2)');
            drawTransformedPath(paths.p2, 'rgba(244, 114, 182, 0.2)');

            // 1.5 畫傳送門
            const angle = (Date.now() / 1000) % (Math.PI * 2);
            // P1 (Host)
            if (paths.p1.length) {
                drawPortal(ctx, tx(paths.p1[0].x), ty(paths.p1[0].y), '#3b82f6', angle, true);
                const end = paths.p1[paths.p1.length - 1];
                drawPortal(ctx, tx(end.x), ty(end.y), '#ef4444', -angle, false);
            }
            // P2 (Guest)
            if (paths.p2.length) {
                drawPortal(ctx, tx(paths.p2[0].x), ty(paths.p2[0].y), '#f472b6', angle, true);
            }

            // 2. 畫格子與骰子
            // 根據角色決定顯示位置
            // Host: my=p1(Bottom), partner=p2(Top)
            // Guest: my=p2(Top->Flip->Bottom), partner=p1(Bottom->Flip->Top)
            const myOwner = role === 'host' ? 'p1' : 'p2';
            const partnerOwner = role === 'host' ? 'p2' : 'p1';

            drawDiceGrid(mySlots, myOwner);
            drawDiceGrid(partnerSlots, partnerOwner);

            // 3. 畫敵人
            enemies.forEach(e => {
                // 【平滑移動處理】
                if (role === 'guest') {
                    // 如果還沒有視覺座標，初始化它
                    if (e.vX === undefined) { e.vX = e.x; e.vY = e.y; }
                    // 視覺座標追蹤邏輯座標 (0.25 為平滑係數，讓移動不卡頓)
                    e.vX += (e.x - e.vX) * 0.25;
                    e.vY += (e.y - e.vY) * 0.25;
                } else {
                    // 房主直接使用邏輯座標
                    e.vX = e.x;
                    e.vY = e.y;
                }

                // 使用視覺座標進行 tx/ty 轉換
                const drawX = tx(e.vX);
                const drawY = ty(e.vY);

                const size = e.isBoss ? (e.size || 60) : 20;
                const renderSize = size;

                // 顏色判斷：Boss 顏色或玩家所屬顏色
                const color = e.isBoss ? (BOSS_TYPES[e.bossType]?.color || '#f00') : (e.owner === 'p1' ? '#3b82f6' : '#f472b6');

                if (e.isBoss) {
                    const bossImg = BOSS_TYPES[e.bossType]?.img;
                    if (bossImg && bossImg.complete) {
                        ctx.save();
                        // Boss 的呼吸縮放特效
                        const scale = 1 + Math.sin(Date.now() / 200) * 0.05;
                        ctx.translate(drawX, drawY);
                        ctx.scale(scale, scale);
                        ctx.drawImage(bossImg, -renderSize / 2, -renderSize / 2, renderSize, renderSize);
                        ctx.restore();
                    } else {
                        // 圖片未載入完成時的備援圓形
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(drawX, drawY, renderSize / 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else {
                    // 普通小怪畫正方形
                    ctx.fillStyle = color;
                    ctx.fillRect(drawX - renderSize / 2, drawY - renderSize / 2, renderSize, renderSize);
                }

                // 血條繪製 (位於怪物上方)
                const percent = Math.max(0, e.hp / e.maxHp);
                ctx.fillStyle = '#333';
                ctx.fillRect(drawX - 12, drawY - renderSize / 2 - 8, 24, 4); // 背景黑條
                ctx.fillStyle = '#22c55e';
                ctx.fillRect(drawX - 12, drawY - renderSize / 2 - 8, 24 * percent, 4); // 綠色血量
            });

            // 4. 畫子彈
            projectiles.forEach(p => {
                ctx.fillStyle = p.color || '#fff';
                ctx.beginPath(); ctx.arc(tx(p.x), ty(p.y), 4, 0, Math.PI * 2); ctx.fill();
            });

            // 5. 畫傷害與特效
            damagePopups.forEach(d => {
                ctx.fillStyle = d.color;
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(d.val, tx(d.x), ty(d.y));
                d.y -= 0.5; d.life--;
            });
            damagePopups = damagePopups.filter(d => d.life > 0);

            // 6. 畫黑洞
            blackHoles.forEach(bh => {
                const bx = tx(bh.x);
                const by = ty(bh.y);
                ctx.save();
                ctx.translate(bx, by);
                const rot = (Date.now() / 1000) * 2;
                ctx.rotate(rot);
                ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI * 2);
                ctx.fillStyle = '#000'; ctx.fill();
                ctx.strokeStyle = '#6366f1'; ctx.lineWidth = 2; ctx.stroke();

                // 吸入動畫
                for (let i = 0; i < 4; i++) {
                    ctx.rotate(Math.PI / 2);
                    ctx.beginPath(); ctx.moveTo(30 + Math.sin(Date.now() / 200) * 10, 0); ctx.lineTo(10, 0);
                    ctx.strokeStyle = 'rgba(99, 102, 241, 0.5)'; ctx.stroke();
                }
                ctx.restore();
            });

            // 拖曳中
            if (drag.isDragging && drag.dice) {
                // drag.currentX/Y 已經是 Input 座標
                // 在 handleInputMove 中我们需要根據 Guest 調整嗎？
                // 我們統一：drag.currentX/Y 儲存的是「螢幕/Canvas 像素座標」 (未經 tx/ty 轉換)
                // 但因為我們 drawDiceGrid 裡面用了 tx/ty，格子位置變了
                // 所以 InputEvent 裡面也需要做對應的逆轉換來判定格子?
                // 這裡單純畫拖曳物，直接畫在滑鼠位置即可
                renderDice(ctx, drag.currentX - grid.slotSize / 2, drag.currentY - grid.slotSize / 2, drag.dice, false);
            }
            ctx.restore();
        }

        function drawPath(path, color) {
            if (path.length < 2) return;
            ctx.save();
            ctx.beginPath();
            ctx.strokeStyle = color + '44'; // 淡色
            ctx.lineWidth = 30;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.moveTo(path[0].x, path[0].y);
            path.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.stroke();

            // 虛線
            ctx.strokeStyle = '#ffffff44';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 15]);
            ctx.stroke();
            ctx.restore();
        }

        function drawPortal(ctx, x, y, color, angle, isStart) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);

            // 外圈光環
            const gradient = ctx.createRadialGradient(0, 0, 10, 0, 0, 30);
            gradient.addColorStop(0, color);
            gradient.addColorStop(1, 'rgba(0,0,0,0)');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, 30, 0, Math.PI * 2);
            ctx.fill();

            // 旋轉紋路
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            for (let i = 0; i < 4; i++) {
                ctx.rotate(Math.PI / 2);
                ctx.beginPath();
                ctx.moveTo(10, 0);
                ctx.quadraticCurveTo(20, 10, 25, 0);
                ctx.stroke();
            }

            // 中心黑洞/亮點
            ctx.fillStyle = isStart ? '#000' : '#fff';
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0, Math.PI * 2);
            ctx.fill();

            // 標示文字 (START / END) - 不旋轉
            ctx.rotate(-angle - (role === 'guest' ? Math.PI : 0)); // 抵銷旋轉，並修正 Guest 視角
            // Guest 視角下 canvas 其實已經 rotate(PI) 了。
            // 這裡的 angle 是 portal 自己的動畫。
            // 我們希望文字永遠正向顯示?
            // Canvas has global rotate PI for guest.
            // Text drawn here will be upside down for Guest if we don't fix it?
            // No, the global rotate handles everything.
            // But if we want text to be readable "upright" relative to the player...
            // Guest sees P2 (Top) as Bottom.
            // Actually, let's keep it simple, just symbols.

            ctx.restore();
        }

        function drawDiceGrid(slots, owner) {
            const isP1 = owner === 'p1';
            // 計算區域 Offset
            // 沿用 getSlotPixelY 的邏輯，但為了畫 Grid 整體，我們重新算
            const totalH = grid.rows * (grid.slotSize + grid.padding);
            const startY = isP1 ?
                (canvas.height * 0.75) - (totalH / 2) :
                (canvas.height * 0.25) - (totalH / 2);

            const sideMargin = canvas.width * 0.12;

            slots.forEach(slot => {
                const rawX = sideMargin + grid.padding + slot.col * (grid.slotSize + grid.padding);
                const rawY = startY + slot.row * (grid.slotSize + grid.padding);

                // 應用視角轉換
                const drawX = tx(rawX);
                const drawY = ty(rawY);

                // 底座
                ctx.fillStyle = '#1e293b';
                drawRoundedRect(ctx, drawX, drawY, grid.slotSize, grid.slotSize, 8);
                ctx.fill();

                if (slot.dice && !slot.isBeingDragged) {
                    renderDice(ctx, drawX, drawY, slot.dice, slot.isLocked);
                }
            });
        }

        // 畫圓角矩形
        function drawRoundedRect(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y); ctx.lineTo(x + w - r, y); ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r); ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h); ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r); ctx.lineTo(x, y + r); ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
        }

        // --- 9. 操作事件 ---
        function setupTouchEvents() {
            // 統一轉換座標
            const getPos = (e) => {
                const rect = canvas.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                // 1. 先轉換為基礎邏輯座標 (500 width base)
                let x = (clientX - rect.left) * scaleFactor;
                let y = (clientY - rect.top) * scaleFactor;

                // 2. 【核心修正】如果是 Guest，點擊座標必須旋轉 180 度轉回邏輯座標
                // 因為視覺上你點的是下方，但邏輯上 P2 的骰子區是在上方
                if (role === 'guest') {
                    x = canvas.width - x;
                    y = canvas.height - y;
                }

                return { x, y };
            };

            // --- 以下監聽器部分維持你原本的代碼，不用動 ---
            canvas.addEventListener('mousedown', e => {
                const p = getPos(e);
                handleInputStart(p.x, p.y);
            });
            canvas.addEventListener('mousemove', e => {
                const p = getPos(e);
                handleInputMove(p.x, p.y);
            });
            window.addEventListener('mouseup', handleInputEnd);

            canvas.addEventListener('touchstart', e => {
                e.preventDefault();
                const p = getPos(e);
                handleInputStart(p.x, p.y);
            }, { passive: false });
            canvas.addEventListener('touchmove', e => {
                e.preventDefault();
                const p = getPos(e);
                handleInputMove(p.x, p.y);
            }, { passive: false });
            window.addEventListener('touchend', handleInputEnd);
        }

        function handleInputStart(x, y) {
            // x, y 已經是邏輯座標（getPos 轉換過了）

            const clicked = mySlots.find(slot => {
                // 直接取得邏輯座標
                const sx = getSlotPixelX(slot, role === 'host' ? 'p1' : 'p2');
                const sy = getSlotPixelY(slot, role === 'host' ? 'p1' : 'p2');

                // 不需要 tx/ty 轉換，直接比對邏輯座標
                return Math.abs(x - sx) < grid.slotSize / 2 + 5 &&
                    Math.abs(y - sy) < grid.slotSize / 2 + 5;
            });

            if (clicked && clicked.dice && !clicked.isLocked) {
                drag.isDragging = true;
                drag.fromSlot = clicked;
                drag.dice = { ...clicked.dice };
                drag.currentX = x;
                drag.currentY = y;
                clicked.isBeingDragged = true;
            }
        }

        function handleInputMove(x, y) {
            if (drag.isDragging) {
                drag.currentX = x;
                drag.currentY = y;
            }
        }

        function handleInputEnd() {
            if (!drag.isDragging) return;

            const lx = drag.currentX;
            const ly = drag.currentY;

            // 判定目標格（用邏輯座標比對）
            const target = mySlots.find(slot => {
                const sx = getSlotPixelX(slot, role === 'host' ? 'p1' : 'p2');
                const sy = getSlotPixelY(slot, role === 'host' ? 'p1' : 'p2');

                // 不需要 tx/ty 轉換
                return Math.abs(lx - sx) < grid.slotSize / 2 + 10 &&
                    Math.abs(ly - sy) < grid.slotSize / 2 + 10;
            });

            if (target && target !== drag.fromSlot) {
                // 合成邏輯
                if (target.dice && target.dice.id === drag.dice.id && target.dice.lv === drag.dice.lv && target.dice.lv < 7) {
                    const newId = userData.deck[Math.floor(Math.random() * userData.deck.length)];
                    const db = ALL_DICES.find(d => d.id === newId);
                    target.dice = {
                        id: newId, lv: drag.dice.lv + 1,
                        baseColor: db.baseColor
                    };
                    drag.fromSlot.dice = null;
                    syncMyData();
                } else if (!target.dice) {
                    // 移動
                    target.dice = drag.dice;
                    drag.fromSlot.dice = null;
                    syncMyData();
                }
            }

            drag.fromSlot.isBeingDragged = false;
            drag.isDragging = false;
            drag.fromSlot = null;
        }

        function handleSummonClick() {
            if (battleState.sp < battleState.summonCost) return;
            // 找空位
            const empties = mySlots.filter(s => !s.dice);
            if (empties.length === 0) return;

            battleState.sp -= battleState.summonCost;
            battleState.summonCost += 10;

            const target = empties[Math.floor(Math.random() * empties.length)];
            const diceId = userData.deck[Math.floor(Math.random() * userData.deck.length)];
            const db = ALL_DICES.find(d => d.id === diceId);

            target.dice = {
                id: diceId, lv: 1, baseColor: db.baseColor
            };

            syncMyData();
            updateUILive();
        }

        function powerUpDice(id) {
            const lv = powerUpLevels[id] || 1;
            const cost = 100 * Math.pow(2, lv - 1);
            if (battleState.sp >= cost && lv < 5) {
                battleState.sp -= cost;
                powerUpLevels[id] = lv + 1;
                syncMyData(); // Powerup 雖然不影響盤面結構，但會影響傷害，這部分 Host 算傷害時需要知道對方等級嗎？
                // 目前 syncMyData 只傳 slots.
                // 為了簡化，合作模式中「強化」只影響「自己」的傷害計算。
                // Host 幫 Guest 算傷害時，不知道 Guest 的等級。
                // 這是一個 bug。 Host 必須知道 Guest 的 diceLevels。
                // 修正：syncMyData 應該也要傳 diceLevels (powerUpLevels)。
                updateUI(); // 重新繪製按鈕
            }
        }
// 取得骰子特殊能力數值 (根據等級計算)
        function getDiceSpecialValue(diceId, diceLv = 1) {
            const dice = ALL_DICES.find(d => d.id === diceId);
            if (!dice || !dice.special) return 0;
            const userDataLvs = (userData && userData.diceLevels) ? userData.diceLevels : {};
            // 這裡的 Level 是指「帳號該骰子的等級」(power up level)，不是遊戲內的星數
            // 但為了簡單，這裡通常用外部等級。若要嚴謹應傳入 userData.diceLevels[diceId]
            const pLv = userDataLvs[diceId] || 1; 
            
            const base = dice.special.value || 0;
            const grow = dice.special.grow || 0;
            return base + (pLv - 1) * grow;
        }
        function updateUILive() {
            // 1. 同步純文字狀態
            document.getElementById('hpText').innerText = battleState.hp;
            document.getElementById('spText').innerText = Math.floor(battleState.sp);
            document.getElementById('waveText').innerText = battleState.wave;
            document.getElementById('summonCostText').innerText = battleState.summonCost;

            // 2. 局部更新按鈕狀態 (只改顏色，不重繪 DOM)
            // 只有在 SP 變動影響到「買得起/買不起」的狀態時，視覺才需要變
            const currentSp = battleState.sp;

            userData.deck.forEach(id => {
                const btn = document.getElementById(`btn-power-${id}`);
                const costEl = document.getElementById(`cost-power-${id}`);
                if (!btn) return;

                const lv = powerUpLevels[id] || 1;
                const cost = 100 * Math.pow(2, lv - 1);
                const isMax = lv >= 5;

                // 處理邊框顏色
                // 如果滿等 -> 金色
                // 如果買得起 -> 藍色
                // 否則 -> 灰色
                // 我們直接操作 classList 比較安全，但因為有 tailwind class 混雜，可以暴力替換 border-*

                // 清除舊的 border color class
                btn.classList.remove('border-yellow-500', 'border-blue-500', 'border-slate-700', 'shadow-[0_0_5px_rgba(234,179,8,0.3)]');

                if (isMax) {
                    btn.classList.add('border-yellow-500', 'shadow-[0_0_5px_rgba(234,179,8,0.3)]');
                } else if (currentSp >= cost) {
                    btn.classList.add('border-blue-500');
                } else {
                    btn.classList.add('border-slate-700');
                }
            });
        }

        function updateUI() {
            const container = document.getElementById('powerUpButtons');
            if (!container) return;

            // 產生強化按鈕 (完全移植 dice_battle 風格)
            container.innerHTML = userData.deck.map((id) => {
                const dice = ALL_DICES.find(d => d.id === id);
                const lv = powerUpLevels[id] || 1;
                const cost = 100 * Math.pow(2, lv - 1);
                const q = QUALITIES[dice.quality] || QUALITIES.common;
                const isMax = lv >= 5;
                const costDisplay = isMax ? "MAX" : `${cost >= 1000 ? (cost / 1000).toFixed(1) + 'k' : cost} SP`;
                const costColor = isMax ? "text-orange-500" : "text-slate-400";
                const borderColor = isMax ? "border-yellow-500 shadow-[0_0_5px_rgba(234,179,8,0.3)]" :
                    (battleState.sp >= cost ? 'border-blue-500' : 'border-slate-700');

                // 注意：這裡我們在按鈕內放一個 canvas 畫骰子圖
                return `
                <button id="btn-power-${id}" onclick="${isMax ? '' : `powerUpDice('${id}')`}" 
                    class="flex-1 min-w-[70px] bg-slate-800 border ${borderColor} rounded-lg py-1.5 flex flex-col items-center ${isMax ? '' : 'active:scale-95'} transition-all mx-1">
                    <div class="w-8 h-8 rounded bg-white relative mb-1 overflow-hidden" style="border: 1px solid ${q.color}">
                        <canvas id="pwr-canvas-${id}" width="32" height="32" class="absolute inset-0 pointer-events-none"></canvas>
                    </div>
                    <div class="text-[9px] text-yellow-500 font-bold leading-none">Lv.${lv}</div>
                    <div id="cost-power-${id}" class="text-[8px] ${costColor} mt-1 font-bold tracking-tighter">${costDisplay}</div>
                </button>`;
            }).join('');

            // 繪製按鈕上的小骰子
            setTimeout(() => {
                userData.deck.forEach(id => {
                    const dice = ALL_DICES.find(d => d.id === id);
                    const canvas = document.getElementById(`pwr-canvas-${id}`);
                    if (canvas && dice) {
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        // 使用新的 drawDiceFeature
                        drawDiceFeature(ctx, 0, 0, canvas.width, dice.pattern || dice.id, dice.baseColor);
                    }
                });
            }, 0);
        }

        function initUI() {
            updateUI();
        }



        // 啟動
        init();
        // ... (原本的 init();) ...

        // --- 新增：安全離開與資料庫清理 ---

        function quitGame() {
            // 觸發頁面跳轉，這會自動呼叫下方的 beforeunload 事件
            window.location.href = 'dice.html';
        }

        // 確保有房號才執行清理註冊
        if (roomId) {
            const roomRef = db.ref('coop_rooms/' + roomId);

            if (role === 'host') {
                // 【房主 HOST】
                // 1. 設定 "意外斷線" (由 Firebase 伺服器端執行) 自動刪除整個房間
                roomRef.onDisconnect().remove();

                // 2. 設定 "正常離開/關閉視窗" (由瀏覽器端執行) 立即刪除
                window.addEventListener('beforeunload', () => {
                    roomRef.remove();
                });
            } else {
                // 【訪客 GUEST】
                // 1. 設定 "意外斷線" 只刪除 p2 節點
                const p2Ref = roomRef.child('players/p2');
                p2Ref.onDisconnect().remove();

                // 2. 設定 "正常離開/關閉視窗" 立即刪除 p2
                window.addEventListener('beforeunload', () => {
                    p2Ref.remove();
                });
            }
        }

        function handleGameOver() {
            // 預防機制：如果已經處理過 GameOver 就跳過，避免重複上傳排行榜
            if (battleState.gameOverHandled) return;
            battleState.gameOverHandled = true;

            battleState.isStarted = false;

            // 1. 更新本地紀錄 (遵守你的 LocalStorage 保護原則)
            if (battleState.wave > userData.maxWave) {
                userData.maxWave = battleState.wave;
                localStorage.setItem('dice_game_data', JSON.stringify(userData));
            }

            // 2. 斷開 Firebase 監聽 (重要！節省流量與手機電力)
            if (roomRef) {
                roomRef.off(); // 停止接收數據更新
            }

            // 3. 上傳排行榜 (僅由 Host 執行一次)
            if (role === 'host') {
                // 先在 Realtime DB 標記遊戲結束，讓 Guest 也能跳出視窗
                db.ref(`coop_rooms/${roomId}`).update({ gameover: true });

                db.ref(`coop_rooms/${roomId}`).once('value').then(snap => {
                    const data = snap.val();
                    if (!data) return;

                    const p1Name = data.players.p1?.name || "房主";
                    const p2Name = data.players.p2?.name || "隊友";

                    const namesElement = document.getElementById('player-names');
                    if (namesElement) {
                        namesElement.innerText = `${p1Name} & ${p2Name}`;
                    }
                    // 只有波數大於 1 才紀錄，避免無效數據佔用 Firestore 配額
                    if (battleState.wave > 1) {
                        fs.collection('leaderboard').add({
                            playerNames: winnerText, // 存入組合名稱
                            p1Name: p1Name,
                            p2Name: p2Name,
                            wave: battleState.wave,
                            timestamp: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    }
                });
            }

            // 4. 顯示結算畫面
            document.getElementById('final-wave').innerText = battleState.wave;
            document.getElementById('game-over-modal').classList.remove('hidden');
        }

        // --- 繪圖函式 (移植自 dice_battle) ---
        function renderDice(ctx, x, y, dice, isLocked) {
            if (!dice) return;
            const slotSize = grid.slotSize;

            // 為了取得品質顏色 (Common/Rare/Epic 的白框)
            const dbRef = ALL_DICES.find(d => d.id === dice.id);
            const q = QUALITIES[dbRef ? dbRef.quality : 'common'];

            // 1. 畫外框 (普通品質顏色)
            ctx.beginPath();
            ctx.strokeStyle = q.color || '#fff';
            ctx.lineWidth = 3;
            drawRoundedRect(ctx, x + 4, y + 4, slotSize - 8, slotSize - 8, 8);
            ctx.stroke();

            // 2. 畫填充背景 (白色)
            ctx.beginPath();
            ctx.fillStyle = "#ffffff";
            drawRoundedRect(ctx, x + 6, y + 6, slotSize - 12, slotSize - 12, 6);
            ctx.fill();

            const dColor = dice.baseColor || "#333";
            const pattern = (dbRef && dbRef.pattern) ? dbRef.pattern : dice.id;
            const drawX = x + 6;
            const drawY = y + 6;
            const drawSize = slotSize - 12;

            // 3. 畫特徵圖案
            if (typeof drawDiceFeature === 'function') {
                drawDiceFeature(ctx, drawX, drawY, drawSize, pattern, dColor);
            }

            // --- 新增：這裡是關鍵，呼叫剛才加的特效函式 ---
            // 放在特徵之後、星星之前，這樣特效框會蓋在圖案上但不會遮住星星
            if (typeof drawQualityBorder === 'function') {
                drawQualityBorder(ctx, x, y, slotSize, dice.id);
            }

            // 4. 畫點數 (星級)
            if (typeof drawDiceStars === 'function') {
                drawDiceStars(ctx, drawX, drawY, drawSize, dice.lv, dColor);
            }

            // 5. 鎖定遮罩
            if (isLocked) {
                ctx.save();
                ctx.beginPath();
                ctx.fillStyle = "rgba(15, 23, 42, 0.75)";
                drawRoundedRect(ctx, x + 5, y + 5, slotSize - 10, slotSize - 10, 8);
                ctx.fill();
                ctx.beginPath();
                ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
                ctx.lineWidth = 2;
                const p = slotSize * 0.3;
                ctx.moveTo(x + p, y + p); ctx.lineTo(x + slotSize - p, y + slotSize - p);
                ctx.moveTo(x + slotSize - p, y + p); ctx.lineTo(x + p, y + slotSize - p);
                ctx.stroke();
                ctx.restore();
            }
        }

        function drawDiceFeature(ctx, x, y, size, pattern, diceColor) {
            if (!pattern) return;

            const m = size / 2;
            ctx.save();
            ctx.translate(x, y);

            const r = parseInt(diceColor.slice(1, 3), 16);
            const g = parseInt(diceColor.slice(3, 5), 16);
            const b = parseInt(diceColor.slice(5, 7), 16);
            ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.3)`; // 稍微加深一點點，更明顯
            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.12)`;
            ctx.lineWidth = 4;
            ctx.lineCap = "round";
            ctx.lineJoin = "round";

            switch (pattern) {
                // --- Common ---
                case 'fire':
                    ctx.beginPath();
                    ctx.moveTo(m, size * 0.2); ctx.lineTo(size * 0.8, size * 0.8); ctx.lineTo(size * 0.2, size * 0.8);
                    ctx.closePath(); ctx.stroke(); ctx.fill();
                    break;
                case 'ice':
                    ctx.beginPath(); ctx.arc(m, m, size * 0.35, 0, Math.PI * 2);
                    ctx.moveTo(m, size * 0.1); ctx.lineTo(m, size * 0.9);
                    ctx.moveTo(size * 0.1, m); ctx.lineTo(size * 0.9, m);
                    ctx.stroke();
                    break;
                case 'wind':
                    ctx.beginPath();
                    for (let i = -1; i <= 1; i++) {
                        ctx.moveTo(size * 0.2, m + (i * 12)); ctx.lineTo(size * 0.8, m + (i * 12));
                    }
                    ctx.stroke();
                    break;
                case 'electric':
                    ctx.beginPath();
                    ctx.moveTo(m + 5, size * 0.15); ctx.lineTo(m - 10, m + 5);
                    ctx.lineTo(m + 10, m - 5); ctx.lineTo(m - 5, size * 0.85);
                    ctx.stroke();
                    break;
                case 'poison':
                    ctx.beginPath();
                    ctx.moveTo(m, size * 0.2); ctx.lineTo(size * 0.75, m);
                    ctx.lineTo(m, size * 0.8); ctx.lineTo(size * 0.25, m);
                    ctx.closePath(); ctx.stroke(); ctx.fill();
                    break;

                // --- Rare & Epic ---
                case 'laser_beam': // 雷射：科技感十字準星 + 脈衝光環
                    // 1. 外圈旋轉光環
                    ctx.save();
                    ctx.translate(m, m);
                    ctx.rotate(Date.now() / 500);
                    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.4)`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.35, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();

                    // 2. 中心十字線 (準星)
                    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.8)`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(m - size * 0.2, m); ctx.lineTo(m + size * 0.2, m);
                    ctx.moveTo(m, m - size * 0.2); ctx.lineTo(m, m + size * 0.2);
                    ctx.stroke();

                    // 3. 四個角落定位點
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.6)`;
                    const corners = [
                        [size * 0.15, size * 0.15],
                        [size * 0.85, size * 0.15],
                        [size * 0.15, size * 0.85],
                        [size * 0.85, size * 0.85]
                    ];
                    corners.forEach(([cx, cy]) => {
                        ctx.beginPath();
                        ctx.arc(cx, cy, 2, 0, Math.PI * 2);
                        ctx.fill();
                    });

                    // 4. 中心發光點
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.9)`;
                    ctx.beginPath();
                    ctx.arc(m, m, size * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'lock': // 鎖定：方框中帶一個圓點
                    ctx.strokeRect(size * 0.25, size * 0.25, size * 0.5, size * 0.5);
                    ctx.beginPath(); ctx.arc(m, m, 4, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'teleport': // 傳送：兩個漩渦括號
                    ctx.beginPath();
                    ctx.arc(size * 0.3, m, size * 0.3, -Math.PI / 2, Math.PI / 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(size * 0.7, m, size * 0.3, Math.PI / 2, -Math.PI / 2);
                    ctx.stroke();
                    break;
                case 'gear': // 齒輪：外圈八個齒（用虛線模擬）
                    ctx.beginPath();
                    ctx.setLineDash([5, 5]);
                    ctx.arc(m, m, size * 0.35, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]); // 恢復實線
                    ctx.beginPath(); ctx.arc(m, m, size * 0.15, 0, Math.PI * 2); ctx.stroke();
                    break;

                // --- Legend ---
                case 'mighty_wind': // 強風：多重氣流線條
                    ctx.beginPath();
                    for (let i = -1; i <= 1; i++) {
                        ctx.moveTo(size * 0.2, m + i * size * 0.15);
                        ctx.bezierCurveTo(m, m + i * size * 0.4, m, m - i * size * 0.4, size * 0.8, m + i * size * 0.15);
                    }
                    ctx.stroke();
                    break;

                // --- 聖域 (Sanctuary) 光環圓圈 ---
                case 'sanctuary':
                    // 1. 外圈光環
                    ctx.beginPath();
                    ctx.arc(m, m, size * 0.35, 0, Math.PI * 2);
                    ctx.stroke();
                    // 2. 中圈光環
                    ctx.beginPath();
                    ctx.arc(m, m, size * 0.25, 0, Math.PI * 2);
                    ctx.stroke();
                    // 3. 中心十字
                    ctx.beginPath();
                    ctx.moveTo(m - size * 0.1, m); ctx.lineTo(m + size * 0.1, m);
                    ctx.moveTo(m, m - size * 0.1); ctx.lineTo(m, m + size * 0.1);
                    ctx.stroke();
                    // 4. 四個光點
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.6)`;
                    [0, 90, 180, 270].forEach(angle => {
                        const rad = angle * Math.PI / 180;
                        const px = m + Math.cos(rad) * size * 0.3;
                        const py = m + Math.sin(rad) * size * 0.3;
                        ctx.beginPath();
                        ctx.arc(px, py, size * 0.04, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    break;

                // --- 彗星 (Comet) 彗星拖尾 ---
                case 'comet':
                    // 1. 彗星本體
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.8)`;
                    ctx.beginPath();
                    ctx.arc(size * 0.65, size * 0.35, size * 0.12, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    // 2. 拖尾（三條流光）
                    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.5)`;
                    for (let i = -1; i <= 1; i++) {
                        ctx.beginPath();
                        ctx.moveTo(size * 0.65, size * 0.35);
                        ctx.quadraticCurveTo(
                            size * 0.4, size * 0.5 + i * size * 0.1,
                            size * 0.15, size * 0.7 + i * size * 0.15
                        );
                        ctx.stroke();
                    }
                    // 3. 尾部星點
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.4)`;
                    [[0.3, 0.55], [0.2, 0.65], [0.15, 0.75]].forEach(([px, py]) => {
                        ctx.beginPath();
                        ctx.arc(size * px, size * py, size * 0.03, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    break;

                // --- 連鎖 (Chain) 閃電鏈 ---
                case 'chain':
                    // 三個目標點
                    const chainPoints = [
                        [size * 0.2, size * 0.25],
                        [size * 0.5, size * 0.65],
                        [size * 0.8, size * 0.35]
                    ];
                    // 繪製閃電連線
                    ctx.lineWidth = 2.5;
                    for (let i = 0; i < chainPoints.length - 1; i++) {
                        const [x1, y1] = chainPoints[i];
                        const [x2, y2] = chainPoints[i + 1];
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        // 鋸齒效果
                        const segments = 3;
                        for (let s = 1; s <= segments; s++) {
                            const t = s / segments;
                            const mx = x1 + (x2 - x1) * t;
                            const my = y1 + (y2 - y1) * t;
                            const offset = (s % 2 === 0 ? 1 : -1) * size * 0.08;
                            ctx.lineTo(mx + offset, my);
                        }
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                    // 繪製目標點
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.7)`;
                    chainPoints.forEach(([px, py]) => {
                        ctx.beginPath();
                        ctx.arc(px, py, size * 0.06, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    break;

                // --- 毀滅 (Doom) 末日時鐘 ---
                case 'doom':
                    // 1. 時鐘外圈
                    ctx.beginPath();
                    ctx.arc(m, m, size * 0.35, 0, Math.PI * 2);
                    ctx.stroke();
                    // 2. 12點刻度
                    [0, 90, 180, 270].forEach(angle => {
                        const rad = angle * Math.PI / 180 - Math.PI / 2;
                        const x1 = m + Math.cos(rad) * size * 0.3;
                        const y1 = m + Math.sin(rad) * size * 0.3;
                        const x2 = m + Math.cos(rad) * size * 0.35;
                        const y2 = m + Math.sin(rad) * size * 0.35;
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    });
                    // 3. 指針（指向12點 - 死亡象徵）
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.9)`;
                    ctx.beginPath();
                    ctx.moveTo(m, m);
                    ctx.lineTo(m, m - size * 0.25);
                    ctx.stroke();
                    // 4. 中心點
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.8)`;
                    ctx.beginPath();
                    ctx.arc(m, m, size * 0.06, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'joker': // 小丑：倒三角形加上上方兩點
                    ctx.beginPath();
                    ctx.moveTo(size * 0.2, size * 0.3); ctx.lineTo(size * 0.8, size * 0.3);
                    ctx.lineTo(m, size * 0.8); ctx.closePath(); ctx.stroke();
                    ctx.beginPath(); ctx.arc(size * 0.35, size * 0.2, 3, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(size * 0.65, size * 0.2, 3, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'growth': // 成長：向上的箭頭
                    ctx.beginPath();
                    ctx.moveTo(m, size * 0.15); ctx.lineTo(m, size * 0.85);
                    ctx.moveTo(m, size * 0.15); ctx.lineTo(size * 0.3, size * 0.4);
                    ctx.moveTo(m, size * 0.15); ctx.lineTo(size * 0.7, size * 0.4);
                    ctx.stroke();
                    break;
                case 'sun': // 太陽：圓形放射狀 (優化版：縮小射線範圍，避開星數點點)
                    // 1. 中心圓縮小一點點
                    ctx.beginPath();
                    ctx.arc(m, m, size * 0.15, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.fill();

                    // 2. 射線調整：縮短長度，並將線條變細，避免干擾
                    ctx.lineWidth = 2; // 射線用細線
                    for (let i = 0; i < 8; i++) {
                        ctx.save();
                        ctx.translate(m, m);
                        // 旋轉 22.5 度 (Math.PI / 8)，讓射線錯開正方形的四角與正中心
                        ctx.rotate((i * Math.PI / 4) + (Math.PI / 8));
                        ctx.beginPath();
                        // 射線從中心 0.22 延伸到 0.32，確保它留在骰子中間區域，不碰到邊緣的星點
                        ctx.moveTo(0, -size * 0.22);
                        ctx.lineTo(0, -size * 0.32);
                        ctx.stroke();
                        ctx.restore();
                    }
                    // 恢復原始線寬供後續圖形使用
                    ctx.lineWidth = 4;
                    break;

                // --- Mythic ---
                case 'galaxy': // 銀河：旋渦狀 S 型
                    ctx.beginPath();
                    ctx.moveTo(m, size * 0.1);
                    ctx.bezierCurveTo(size * 0.9, size * 0.1, size * 0.1, size * 0.9, m, size * 0.9);
                    ctx.stroke();
                    ctx.beginPath(); ctx.arc(m, m, size * 0.1, 0, Math.PI * 2); ctx.fill();
                    break;
                // --- 易傷 (Crack) 外觀：碎裂水晶效果 ---
                case 'crack':
                    // 1. 中心爆裂點
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.5)`;
                    ctx.beginPath();
                    ctx.arc(m, m, size * 0.12, 0, Math.PI * 2);
                    ctx.fill();

                    // 2. 多方向裂紋擴散
                    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.7)`;
                    ctx.lineWidth = 2.5;
                    const crackAngles = [0, 45, 90, 135, 180, 225, 270, 315];
                    crackAngles.forEach(angle => {
                        const rad = angle * Math.PI / 180;
                        const x1 = m + Math.cos(rad) * size * 0.12;
                        const y1 = m + Math.sin(rad) * size * 0.12;
                        const x2 = m + Math.cos(rad) * size * 0.42;
                        const y2 = m + Math.sin(rad) * size * 0.42;

                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    });

                    // 3. 外圍碎片點綴
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.4)`;
                    [0.1, 0.25, 0.75, 0.9].forEach(ratio => {
                        ctx.beginPath();
                        ctx.arc(size * ratio, size * 0.15, 1.5, 0, Math.PI * 2);
                        ctx.arc(size * ratio, size * 0.85, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    break;

                // --- 礦山 (Mine) 外觀：一個 T 字型的鎬頭 ---
                case 'mine':
                    ctx.beginPath();
                    // 鎬頭的弧形金屬部分
                    ctx.moveTo(size * 0.25, size * 0.35);
                    ctx.quadraticCurveTo(m, size * 0.15, size * 0.75, size * 0.35);
                    ctx.stroke();
                    // 鎬頭的木柄
                    ctx.beginPath();
                    ctx.moveTo(m, size * 0.25);
                    ctx.lineTo(m, size * 0.75);
                    ctx.stroke();
                    // 裝飾一個小錢幣圓點
                    ctx.beginPath();
                    ctx.arc(m + size * 0.15, size * 0.7, size * 0.08, 0, Math.PI * 2);
                    ctx.fill(); ctx.stroke();
                    break;
            }
            ctx.restore();
        }

        function drawDiceStars(ctx, x, y, size, stars, diceColor) {
            if (stars >= 7) {
                ctx.save();
                ctx.fillStyle = "#fbbf24";
                ctx.font = `bold ${size * 0.7}px Arial`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText("★", x + size / 2, y + size / 2 + size * 0.05);
                ctx.restore();
                return;
            }

            ctx.fillStyle = diceColor || "#333";
            const dotSize = size * 0.07;
            const p = size * 0.22;
            const m = size / 2;
            const l = p, r = size - p;
            const t = p, b = size - p;

            let dots = [];
            if (stars === 1) dots = [[m, m]];
            else if (stars === 2) dots = [[l, t], [r, b]];
            else if (stars === 3) dots = [[l, t], [m, m], [r, b]];
            else if (stars === 4) dots = [[l, t], [r, t], [l, b], [r, b]];
            else if (stars === 5) dots = [[l, t], [r, t], [m, m], [l, b], [r, b]];
            else if (stars === 6) dots = [[l, t], [r, t], [l, m], [r, m], [l, b], [r, b]];

            dots.forEach(dot => {
                ctx.beginPath();
                ctx.arc(x + dot[0], y + dot[1], dotSize, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        // --- 新增：品質邊框特效 (從 Dice Battle 移植) ---
       // --- 高效能版：品質邊框特效 (移除 setTransform 通用版) ---
        function drawQualityBorder(ctx, x, y, size, diceId) {
            if (!diceId) return;
            const db = ALL_DICES.find(d => d.id === diceId);
            if (!db) return;

            const quality = db.quality;
            if (quality !== 'legend' && quality !== 'mythic') return;

            const time = Date.now() / 1000;

            ctx.save();
            // 修正：移除 setTransform，直接 translate 即可
            // 這樣無論是在大廳(dice.html)還是戰鬥(dice_battle.html)都通用
            ctx.translate(x, y);

            if (quality === 'legend') {
                // --- 傳說 (Legend) ---
                const shimmer = (Math.sin(time * 3) + 1) / 2;

                // 1. 底層光暈
                ctx.strokeStyle = `rgba(234, 179, 8, ${0.3 + shimmer * 0.2})`;
                ctx.lineWidth = 6;
                ctx.beginPath();
                drawRoundedRect(ctx, 1, 1, size - 2, size - 2, 8);
                ctx.stroke();

                // 2. 核心金框
                const grad = ctx.createLinearGradient(0, 0, size, size);
                grad.addColorStop(0, '#B8860B');
                grad.addColorStop(0.5 + Math.sin(time) * 0.2, '#FFD700');
                grad.addColorStop(1, '#B8860B');

                ctx.strokeStyle = grad;
                ctx.lineWidth = 2.5;
                ctx.beginPath();
                drawRoundedRect(ctx, 3, 3, size - 6, size - 6, 8);
                ctx.stroke();

                // 3. 實體黃金護角
                ctx.fillStyle = "#FFD700";
                const offset = 4;
                const cornerW = 3.5;
                
                ctx.fillRect(0, offset, cornerW, cornerW); ctx.fillRect(offset, 0, cornerW, cornerW); // 左上
                ctx.fillRect(size - cornerW, offset, cornerW, cornerW); ctx.fillRect(size - offset - cornerW, 0, cornerW, cornerW); // 右上
                ctx.fillRect(size - cornerW, size - offset - cornerW, cornerW, cornerW); ctx.fillRect(size - offset - cornerW, size - cornerW, cornerW, cornerW); // 右下
                ctx.fillRect(0, size - offset - cornerW, cornerW, cornerW); ctx.fillRect(offset, size - cornerW, cornerW, cornerW); // 左下

            } else if (quality === 'mythic') {
                // --- 神話 (Mythic) ---
                const hue = (time * 60) % 360;

                // 1. 霓虹底光
                ctx.strokeStyle = `hsla(${hue}, 100%, 50%, 0.25)`;
                ctx.lineWidth = 6;
                ctx.beginPath();
                drawRoundedRect(ctx, 2, 2, size - 4, size - 4, 10);
                ctx.stroke();

                // 2. 虛線流動
                ctx.strokeStyle = `hsla(${hue}, 100%, 80%, 0.9)`;
                ctx.lineWidth = 2;
                ctx.setLineDash([8, 6]);
                ctx.lineDashOffset = -time * 25;
                ctx.beginPath();
                drawRoundedRect(ctx, 2, 2, size - 4, size - 4, 10);
                ctx.stroke();
                ctx.setLineDash([]);

                // 3. 懸浮能量支架 (L型)
                ctx.strokeStyle = `hsla(${(hue + 180) % 360}, 100%, 75%, 0.9)`;
                ctx.lineCap = "round";
                ctx.lineWidth = 3;
                const cLen = size * 0.15;
                const cOff = 1.5;

                ctx.beginPath();
                // 左上 L
                ctx.moveTo(cOff, cOff + cLen); ctx.lineTo(cOff, cOff); ctx.lineTo(cOff + cLen, cOff);
                // 右上 L
                ctx.moveTo(size - cOff - cLen, cOff); ctx.lineTo(size - cOff, cOff); ctx.lineTo(size - cOff, cOff + cLen);
                // 右下 L
                ctx.moveTo(size - cOff, size - cOff - cLen); ctx.lineTo(size - cOff, size - cOff); ctx.lineTo(size - cOff - cLen, size - cOff);
                // 左下 L
                ctx.moveTo(cOff + cLen, size - cOff); ctx.lineTo(cOff, size - cOff); ctx.lineTo(cOff, size - cOff - cLen);
                ctx.stroke();

                // 4. 角落能量點
                ctx.fillStyle = "#fff";
                const dotSize = 1.5;
                ctx.beginPath();
                ctx.arc(cOff, cOff, dotSize, 0, Math.PI * 2);
                ctx.arc(size - cOff, cOff, dotSize, 0, Math.PI * 2);
                ctx.arc(size - cOff, size - cOff, dotSize, 0, Math.PI * 2);
                ctx.arc(cOff, size - cOff, dotSize, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }
    </script>
    <!-- Game Over Modal -->
    <div id="game-over-modal"
        class="fixed inset-0 bg-black/80 flex items-center justify-center z-[100] hidden backdrop-blur-sm">
        <div class="bg-slate-800 p-8 rounded-2xl border border-slate-600 text-center max-w-sm mx-4 shadow-2xl">
            <h2 class="text-3xl font-black text-white mb-2 tracking-wider">GAME OVER</h2>

            <p class="text-slate-400 mb-2 text-lg">共堅持了
                <span id="final-wave" class="text-yellow-400 font-bold text-3xl mx-1">0</span> 波
            </p>

            <div class="mb-8 py-2 px-4 bg-slate-900/50 rounded-lg inline-block">
                <p class="text-slate-500 text-xs uppercase tracking-widest mb-1">團隊</p>
                <div id="player-names" class="text-blue-300 font-medium">載入中...</div>
            </div>

            <button onclick="quitGame()"
                class="w-full py-4 bg-gradient-to-r from-blue-600 to-indigo-600 rounded-xl font-bold text-white text-xl shadow-lg active:scale-95 transition-all hover:scale-105">
                返回大廳
            </button>
        </div>
    </div>
</body>

</html>